{"./":{"url":"./","title":"Getting Started","keywords":"","body":"Cocos2d-x v3 Docs Q4 2019 r.3 ======= Authors: SlackMoehrle, Minggo, Walzer, Jare Special Thanks: To our users! Without you there is no reason to even write this guide. Please provide feedback for this guide on GitHub For offline viewing, you can download a copy of our: For offline viewing, you can download a copy of our: Creator 1.9 Creator 1.10 Creator 2.0 Creator 2.1 Creator 2.2 deprecated legacy documentation deprecated WIKI Cocos2d-x Latest API Reference "},"about/getting_started.html":{"url":"about/getting_started.html","title":"About Cocos2d-x","keywords":"","body":"Where to get Cocos2d-x and what do I get? You can clone the GitHub Repo and follow the steps in the README. You can also download as part of the Cocos package on our download page. No matter if you choose to develop in C++, JavaScript or Lua, everything you need is in one package. The Cocos family of products has a few different pieces. Cocos2d-x - this is the game engine, itself. It includes the engine and the cocos command-line tool. You can download a production release or stay bleeding edge by cloning our GitHub Repo. Cocos Creator - is a unified game development tool. You can create your entire game, from start to finish, using this tool. It uses JavaScript natively and can export to C++. Read more about Cocos Creator. Cocos Launcher - is EOL'd. No replacement. Coco Studio - is EOL'd and has been replaced by Cocos Creator. Code IDE - is EOL'd. Common text editors and IDE's can be used instead. Conventions used in this documentation auto is used for creating local variables. using namespace cocos2d; is used to shorten types. each chapter has a compilable source code sample to demonstrate concepts. class names, methods names and other API components are rendered using fixed fonts. eg: Sprite. italics are used to notate concepts and keywords. "},"about/why.html":{"url":"about/why.html","title":"Why Cocos2d-x","keywords":"","body":"Why choose Cocos2d-x Why would you want to choose Cocos2d-x over other available game engines? Modern C++ API (please refer to the modernizing done in version 3.0) Cross-platform - desktop and mobile Capability to test and debug your game on the desktop and then push it to a mobile or desktop target A vast API of functionality including sprites, actions, animations, particles, transitions, timers, events (touch, keyboard, accelerometer, mouse), sound, file IO, persistence, skeletal animations, 3D "},"about/learn.html":{"url":"about/learn.html","title":"How to learn","keywords":"","body":"Learning Resources This very guide! Android Fundamentals Make School Tutorials Timberman Clone Game of Life Games From Scratch Cocos2d-x tutorial series Cocos Ceator tutorial "},"about/help.html":{"url":"about/help.html","title":"Where to get help","keywords":"","body":"Where to get help Forums Bug Tracker cpp-tests project. This project is our basis for testing. Use this project to learn how we implement the functionality of the engine. This project is located in Cocos2d-x_root/build. API Reference. "},"about/how.html":{"url":"about/how.html","title":"How to contribute","keywords":"","body":"How to contribute to our projects Contributing to these docs We always welcome contributions to our documentation. Fork our docs repo en/ is for English contributions, zh/ is for 中文 contributions. code blocks must be wrapped in a markdown codeblock. For Markdown help, please see GitHub Flavored Markdown Test your changes using gitbook build and gitbook serve. Please test in a few web browsers. Submit a pull request with your changes and we will review and merge it. Contributing to cocos2d-x For general questions You can ask general questions by using: Forum (preferred way) Weibo Twitter Reporting bugs To report bugs, please use the Issue Tracker Steps to report a bug: Create a new GitHub issue here Add all the needed information to reproduce the bug, the information include engine version steps to reproduce the bug some pseudocode resources link if needed Submitting patches If you want to contribute code, please follow these steps: (If you are new to git and/or GitHub, you should read Pro Git , especially the section on Contributing to a project:Small/Large Public Project ) Download the latest cocos2d-x develop branch from github:$ git clone git://github.com/cocos2d/cocos2d-x.git $ cd cocos2d-x $ git checkout v3 $ ./download-deps.py $ git submodule update --init Apply your changes in the recently downloaded repository Commit your changes in your own repository Create a new branch with your patch: $ git checkout -b my_fix_branch Push your new branch to your public repository Send a “pull request” to user “cocos2d” It must be complete. See the definition below It must follow the Releases rules. See the definition below Only complete patches will be merged The patch must be complete. By that, we mean: For C++ code follow the Cocos2d C++ Coding Style For Python code follow the PEP8 guidelines Describe what the patch does Include test cases if applicable Include unit tests if applicable Must be tested in all supported platforms. If you don't have access to test your code in all the supported platforms, let us know. Must NOT degrade the performance Must NOT break existing tests cases Must NOT break the Continuous Integration build Must NOT break backward compatibility Must compile WITHOUT warnings New APIs MUST be easy to use, familiar to cocos2d-x users Code MUST be easy to extend and maintain Must have documentation: C++ APIs must use Doxygen strings, tools must have a README.md file that describe how to use the tool Must be efficient (fast / low memory needs) It must not duplicate existing code, unless the new code deprecates the old one Patches that refactor key components will only be merged in the next major versions. Promoting cocos2d-x Help us promote cocos2d-x by using the cocos2d-x logo in your game, or by mentioning cocos2d-x in the credits. Spreading the word! You can help us spread the word about Cocos2d-x! We would surely appreciate it! Talk about us on Facebook! Our Facebook Page Tweet, Tweet! Our Twitter Read our Blog and promote it on your social media. Become a Regional Coordinator "},"basic_concepts/":{"url":"basic_concepts/","title":"Basic Cocos2d-x Concepts","keywords":"","body":"Basic Cocos2d-x Concepts This chapter assumes you've just gotten started with Cocos2d-x, and are ready to start working on the game of your dreams. Don't worry, it will be fun! Let's get started! Cocos2d-x is a cross-platform game engine. A game engine is a piece of software that provides common functionality that all games need. You might have heard this referred to as an API or framework but in this guide, we'll be calling it a game engine. Game engines include many components that when used together will help speed up development time, and often perform better than homemade engines. A game engine is usually comprised of some or all of the following components: a renderer, 2d/3d graphics, collision detection, a physics engine, sound, controller support, animations, sequences and more. To be sure we are all on the same page, we should review common game terminology: Director: You can think of the Director the same way you think about a movie director. The Director controls every aspect of your game. What is shown on the screen, what sounds are played, what happens with player input, and much more. Scene: A Scene is a container that holds Sprites, Labels, Nodes and other objects that your game needs. A Scene is responsible for running game logic and rendering the content on a per-frame basis. Sprite: A Sprite is a 2D image that can be animated or transformed by changing its properties. Most all games will have multiple Sprite objects ranging from the hero, an enemy or a level boss. Scene Graph: The scene graph is a data structure that arranges a graphical scene, into a tree structure. This tree structure is what is used to render objects onscreen in a specific order. Renderer: In an oversimplified definition the renderer is responsible for taking everything you want on the screen and getting it there, technically. No need to delve into this further at this time. Events: What do you do when the player moves around? What about touch events or keyboard input? These all trigger events that can be acted upon as needed. Audio: Perhaps your game has background music and or sound effects. There needs to be a way to hear them! UI Components: Things like Button, Label, ScrollView, etc. Items that help you layout your game and related interfaces. Physics Engine: The physics engine is responsible for emulating the laws of physics realistically within the application. Game engines usually support multiple platforms thus making it easy to develop your game and then deploy it to multiple platforms without much overhead at all. Since Cocos2d-x is a game engine, it provides a simplified API for developing cross-platform mobile and desktop games. By encapsulating the power inside an easy to use API, you can focus on developing your games and worry less about the implementation of the technical underpinnings. Cocos2d-x will take care of as much or as little of the heavy lifting as you want. Cocos2d-x provides Scene, Transition, Sprite, Menu, Sprite3D, Audio objects and much more (our API Reference and cpp-tests will be your best friends!). Everything you need to create your games is included. Let's Build A Game - Step 1 Going step-by-step is the best way to make a game. Break the game down into pieces and tackle them one at a time, tieing them together as needed. To get started, please review our installation docs and our command-line tools docs. Ensure that you have Cocos2d-x installed and you have created a new project to begin development with. Hint: cocos new FirstGame -l cpp -p com.mycompany.mygame -d Games/. or similar is what you will end up running. Once you have this step done, keep on reading... Let's get started learning concepts and building a game! "},"basic_concepts/getting_started.html":{"url":"basic_concepts/getting_started.html","title":"Main Components","keywords":"","body":"Main Components It might seem overwhelming at first, but getting started with Cocos2d-x is simple. Before we dive into depth we must understand some of the concepts Cocos2d-x utilizes. At the heart of Cocos2d-x are Scene, Node, Sprite, Menu and Action objects. Look at any of your favorite games, and you will see all of these components in one form or another! Let's have a look. This might look a bit similar to a very popular game you might have played: Let's take another look, but splitting up the screenshot and identifying the components used to build it: You can see a menu, some sprites and labels, which all have an equivalent in Cocos2d-x. Take a look at a few of your own game design documents, and see what components you have, you'll probably have a few that match up. Let's Build A Game - Step 2 From the previous step, you now have a working Cocos2d-x project created FirstGame. This is good, it allows you to verify that your development environment is working. However, it also lets you see what code starts the game and how some basic decisions are made when the game starts. Let's take a look at a few of these Classes to gain some understanding. Cross-platform code is stored in the Classes/ directory while platform dependent code is stores in a folder for each platform, i.e proj.android, proj.ios_mac, proj.linux, proj.win32. AppDelegate AppDelegate is a very important class. AppDelegate is called once all the platform dependent code is run. The magic starts here! Take a look at it. Let's discuss a few key pieces! Design resolution - help to determine how large or small to design your Sprite objects (and much more). This is based upon the screen size of the device the game is running on. Because of this, it is always best to test your game on several devices of different screen resolution. Here is the relevant piece from AppDelegate: static cocos2d::Size designResolutionSize = cocos2d::Size(480, 320); static cocos2d::Size smallResolutionSize = cocos2d::Size(480, 320); static cocos2d::Size mediumResolutionSize = cocos2d::Size(1024, 768); static cocos2d::Size largeResolutionSize = cocos2d::Size(2048, 1536); AppDelegate::applicationDidFinishLaunching() - this is the main place you will start coding your game. This function does a lot for you already, but it may require tweaking, according to your needs. Consider the following lines where the first Scene is loaded and run, using the HelloWorld class: // create a scene. it's an autorelease object auto scene = HelloWorld::createScene(); // run director->runWithScene(scene); Making a few code changes So that we can get started making this game a bit more personal, we can change the Title of the glView. This is a simple change, made in the AppDelegate class. Take a look (or use Find) for the following lines: if(!glview) { #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX) glview = GLViewImpl::createWithRect(\"FirstGame\", cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height)); #else glview = GLViewImpl::create(\"FirstGame\"); #endif director->setOpenGLView(glview); } Notice where the code says: FirstGame. We can change this to Bubble Shooter. Make sure to change it in both places! This doesn't change the name of any IDE project names or directory names. Once you have this step done, keep on reading... Who is the Director? "},"basic_concepts/director.html":{"url":"basic_concepts/director.html","title":"Director","keywords":"","body":"Director Cocos2d-x uses the concept of a Director, just like in a movie! The Director object controls the flow of operations and tells the necessary recipient what to do. Think of yourself as the Executive Producer and you tell the Director what to do! One common Director task is to control Scene replacements and transitions. The Director is a shared singleton (effectively, there's only one instance of the class at a time) object that you can call from anywhere in your code. Here is an example of a typical game flow. The Director takes care of transitioning through this as your game criteria decides: You are the director of your game. You decide what happens, when and how. Take charge! How do I get the Director's attention? To interact with the Director you need to call on it. There are a few ways to do this: // get the director and then use it auto director = cocos2d::Director::getInstance(); director->runWithScene(scene); // get the director for each operation (not recommended for repeated requests) auto s = cocos2d::Director::getInstance()->getWinSize(); What things can the Director do? The Director has many responsibilities and even more possibilities. As mentioned above, the Director controls the show. Here are some useful things the Director can do without breaking a sweat: Scenes: change scenes, change scenes with a transition effects, etc... director->runWithScene(scene); // use when starting your game director->replaceScene(scene2); // use when changing from the running scene to another scene Pause/Resume: pause your game (if you are using physics there are more steps) // stop animations cocos2d::Director::getInstance()->stopAnimation(); // resume animations cocos2d::Director::getInstance()->startAnimation(); Get internal info: get/set properties of your game. Consult the API Reference for more functionality. // turn on display FPS cocos2d::Director::GetInstance()->setDisplayStats(true); // set FPS. the default value is 1.0/60 if you don't call this cocos2d::Director::GetInstance()->setAnimationInterval(1.0f / 60); // set content scale factor cocos2d::Director::GetInstance()->setContentScaleFactor(....); Let's Build A Game - Step 3 In the previous step we explored the AppDelegate class and what it does. In the next chapter we will explore Scenes. Before we get to that, we should do a bit of house-keeping. Resources Every game will have at least a few resources. These could be fonts, sounds effects, music or sprites. In this sample game we are first going to use simple shapes until our game is playable. Much later on we can use real art work. Moving on... Scenes "},"basic_concepts/scene.html":{"url":"basic_concepts/scene.html","title":"Scenes and the Scene graph","keywords":"","body":"Scenes and the Scene Graph In your game you probably want a main menu, a few levels and an ending scene. How do you organize all of these into the separate pieces they are? You guessed it, Scene. When you think about your favorite movie you can see that it's distinctly broken down into scenes, or separate parts of the story line. If we apply this same thought process to games, we should come up with at least a few scenes no matter how simple the game is. Taking another look at the familiar image from earlier: This is a main menu and it is a single Scene. This scene is made up of several pieces that all fit together to give us the end result. Scenes are drawn by the renderer. The renderer is responsible for gathering everything that should be on the screen, and how it should look and getting it there. To better understand this we need to talk a bit about the scene graph. Scene Graph A scene graph is a data structure that arranges a graphical scene. A scene graph contains Node objects in a tree (yes, it is called scene graph, but it is actually represented by a tree) structure. It sounds and looks complicated. I'm sure you are asking why should you care about this technical detail if Cocos2d-x does the heavy lifting for you? It really is important to understand how Scene objects are drawn by the renderer. Once you start adding Node, Sprite and Animation objects to your game, you want to make sure you are drawing the things you expect. But, what if you are not? What if your Sprite objects are hidden in the background and you want them to be the foremost objects? No big deal, just take a step back and run through the scene graph on a piece of paper, and I bet you find your mistake easily. Since the Scene Graph is a tree; you can walk the tree. Cocos2d-x uses the in-order walk algorithm. An in-order walk is the left side of the tree being walked, then the root node, then the right side of the tree. Since the right side of the tree is rendered last, it is displayed first on the scene graph. The scene graph is easily demonstrated, let's take a look at our game scene broken down: This example game scene would be rendered as a tree, simplified to the following: Another point to think about is elements with a negative z-order are on the left side of the tree, while elements with a positive z-order are on the right side. Keep this in consideration when ordering your elements! Of course, you can add elements in any order, and they're automatically sorted based upon a customizable z-order. Building on this concept, we can think of a Scene as a collection of Node objects. Let's break the scene above down to see the scene graph uses the z-order to layout the Scene: The Scene on the left is actually made up of multiple Node objects that are given a different z-order to make them stack on top of each other. In Cocos2d-x, you build the scene graph using the addChild() API call: // Adds a child with the z-order of -2, that means // it goes to the \"left\" side of the tree (because it is negative) scene->addChild(title_node, -2); // When you don't specify the z-order, it will use 0 scene->addChild(label_node); // Adds a child with the z-order of 1, that means // it goes to the \"right\" side of the tree (because it is positive) scene->addChild(sprite_node, 1); Let's Build A Game - Step 4 Continuing with building our game, we need to think about our game and what Scene objects we will need. Some games use just a single Scene object. This works by removing all Node objects from a scene and replacing them with new Node objects that make up the next Scene. This is a valid approach. Another approach might be to break the game down into a main menu and a game scene. A third approach might be to break the game down further into a main menu, level 1 -> level N and finally a closing scene. You may even add a small transition, often called a cut scene between the vavious Scene objects. Perhaps these cut scenes continue telling a story or just visually stimluate the user while the next level is loading in the background. In this game, let us take the approach of breaking down our game into an intro scene, game scene and a closing scene. To do this, we need to make 3 almost entirely identical classes, at least to start with. These classes will change as we work on each one of these parts of our game. There are arguments amongst programmers on having to many or to few classes. Let's save that debate for a later time. For now, the goal is to be as clear as possible so those new to c++ and game development don't struggle to learn both at the same time. Let's add the classes we mentioned above now. Classes are just source files. You can create them from the command-line or your favorite text editor. If you are using an IDE there may even be a wizard you can run if you are new to class creation. The first class is our intro scene. Let's block out a basic class Lions and tigers and Sprites..oh my! "},"basic_concepts/sprites.html":{"url":"basic_concepts/sprites.html","title":"Sprites","keywords":"","body":"Sprites All games have Sprite objects, and you may or may not realize what they are. Sprites are the objects that you move around the screen. You can manipulate them. The main character in your game is probably a Sprite. I know what you might be thinking - isn't every graphical object a Sprite? No! Why? Well a Sprite is only a Sprite if you move it around. If you don't move it around it is just a Node. Taking another look at the image from above, let's point out what are Sprites and what are Nodes: Sprites are important in all games. Writing a platformer, you probably have a main character that is made by using an image of some sort. This is a Sprite. Sprites are easy to create and they have configurable properties like: position, rotation, scale, opacity, color and more. // This is how to create a sprite auto mySprite = Sprite::create(\"mysprite.png\"); // this is how to change the properties of the sprite mySprite->setPosition(Vec2(500, 0)); mySprite->setRotation(40); mySprite->setScale(2.0); // sets both the scale of the X and Y axis uniformly mySprite->setAnchorPoint(Vec2(0, 0)); Let's illustrate each property, consider the following screenshot from the example code for this chapter: If we set the position using mySprite->setPosition(Vec2(500, 0));: Note that the Sprite position has changed from its original position to the new position that we specified. If we now set a new rotation, using mySprite->setRotation(40);: ... you can see that the Sprite has been rotated to the new amount that was specified. If we now specify a new scale using mySprite->setScale(2.0);: Again, we can see that the Sprite now has changed according to our code changes. Lastly, all Node objects (since a Sprite is a subclass of Node) have a value for anchor point. We haven't talked about this yet, so now is a good time. You can think of anchor point as a way of specifying what part of the sprite will be used as a base coordinate when setting the position of it. Using the character from our example game, and setting the anchor point to 0, 0 using: mySprite->setAnchorPoint(Vec2(0, 0)); would result in the lower left corner of our sprite being used as the basis for any setPosition() call. Let's see a few of these in action: Take a look at the red dot in each picture. This red dot illustrates where the anchor point is! As you can see anchor point is very useful when positioning Nodes. You can even adjust the anchor point dynamically to simulate effects in your game. We really can tweak just about every aspect of the Sprite. But, what if we wanted to have these same types of changes occur in an automated, time determined manner? Well, keep reading... "},"basic_concepts/actions.html":{"url":"basic_concepts/actions.html","title":"Actions","keywords":"","body":"Actions Creating a Scene and adding Sprite objects on the screen is only part of what we need to do. For a game to be a game we need to make things move around! Action objects are an integral part of every game. Actions allow the transformation of Node objects in time space. Want to move a Sprite from one Point to another and use a callback when complete? No problem! You can even create a Sequence of Action items to be performed on a Node. You can change Node properties like position, rotation and scale. Example Actions: MoveBy, Rotate, Scale. All games use Actions. Taking a look at the sample code for this chapter, here are Actions in work: and after 5 seconds the sprite will move to a new position: Action objects are easy to create: auto mySprite = Sprite::create(\"Blue_Front1.png\"); // Move a sprite 50 pixels to the right, and 10 pixels to the top over 2 seconds. auto moveBy = MoveBy::create(2, Vec2(50,10)); mySprite->runAction(moveBy); // Move a sprite to a specific location over 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50,10)); mySprite->runAction(moveTo); "},"basic_concepts/sequences.html":{"url":"basic_concepts/sequences.html","title":"Sequences and Spawns","keywords":"","body":"Sequences and Spawns With moving Sprite objects on the screen we have everything we need to create our game, right? Not quite. What about running multiple Actions? Yes, Cocos2d-x handles this too in a few different ways. Just like it sounds, a Sequence is multiple Action objects run in a specified order. Need to run the Sequence in reverse? No problem, Cocos2d-x handles this with no additional work. Take a look at the flow of an example Sequence for moving a Sprite gradually: This Sequence is easy to make: auto mySprite = Node::create(); // move to point 50,10 over 2 seconds auto moveTo1 = MoveTo::create(2, Vec2(50,10)); // move from current position by 100,10 over 2 seconds auto moveBy1 = MoveBy::create(2, Vec2(100,10)); // move to point 150,10 over 2 seconds auto moveTo2 = MoveTo::create(2, Vec2(150,10)); // create a delay auto delay = DelayTime::create(1); mySprite->runAction(Sequence::create(moveTo1, delay, moveBy1, delay.clone(), moveTo2, nullptr)); This example runs a Sequence, in order, but what about running all the specified Actions at the same time? Cocos2d-x supports this too and it is called Spawn. Spawn will take all the specified Action objects and executes them at the same time. Some might be longer than others, so they won't all finish at the same time if this is the case. auto myNode = Node::create(); auto moveTo1 = MoveTo::create(2, Vec2(50,10)); auto moveBy1 = MoveBy::create(2, Vec2(100,10)); auto moveTo2 = MoveTo::create(2, Vec2(150,10)); myNode->runAction(Spawn::create(moveTo1, moveBy1, moveTo2, nullptr)); Why Spawn actions? Is there ever a reason? Sure! What if your main character has multiple Actions when obtaining a power up? Maybe beating the boss at the end of a level has multiple Actions that need to happen to end the level. "},"basic_concepts/parent_child.html":{"url":"basic_concepts/parent_child.html","title":"Parent Child Relationship","keywords":"","body":"Parent Child Relationship Cocos2d-x uses a parent and child relationship. This means that properties and changes to the parent node are applied to its children. Consider a single Sprite and then a Sprite that has children: With children, changing the rotation of the parent will also change the rotation to all children: auto myNode = Node::create(); // rotating by setting myNode->setRotation(50); Just like with rotation, if you change the scale of the parent the children will also get scaled: auto myNode = Node::create(); // scaling by setting myNode->setScale(2.0); // scales uniformly by 2.0 Not all changes to the parent are passed down to its children. Changing the parent anchor point only affects transform operations (scale, position, rotate, skew, etc...) and does not affect children positioning. In fact, children will be always added to the bottom-left (0,0) corner of its parent. "},"basic_concepts/logging.html":{"url":"basic_concepts/logging.html","title":"Logging","keywords":"","body":"Logging as a way to output messages Sometimes, when your app is running, you might wish to see messages being written to the console for informational or debug purposes. This is built into the engine, using log(). Example: // a simple string log(\"This would be outputted to the console\"); // a string and a variable string s = \"My variable\"; log(\"string is %s\", s); // a double and a variable double dd = 42; log(\"double is %f\", dd); // an integer and a variable int i = 6; log(\"integer is %d\", i); // a float and a variable float f = 2.0f; log(\"float is %f\", f); // a bool and a variable bool b = true; if (b == true) log(\"bool is true\"); else log(\"bool is false\"); And, c++ users, if you prefer you can use std::cout in place of log(), however, log() might offer easier formatting of complex output. "},"sprites/":{"url":"sprites/","title":"Sprites","keywords":"","body":"Sprites Cocos2d-x provides Sprite these are images for almost everyhing your game requires. "},"sprites/getting_started.html":{"url":"sprites/getting_started.html","title":"What are Sprites","keywords":"","body":"What are Sprites A Sprite is a 2D image that can be animated or transformed by changing its properties, including rotation, position, scale, color, etc. "},"sprites/creating.html":{"url":"sprites/creating.html","title":"Creating Sprites","keywords":"","body":"Creating Sprites There are different ways to create Sprites depending upon what you need to accomplish. You can create a Sprite from an image with various graphic formats including: PNG, JPEG, TIFF, and others. Let's go through some create methods and talk about each one. Creating a Sprite A Sprite can be created by specifying an image file to use. auto mySprite = Sprite::create(\"mysprite.png\"); The statement above creates a Sprite using the mysprite.png image. The result is that the created Sprite uses the whole image. Sprite has the same dimensions of mysprite.png. If the image file is 200 x 200 the resulting Sprite is 200 x 200. Creating a Sprite with a Rect In the previous example, the created Sprite has the same size as the original image file. If you want to create a Sprite with only a certain portion of the image file, you can do it by specifying a Rect. Rect has 4 values: origin x, origin y, width and height. auto mySprite = Sprite::create(\"mysprite.png\", Rect(0,0,40,40)); Rect starts at the top left corner. This is the opposite of what you might be used to when laying out screen position as it starts from the lower left corner. Thus the resulting Sprite is only a portion of the image file. In this case the Sprite dimension is 40 x 40 starting at the top left corner. If you don't specify a Rect, Cocos2d-x will automatically use the full width and height of the image file you specify. Take a look at the example below. If we use an image with dimensions 200 x 200 the following 2 statements would have the same result. auto mySprite = Sprite::create(\"mysprite.png\"); auto mySprite = Sprite::create(\"mysprite.png\", Rect(0,0,200,200)); "},"sprites/spritesheets.html":{"url":"sprites/spritesheets.html","title":"Spritesheets","keywords":"","body":"Creating a Sprite from a Sprite Sheet A sprite sheet is a way to combine sprites into a single file. Using a sprite sheet helps achieve better performance by batching the draw calls. They can also save disk and video memory in cases where the sprites can be packed on a sheet more efficiently (generally requires special tools). You will read more about this in the Advanced Chapter, but it is one of many standard methods in the industry for increasing game performance. When using a sprite sheet it is first loaded, in its entirety, into the SpriteFrameCache. SpriteFrameCache is a caching class that retains the SpriteFrame objects added to it, for future quicker access. The SpriteFrame is loaded once and retained in the SpriteFrameCache Here is an example sprite sheet: It doesn't look like much but let's take a closer look at what is happening: As you can see the sprite sheet, at a minimum it reduces unneeded space and consolidates all sprites into a single file. Let's tie this all together! Loading a Sprite Sheet Load your sprite sheet into the SpriteFrameCache, probably in AppDelegate: // load the Sprite Sheet auto spritecache = SpriteFrameCache::getInstance(); // the .plist file can be generated with any of the tools mentioned below spritecache->addSpriteFramesWithFile(\"sprites.plist\"); Now that we have a sprite sheet loaded into SpriteFrameCache we can create Sprite objects by utilizing it. Tools for creating Sprite Sheets Creating a sprite sheet manually is a tedious process. Fortunately there are tools that can generate them automatically. These tools can provide even more ways to adjust your sprite sheet for maximum optimization! Here are a few tools: Texture Packer Recommended ShoeBox Zwoptex Sprite Sheet Packer "},"sprites/spriteframe_cache.html":{"url":"sprites/spriteframe_cache.html","title":"SpriteFrame Cache","keywords":"","body":"Creating a Sprite from SpriteFrameCache This creates a Sprite by pulling it from the SpriteFrameCache. // Our .plist file has names for each of the sprites in it. We'll grab // the sprite named, \"mysprite\" from the sprite sheet: auto mysprite = Sprite::createWithSpriteFrameName(\"mysprite.png\"); Creating a Sprite from a SpriteFrame Another way to create the same Sprite is by fetching the SpriteFrame from the SpriteFrameCache, and then creating the Sprite with the SpriteFrame. Example: // this is equivalent to the previous example, // but it is created by retrieving the SpriteFrame from the cache. auto newspriteFrame = SpriteFrameCache::getInstance()->getSpriteFrameByName(\"Blue_Front1.png\"); auto newSprite = Sprite::createWithSpriteFrame(newspriteFrame); "},"sprites/manipulation.html":{"url":"sprites/manipulation.html","title":"Sprite Manipulation","keywords":"","body":"Sprite Manipulation After creating a Sprite you will have access to a variety of properties it has that can be manipulated. Given: auto mySprite = Sprite::create(\"mysprite.png\"); Anchor Point and Position Anchor Point is a point that you set as a way to specify what part of the Sprite will be used when setting its position. Anchor Point affects only properties that can be transformed. This includes scale, rotation, skew. This excludes color and opacity. The anchor point uses a bottom left coordinate system. This means that when specifying X and Y coordinate values you need to make sure to start at the bottom left hand corner to do your calculations. By default, all Node objects have a default anchor point of is (0.5, 0.5). Setting the anchor point is easy: // DEFAULT anchor point for all Sprites mySprite->setAnchorPoint(0.5, 0.5); // bottom left mySprite->setAnchorPoint(0, 0); // top left mySprite->setAnchorPoint(0, 1); // bottom right mySprite->setAnchorPoint(1, 0); // top right mySprite->setAnchorPoint(1, 1); To represent this visually: Sprite properties effected by anchor point Using anchor point effects only properties that can be transformed. This includes scale, rotation, skew. Position A sprite's position is affected by its anchor point as it is this point that is used as a starting point for positioning. Let's visually look at how this happens. Notice the colored line and where the sprite's position is in relation to it. Notice, as we change the anchor point values, the sprite's position changes. It is important to note that all it took was changing the anchor point value. We did not use a setPosition() statement to achieve this: There are more ways to set position than just anchor point. Sprite objects can also be set using the setPosition() method. // position a sprite to a specific position of x = 100, y = 200. mySprite->setPosition(Vec2(100, 200)); Rotation Changes the sprite's rotation, by a positive or negative number of degrees. A positive value rotates the Sprite object clockwise, while a negative value rotates the Sprite object counter-clockwise. The default value is 0. // rotate sprite by +20 degrees mySprite->setRotation(20.0f); // rotate sprite by -20 degrees mySprite->setRotation(-20.0f); // rotate sprite by +60 degrees mySprite->setRotation(60.0f); // rotate sprite by -60 degrees mySprite->setRotation(-60.0f); Scale Changes the sprite's scale, either by x, y or uniformly for both x and y. The default value is 1.0 for both x and y. // increases X and Y size by 2.0 uniformly mySprite->setScale(2.0); // increases just X scale by 2.0 mySprite->setScaleX(2.0); // increases just Y scale by 2.0 mySprite->setScaleY(2.0); Skew Changes the sprite's skew, either by x, y or uniformly for both x and y. The default value is 0,0 for both x and y. // adjusts the X skew by 20.0 mySprite->setSkewX(20.0f); // adjusts the Y skew by 20.0 mySprite->setSkewY(20.0f); Sprite properties not affected by anchor point There are a few properties of Sprite objects that are not affected by anchor point. Why? Because they only change superficial qualities like color and opacity. Color Changes the sprite's color. This is done by passing in a Color3B object. Color3B objects are RGB values. We haven't encountered Color3B yet but it is simply an object that defines an RGB color. An RGB color is a 3 byte value from 0 - 255. Cocos2d-x also provides pre-defined colors that you can pick from. Using these will be a bit faster since they are pre-defined. A few examples: Color3B::White and Color3B::Red. // set the color by passing in a pre-defined Color3B object. mySprite->setColor(Color3B::WHITE); // Set the color by passing in a Color3B object. mySprite->setColor(Color3B(255, 255, 255)); // Same as Color3B::WHITE Opacity Changes the sprite's opacity by the specified value. An opaque object is not transparent at all. This property expects a value from 0 to 255, where 255 means fully opaque and 0 means fully transparent. Think: zero opacity means invisible, and you'll always understand how this works. The default value is 255 (fully opaque). // Set the opacity to 30, which makes this sprite 11.7% opaque. // (30 divided by 256 equals 0.1171875...) mySprite->setOpacity(30); "},"sprites/polygon.html":{"url":"sprites/polygon.html","title":"Polygon Sprite","keywords":"","body":"Polygon Sprite A Polygon Sprite is also a Sprite, that is used to display a 2d image. However, unlike a normal Sprite object, which is a rectangle made of just 2 triangles, PolygonSprite objects are made of a series of triangles. Why use a Polygon Sprite? Simple, performance! There is a lot of technical jargon that we can toss around here about pixel fill rate but the take home lesson is that a PolygonSprite draws based upon the shape of your Sprite, not a simple rectangle around the largest width and height. This saves a lot of unnecessary drawing. Just like Sprite objects, PolygonSprite objects can be used in spritesheets. Texture Packer is one tool that can handle creating spritesheets with out of PolygonSprite objects. Consider this example: Notice the difference between the left and right versions? On the left, a typical Sprite drawn in rectangular fashion by the use of 2 triangles. On the right, a PolygonSprite drawn with many smaller triangles. Whether or not this trade-off is worth it for purely performance reasons depends on a number of factors (sprite shape/detail, size, quantity drawn on screen, etc.), but in general, vertices are cheaper than pixels on modern GPUs. AutoPolygon AutoPolygon is a helper class. It's purpose is to process an image into a 2d polygon mesh at runtime. There are functions for each step in the process, from tracing all the points, to triangulation. The result, can be then passed to a Sprite objects create function to create a PolygonSprite. Example: // Generate polygon info automatically. auto pinfo = AutoPolygon::generatePolygon(\"filename.png\"); // Create a sprite with polygon info. auto sprite = Sprite::create(pinfo); "},"actions/":{"url":"actions/","title":"Actions","keywords":"","body":"Actions Action objects are just like they sound. They make a Node perform a change to its properties. Action objects allow the transformation of Node properties in time. Any object with a base class of Node can have Action objects performed on it. As an example, you can move a Sprite from one position to another and do it over a span of time. Example of MoveTo and MoveBy actions: // Move sprite to position 50,10 in 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50, 10)); mySprite1->runAction(moveTo); // Move sprite 20 points to right in 2 seconds auto moveBy = MoveBy::create(2, Vec2(20,0)); mySprite2->runAction(moveBy); Let's get started with Actions! "},"actions/getting_started.html":{"url":"actions/getting_started.html","title":"What are Actions","keywords":"","body":"By and To, what is the difference? You will notice that each Action has a By and To version. Why? Because they are different in what they accomplish. A By is relative to the current state of the Node. A To action is absolute, meaning it doesn't take into account the current state of the Node. Let's take a look at a specific example: auto mySprite = Sprite::create(\"mysprite.png\"); mySprite->setPosition(Vec2(200, 256)); // MoveBy - lets move the sprite by 500 on the x axis over 2 seconds // MoveBy is relative - since x = 200 + 500 move = x is now 700 after the move auto moveBy = MoveBy::create(2, Vec2(500, mySprite->getPositionY())); // MoveTo - lets move the new sprite to 300 x 256 over 2 seconds // MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of // where it is located now. auto moveTo = MoveTo::create(2, Vec2(300, mySprite->getPositionY())); // Delay - create a small delay auto delay = DelayTime::create(1); auto seq = Sequence::create(moveBy, delay, moveTo, nullptr); mySprite->runAction(seq); "},"actions/basic.html":{"url":"actions/basic.html","title":"Basic Actions","keywords":"","body":"Basic Actions and how to run them Basic actions are usually a singular action, thus accomplishing a single objective. Let's take a look at a few examples: Move Move a Node over a set period of time. auto mySprite = Sprite::create(\"mysprite.png\"); // Move a sprite to a specific location over 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50, 0)); mySprite->runAction(moveTo); // Move a sprite 50 pixels to the right, and 0 pixels to the top over 2 seconds. auto moveBy = MoveBy::create(2, Vec2(50, 0)); mySprite->runAction(moveBy); Rotate Rotate a Node clockwise over 2 seconds. auto mySprite = Sprite::create(\"mysprite.png\"); // Rotates a Node to the specific angle over 2 seconds auto rotateTo = RotateTo::create(2.0f, 40.0f); mySprite->runAction(rotateTo); // Rotates a Node clockwise by 40 degree over 2 seconds auto rotateBy = RotateBy::create(2.0f, 40.0f); mySprite->runAction(rotateBy); Scale Scale a Node by 10 over 2 seconds. auto mySprite = Sprite::create(\"mysprite.png\"); // Scale uniformly by 3x over 2 seconds auto scaleBy = ScaleBy::create(2.0f, 3.0f); mySprite->runAction(scaleBy); // Scale X by 5 and Y by 3x over 2 seconds auto scaleBy = ScaleBy::create(2.0f, 3.0f, 3.0f); mySprite->runAction(scaleBy); // Scale to uniformly to 3x over 2 seconds auto scaleTo = ScaleTo::create(2.0f, 3.0f); mySprite->runAction(scaleTo); // Scale X to 5 and Y to 3x over 2 seconds auto scaleTo = ScaleTo::create(2.0f, 3.0f, 3.0f); mySprite->runAction(scaleTo); Fade In/Out Fade a Node. It modifies the opacity from 0 to 255. The reverse of this action is FadeOut auto mySprite = Sprite::create(\"mysprite.png\"); // fades in the sprite in 1 seconds auto fadeIn = FadeIn::create(1.0f); mySprite->runAction(fadeIn); // fades out the sprite in 2 seconds auto fadeOut = FadeOut::create(2.0f); mySprite->runAction(fadeOut); Tint Tint a Node that implements the NodeRGB protocol from current the tint to a custom tint. auto mySprite = Sprite::create(\"mysprite.png\"); // Tints a node to the specified RGB values auto tintTo = TintTo::create(2.0f, 120.0f, 232.0f, 254.0f); mySprite->runAction(tintTo); // Tints a node BY the delta of the specified RGB values. auto tintBy = TintBy::create(2.0f, 120.0f, 232.0f, 254.0f); mySprite->runAction(tintBy); Animate With Animate it is possible to do simple flipbook animation with your Sprite objects. This is simply replacing the display frame at set intervals for the duration of the animation. Let's consider this example: auto mySprite = Sprite::create(\"mysprite.png\"); // now lets animate the sprite we moved Vector animFrames; animFrames.reserve(12); animFrames.pushBack(SpriteFrame::create(\"Blue_Front1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Front2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Front3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right3.png\", Rect(0,0,65,81))); // create the animation out of the frames Animation* animation = Animation::createWithSpriteFrames(animFrames, 0.1f); Animate* animate = Animate::create(animation); // run it and repeat it forever mySprite->runAction(RepeatForever::create(animate)); It's hard to show an animation in text, so please run the example Programmer Guide Sample code to see this in action! Easing Easing is animating with a specified acceleration to make the animations smooth. A few things to keep in mind is that regardless of speed, ease actions always start and finish at the same time. Ease actions are a good way to fake physics in your game! Perhaps you want a few simulated physics effects but don't want the overhead and complexity of adding it all for a few very basic actions. Another good example is to animate menus and buttons. Here are common easing functions displayed over a graph: Cocos2d-x supports most of the easing function in the above graph. They are also simple to implement. Lets look at a specific use case. Lets drop a Sprite object from the top of the screen and make it bounce. // create a sprite auto mySprite = Sprite::create(\"mysprite.png\"); // create a MoveBy Action to where we want the sprite to drop from. auto move = MoveBy::create(2, Vec2(200, dirs->getVisibleSize().height - newSprite2->getContentSize().height)); // create a BounceIn Ease Action auto move_ease_in = EaseBounceIn::create(move->clone()); auto move_ease_in_back = move_ease_in->reverse(); // create a delay that is run in between sequence events auto delay = DelayTime::create(0.25f); // create the sequence of actions, in the order we want to run them auto seq1 = Sequence::create(move_ease_in, delay, move_ease_in_back, delay->clone(), nullptr); // run the sequence and repeat forever. mySprite->runAction(RepeatForever::create(seq1)); Run the example Programmer Guide Sample code to see this in action! "},"actions/sequences.html":{"url":"actions/sequences.html","title":"Sequences","keywords":"","body":"Sequences and how to run them Sequences are a series of Action objects to be executed sequentially. This can be any number of Action objects, Functions and even another Sequence. Functions? Yes! Cocos2d-x has a CallFunc object that allows you to create a function() and pass it in to be run in your Sequence. This allows you to add your own functionality to your Sequence objects besides just the stock Action objects that Cocos2d-x provides. This is what a Sequence looks like when executing: An example sequence auto mySprite = Sprite::create(\"mysprite.png\"); // create a few actions. auto jump = JumpBy::create(0.5, Vec2(0, 0), 100, 1); auto rotate = RotateTo::create(2.0f, 10); // create a few callbacks auto callbackJump = CallFunc::create([](){ log(\"Jumped!\"); }); auto callbackRotate = CallFunc::create([](){ log(\"Rotated!\"); }); // create a sequence with the actions and callbacks auto seq = Sequence::create(jump, callbackJump, rotate, callbackRotate, nullptr); // run it mySprite->runAction(seq); So what does this Sequence action do? It will execute the following actions sequentially: Jump -> callbackJump() -> Rotate -> callbackRotate() Delays in Sequences Sometimes you may want to create a Sequence that has a small delay between each Action. You can achieve this using CallFunc. Example: // use a sequence incorporating delays between items cocos2d::CallFunc* A = cocos2d::CallFunc::create([=]() { // do something }); cocos2d::CallFunc* B = cocos2d::CallFunc::create([=]() { // do something }); cocos2d::CallFunc* C = cocos2d::CallFunc::create([=]() { // do something }); cocos2d::DelayTime* delay = cocos2d::DelayTime::create(1); runAction(cocos2d::Sequence::create(A, delay, B, delay, C, NULL)); Spawn Spawn is very similar to Sequence, except that all actions will run at the same time. You can have any number of Action objects and even other Spawn objects! Spawn produces the same result as running multiple consecutive runAction() statements. However, the benefit of spawn is that you can put it in a Sequence to help achieve specific effects that you cannot otherwise. Combining Spawn and Sequence is a very powerful feature. Example, given: // create 2 actions and run a Spawn on a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); auto moveBy = MoveBy::create(10, Vec2(400,100)); auto fadeTo = FadeTo::create(2.0f, 120.0f); Using a Spawn: // running the above Actions with Spawn. auto mySpawn = Spawn::createWithTwoActions(moveBy, fadeTo); mySprite->runAction(mySpawn); and consecutive runAction() statements: // running the above Actions with consecutive runAction() statements. mySprite->runAction(moveBy); mySprite->runAction(fadeTo); Both would produce the same result. However, one can use Spawn in a Sequence. This flowchart shows how this might look: // create a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); // create a few Actions auto moveBy = MoveBy::create(10, Vec2(400,100)); auto fadeTo = FadeTo::create(2.0f, 120.0f); auto scaleBy = ScaleBy::create(2.0f, 3.0f); // create a Spawn to use auto mySpawn = Spawn::createWithTwoActions(scaleBy, fadeTo); // tie everything together in a sequence auto seq = Sequence::create(moveBy, mySpawn, moveBy, nullptr); // run it mySprite->runAction(seq); "},"actions/sequence_internals.html":{"url":"actions/sequence_internals.html","title":"Sequence Internals","keywords":"","body":"Clone Clone is exactly like it sounds. If you have an Action, you can apply it to multiple Node objects by using clone(). Why do you have to clone? Good question. Action objects have an internal state. When they run, they are actually changing the Node objects properties. Without the use of clone() you don't truly have a unique Action being applied to the Node. This will produce unexpected results, as you can't know for sure what the properties of the Action are currently set at. Let's hash through an example, say you have a heroSprite and it has a position of (0,0). If you run an Action of: MoveBy::create(10, Vec2(400,100)); This will move heroSprite from (0,0) to (400, 100) over the course of 10 seconds. heroSprite now has a new position of (400, 100) and more importantly the Action has this position in it's internal state. Now, say you have an enemySprite with a position of (200, 200). If you were to apply this same: MoveBy::create(10, Vec2(400,100)); to your enemySprite, it would end up at a position of (800, 200) and not where you thought it would. Do you see why? It is because the Action already had an internal state to start from when performing the MoveBy. Cloning an Action prevents this. It ensures you get a unique version Action applied to your Node. Let's also see this in code, first, incorrect. // create our Sprites auto heroSprite = Sprite::create(\"herosprite.png\"); auto enemySprite = Sprite::create(\"enemysprite.png\"); // create an Action auto moveBy = MoveBy::create(10, Vec2(400,100)); // run it on our hero heroSprite->runAction(moveBy); // run it on our enemy enemySprite->runAction(moveBy); // oops, this will not be unique! // uses the Actions current internal state as a starting point. Correctly, using clone()!: // create our Sprites auto heroSprite = Sprite::create(\"herosprite.png\"); auto enemySprite = Sprite::create(\"enemysprite.png\"); // create an Action auto moveBy = MoveBy::create(10, Vec2(400,100)); // run it on our hero heroSprite->runAction(moveBy); // run it on our enemy enemySprite->runAction(moveBy->clone()); // correct! This will be unique Reverse Reverse is also exactly like it sounds. If you run a series of actions, you can call reverse() to run it, in the opposite order. Otherwise known as, backwards. However, it is not just simply running the Action in reverse order. Calling reverse() is actually manipulating the properties of the original Sequence or Spawn in reverse too. Using the Spawn example above, reversing is simple. // reverse a sequence, spawn or action mySprite->runAction(mySpawn->reverse()); Most Action and Sequence objects are reversible! It's easy to use, but let's make sure we see what is happening. Given: // create a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); mySprite->setPosition(50, 56); // create a few Actions auto moveBy = MoveBy::create(2.0f, Vec2(500,0)); auto scaleBy = ScaleBy::create(2.0f, 2.0f); auto delay = DelayTime::create(2.0f); // create a sequence auto delaySequence = Sequence::create(delay, delay->clone(), delay->clone(), delay->clone(), nullptr); auto sequence = Sequence::create(moveBy, delay, scaleBy, delaySequence, nullptr); // run it newSprite2->runAction(sequence); // reverse it newSprite2->runAction(sequence->reverse()); What is really happening? If we lay out the steps as a list it might be helpful: mySprite is created mySprite position is set to (50, 56) sequence starts to run sequence moves mySprite by 500, over 2 seconds, mySprite new position (550, 56) sequence delays for 2 seconds sequence scales mySprite by 2x over 2 seconds sequence delays for 6 more seconds (notice we run another sequence to accomplish this) we run a reverse() on the sequence so we re-run each action backwards sequence is delayed for 6 seconds sequence scales mySprite by -2x over 2 seconds sequence delays for 2 seconds sequence moves mySprite by -500, over 2 seconds, mySprite new position (50, 56) You can see that a reverse() is simple for you to use, but not so simple in its internal logic. Cocos2d-x does all the heavy lifting! "},"scenes/":{"url":"scenes/","title":"Building and Transitioning Scenes","keywords":"","body":"Building and Transitioning Scenes Cocos2d-x provides Scene. Scene is the foundation of every game. convertToNodeSpace(node2->getPosition()); ``` convert node2’s SCREEN coordinates to node1’s local.As the result, node2 with the position of (-25，-60). ![](scenes-img/5_10.jpg) #### convertToWorldSpace `convertToWorldSpace` converts on-node coordinates to SCREEN coordinates. `convertToWorldSpace` will always return SCREEN position of our sprite, might be very useful if you want to capture taps on your sprite but need to move/scale your layer. Generally, the parent node call this method with the child node position, return the world’s postion of child’s as a result. It seems make no sense calling this method if the caller isn’t the parent. Example: ```cpp Point point = node1->convertToWorldSpace(node2->getPosition()); ``` The above code will convert the node2‘s coordinates to the coordinates on the screen. For example if the anchor position of node1 is which will be the bottom left corner of the node1, but not necessarily on the screen. This will convert the position of the node2 which is to the screen coordinate of the point relative to node1 ). The result shows in the following picture: ![](scenes-img/5_11.jpg) #### convertToWorldSpaceAR `convertToWorldSpaceAR` will return the position relative to anchor point: so if our scene - root layer has anchor point of Vec2(0.5f, 0.5f) - default, `convertToWorldSpaceAR` should return position relative to screen center. `convertToNodeSpaceAR` - the same logic as for `convertToWorldSpaceAR` ### Sample code： ```cpp Sprite *sprite1 = Sprite::create(\"CloseNormal.png\"); sprite1->setPosition(Vec2(20,40)); sprite1->setAnchorPoint(Vec2(0,0)); this->addChild(sprite1); Sprite *sprite2 = Sprite::create(\"CloseNormal.png\"); sprite2->setPosition(Vec2(-5,-20)); sprite2->setAnchorPoint(Vec2(1,1)); this->addChild(sprite2); Vec2 point1 = sprite1->convertToNodeSpace(sprite2->getPosition()); Vec2 point2 = sprite1->convertToWorldSpace(sprite2->getPosition()); Vec2 point3 = sprite1->convertToNodeSpaceAR(sprite2->getPosition()); Vec2 point4 = sprite1->convertToWorldSpaceAR(sprite2->getPosition()); LOG(\"position = (%f,%f)\",point1.x,point1.y); LOG(\"position = (%f,%f)\",point2.x,point2.y); LOG(\"position = (%f,%f)\",point3.x,point3.y); LOG(\"position = (%f,%f)\",point4.x,point4.y); ``` Result： ``` position = (-25.000000,-60.000000) position = (15.000000,20.000000) position = (-25.000000,-60.000000) position = (15.000000,20.000000) ``` ---> "},"scenes/getting_started.html":{"url":"scenes/getting_started.html","title":"What are Scenes?","keywords":"","body":"What is a Scene? A Scene is a container that holds Sprites, Labels, Nodes and other objects that your game needs. A Scene is responsible for running game logic and rendering the content on a per-frame basis. You need at least one Scene to start your game. You can think of this like a movie. The Scene is what is running and users see what is happening in real-time. You can have any number of Scene objects in your game and transition through them easily. Cocos2d-x provides scene transitions and you can even have scene transitions with cool effects. "},"scenes/creating.html":{"url":"scenes/creating.html","title":"Creating Scenes","keywords":"","body":"Creating a Scene It is very easy to create a Scene auto myScene = Scene::create(); Remember the Scene Graph? In Chapter 2 of this guide we learned about a scene graph and how it affects the drawing of our game. The important thing to remember is that this defines the drawing order of the GUI elements. Also remember z-order! A Simple Scene Lets's build a simple Scene. Remember that Cocos2d-x uses a right handed coordinate system. This means that our 0,0 coordinate is at the bottom left corner of the screen/display. When you start positioning your game elements this is where you should start your calculations from. Let's create a simple Scene and add a few elements to it: auto dirs = Director::getInstance(); Size visibleSize = dirs->getVisibleSize(); auto myScene = Scene::create(); auto label1 = Label::createWithTTF(\"My Game\", \"Marker Felt.ttf\", 36); label1->setPosition(Vec2(visibleSize.width / 2, visibleSize.height / 2)); myScene->addChild(label1); auto sprite1 = Sprite::create(\"mysprite.png\"); sprite1->setPosition(Vec2(100, 100)); myScene->addChild(sprite1); When we run this code we shall see a simple Scene that contains a Label and a Sprite. It doesn't do much but it's a start. "},"scenes/transitioning.html":{"url":"scenes/transitioning.html","title":"Transitioning Scenes","keywords":"","body":"Transitioning between Scenes You might need to move between Scene objects in your game. Perhaps starting a new game, changing levels or even ending your game. Cocos2d-x provides a number of ways to do scene transitions. Ways to transition between Scenes There are many ways to transition through your scenes. Each has specific functionality. Let's go through them. Given: auto myScene = Scene::create(); runWithScene() - use this for the first scene only. This is the way to start your games first Scene. Director::getInstance()->runWithScene(myScene); replaceScene() - replace a scene outright. Director::getInstance()->replaceScene(myScene); pushScene() - suspends the execution of the running scene, pushing it on the stack of suspended scenes. Only call this if there is a running scene. Director::getInstance()->pushScene(myScene); popScene() - This scene will replace the running one. The running scene will be deleted. Only call this if there is a running scene. Director::getInstance()->popScene(); Transition Scenes with effects You can add visual effects to your Scene transitions auto myScene = Scene::create(); // Transition Fade Director::getInstance()->replaceScene(TransitionFade::create(0.5, myScene, Color3B(0,255,255))); // FlipX Director::getInstance()->replaceScene(TransitionFlipX::create(2, myScene)); // Transition Slide In Director::getInstance()->replaceScene(TransitionSlideInT::create(1, myScene) ); "},"ui_components/":{"url":"ui_components/","title":"UI Components","keywords":"","body":"UI Components Taking a look at the common apps you might use, I bet that you can spot UI widgets without necessarily knowing what they are. They aren't specific to games, every application probably uses a few widgets. What does UI stand for? What do UI widgets do? Oh so many questions! "},"ui_components/getting_started.html":{"url":"ui_components/getting_started.html","title":"Widgets","keywords":"","body":"Widgets, oh, my! UI is an abbreviation that stands for user interface. You know, things that are on the screen. This include items like: labels, buttons, menus, sliders and views. Cocos2d-x provides a set of UI widgets to make it simple to add these controls to your projects. It may sound trivial, but a lot goes in to creating a core class like a Label. There are so many aspects of just this one. Could you imagine having to write your own custom widget set? Don't worry, your needs are covered! setPosition(Vec2(0,0)); this->addChild(imageView); ``` It is also possible to create an `ImageView` from a `SpriteFrame`: ```cpp auto imageView = ImageView::create(\"ccicon.png\", TextureResType::PLIST); imageView->setPosition(Vec2(0,0)); this->addChild(imageView); ``` ## Text A `Text` widget is used for displaying text. It can also use it as a _text-only_ button. You can think of a `Text` widget as `Text` supports system font and TTF fonts. To create a `Text` widget: ```cpp auto text = Text::create(\"Text\",\"fonts/MyTTF.ttf\",30); this->addChild(text); ``` You can add effects like _shadow_, _glow_ and _outline_ just like any `Label` object. ### TextBMFont A `TextBMFont` widget is used for displaying `BMFont` text. It supports touch event, focus, percent positioning and percent content size. Creating a `TextBMFont` is list like the `Text` widget: ```cpp auto textBMFont = TextBMFont::create(\"BMFont\", \"bitmapFontTest2.fnt\"); textBMFont->setPosition(Vec2(0,0)); this->addChild(textBMFont); ``` #### TextAtlas A `TextAtlas` widget is used for displaying text as an _atlas font_. It supports touch event, focus, percent positioning and percent content size.\\ ```cpp auto textAtlas = TextAtlas::create(\"1234567890\", \"labelatlas.png\", 17, 22, \"0\"); textAtlas->setPosition(Vec2(0,0)); this->addChild(textAtlas); ``` #### RichText A `RichText` widget is used for displaying text, image and custom nodes. It supports touch event, focus, percent positioning and percent content size. When receiving a touch event the whole `RichText` widget receives the event. To create a `RichText` widget: ```cpp auto richText = RichText::create(); richText->ignoreContentAdaptWithSize(false); richText->setContentSize(Size(100, 100)); auto re1 = RichElementText::create(1, Color3B::WHITE, 255, str1, \"Marker Felt\", 10); richText->pushBackElement(re1); richText->setPosition(Vec2(0,0)); richText->setLocalZOrder(10); this->addChild(_richText); ``` --> "},"ui_components/labels.html":{"url":"ui_components/labels.html","title":"Label","keywords":"","body":"Label Cocos2d-x provides a Label object that can create labels using true type, bitmap or the built-in system font. This single class can handle all your Label needs. Label BMFont BMFont is a label type that uses a bitmap font. The characters in a bitmap font are made up of a matrix of dots. It is very fast and easy to use, but not scalable as it requires a separate font for each size character. Each character in a Label is a separate Sprite. This means that each character can be rotated, scaled, tinted, have a different anchor point and/or most any other property changed. Creating a BMFont label requires two files: a .fnt file and an image representation of each character in .png format. If you are using a tool like Glyph Designer these files are created automatically for you. Creating a Label object from a bitmap font: auto myLabel = Label::createWithBMFont(\"bitmapRed.fnt\", \"Your Text\"); All of the characters in the string parameter should be found in the provided .fnt file, otherwise they won't be rendered. If you render a Label object and it is missing characters, make sure they exist in your .fnt file. Label TTF True Type Fonts are different from the bitmap fonts we learned about above. With true type fonts the outline of the font is rendered. This is convenient as you do not need to have a separate font file for each size and color you might wish to use. Creating a Label object that uses a true type font is easy. To create one you need to specify a .ttf font file name, text string and a size. Unlike BMFont, TTF can render size changes without the need for a separate font files. Example, using a true type font: auto myLabel = Label::createWithTTF(\"Your Text\", \"Marker Felt.ttf\", 24); Although it is more flexible than a bitmap font, a true type font is slower to render and changing properties like the font face and size is an expensive operation. If you need several Label objects from a true type font that all have the same properties you can create a TTFConfig object to manage them. A TTFConfig object allows you to set the properties that all of your labels would have in common. You can think of this like a recipe where all your Label objects will use the same ingredients. You can create a TTFConfig object for your Labels in this way: // create a TTFConfig files for labels to share TTFConfig labelConfig; labelConfig.fontFilePath = \"myFont.ttf\"; labelConfig.fontSize = 16; labelConfig.glyphs = GlyphCollection::DYNAMIC; labelConfig.outlineSize = 0; labelConfig.customGlyphs = nullptr; labelConfig.distanceFieldEnabled = false; // create a TTF Label from the TTFConfig file. auto myLabel = Label::createWithTTF(labelConfig, \"My Label Text\"); A TTFConfig can also be used for displaying Chinese, Japanese and Korean characters. Label SystemFont SystemFont is a label type that uses the default system font and font size. This is a font that is meant not to have its properties changed. You should think of it as system font, system rules. Creating a SystemFont label: auto myLabel = Label::createWithSystemFont(\"My Label Text\", \"Arial\", 16); Label Effects After you have your Label objects on screen you might want to make them a bit prettier. Perhaps they look flat or plain. Thankfully you don't have to create your own custom fonts! Label objects can have effects applied to them. Not all Label objects support all effects. Some effects include shadow, outline and glow. You can apply one or more effects to a Label object easily: Label with a shadow effect: auto myLabel = Label::createWithTTF(\"My Label Text\", \"myFont.ttf\", 16); // shadow effect is supported by all Label types myLabel->enableShadow(); Label with a outline effect: auto myLabel = Label::createWithTTF(\"My Label Text\",\"myFont.ttf\", 16); // outline effect is TTF only, specify the outline color desired myLabel->enableOutline(Color4B::WHITE, 1)); Label with a glow effect: auto myLabel = Label::createWithTTF(\"My Label Text\", \"myFont.ttf\", 16); // glow effect is TTF only, specify the glow color desired. myLabel->enableGlow(Color4B::YELLOW); "},"ui_components/menus.html":{"url":"ui_components/menus.html","title":"Menu","keywords":"","body":"Menu and Menu Items We are all probably familiar with what a menu is. We see these in every application we use. In your game you would probably use a Menu object to navigate through game options. Menus often contain buttons like Play, Quit, Settings and About, but could also contain other Menu objects for a nested menu system. A Menu object is a special type of Node object. You can create an empty Menu object as a place holder for your menu items: auto myMenu = Menu::create(); As we described options above of Play, Quit, Settings and About, these are your menu items. A Menu without menu items makes little sense. Cocos2d-x offers a variety of ways to create your menu items including by using a Label object or specifying an image to display. Menu items usually have two possible states, a normal and a selected state. When you tap or click on the menu item a callback is triggered. You can think of this as a chain reaction. You tap/click the menu item and it runs the code you specified. A Menu can have just a single item or many items. // creating a menu with a single item // create a menu item by specifying images auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this)); auto menu = Menu::create(closeItem, NULL); this->addChild(menu, 1); A menu can also be created by using a vector of MenuItem objects: // creating a Menu from a Vector of items Vector MenuItems; auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this)); MenuItems.pushBack(closeItem); /* repeat for as many menu items as needed */ auto menu = Menu::createWithArray(MenuItems); this->addChild(menu, 1); If you run the sample code for this chapter you will see a Menu containing Label objects for MenuItems: Lambda functions as Menu callbacks Above we just learned that when you click a menu item it triggers a callback. C++11 offers lambda functions and therefore Cocos2d-x takes full advantage of them! A lambda function is a function you write inline in your source code. Lambdas are also evaluated at runtime instead of compile time. A simple lambda: // create a simple Hello World lambda auto func = [] () { cout Using a lambda as a MenuItem callback: auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", [&](Ref* sender){ // your code here }); "},"ui_components/buttons.html":{"url":"ui_components/buttons.html","title":"Buttons","keywords":"","body":"Buttons I doubt that we need to explain buttons much. We all know them as those things we click on to make something happen in our games. Perhaps you might use a button to change scenes or to add Sprite objects into your game play. A button intercepts a touch event and calls a predefined callback when tapped. A Button has a normal and selected state. The appearance of the Button can change based upon it's state. Creating a Button and defining its callback is simple, make sure to #include \"ui/CocosGUI.h\": auto button = Button::create(\"normal_image.png\", \"selected_image.png\", \"disabled_image.png\"); button->setTitleText(\"Button Text\"); button->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(button); As you can see in the above example we specify a .png image for each of the possible states the button can be in. A Button is made up of 3 graphics that might look like this: On screen a Button might look like this: "},"ui_components/checkboxes.html":{"url":"ui_components/checkboxes.html","title":"Checkbox","keywords":"","body":"CheckBox We are all used to filling out checkboxes on paper forms like job applications and rental agreements. You can also have checkboxes in your games. Perhaps, you want to have the ability for your player to make a simple yes or no choice. You might also hear this referred to as a binary choice (0 and 1). A CheckBox permits the user to make this type of choice. There are 5 different states a Checkbox can have: normal, selected and disabled. It is simple to create a CheckBox: #include \"ui/CocosGUI.h\" auto checkbox = CheckBox::create(\"check_box_normal.png\", \"check_box_normal_press.png\", \"check_box_active.png\", \"check_box_normal_disable.png\", \"check_box_active_disable.png\"); checkbox->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(checkbox); As you can see in the above example we specify a .png image for each of the possible states the Checkbox can be in. Since there are 5 possible states that a CheckBox can be in, it is up 5 graphics, one for each of its states. Example graphics: On screen a Checkbox might look like this: "},"ui_components/loading_bar.html":{"url":"ui_components/loading_bar.html","title":"Loading Bar","keywords":"","body":"LoadingBar Have you ever played a game where you had to wait while it loaded up all the content it needed? It probably showed you a bar, filling in as it made progress accomplishing its task. This is often referred to as a progress bar, status bar or a loading bar. Creating a LoadingBar: #include \"ui/CocosGUI.h\" auto loadingBar = LoadingBar::create(\"LoadingBarFile.png\"); // set the direction of the loading bars progress loadingBar->setDirection(LoadingBar::Direction::RIGHT); this->addChild(loadingBar); In the above example a loading bar is created and we set the direction it should fill towards as progress is made. In this case to the right direction. However, you probably need to change the percentage of the LoadingBar. This is easily done: #include \"ui/CocosGUI.h\" auto loadingBar = LoadingBar::create(\"LoadingBarFile.png\"); loadingBar->setDirection(LoadingBar::Direction::RIGHT); // something happened, change the percentage of the loading bar loadingBar->setPercent(25); // more things happened, change the percentage again. loadingBar->setPercent(35); this->addChild(loadingBar); As you can see in the above example we specify a .png image for the LoadingBar objects texture: On screen a LoadingBar might look like this: "},"ui_components/sliders.html":{"url":"ui_components/sliders.html","title":"Slider","keywords":"","body":"Slider Sometimes it is necessary to change a value slightly. Perhaps you have a character and you want to allow the player to adjust the strength of attacking an enemy. A Slider allows users to set a value by moving an indicator. To create a Slider: #include \"ui/CocosGUI.h\" auto slider = Slider::create(); slider->loadBarTexture(\"Slider_Back.png\"); // what the slider looks like slider->loadSlidBallTextures(\"SliderNode_Normal.png\", \"SliderNode_Press.png\", \"SliderNode_Disable.png\"); slider->loadProgressBarTexture(\"Slider_PressBar.png\"); slider->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(slider); As you can see in the above example we specify a .png image for each of the possible states the slider can be in. A Slider is made up of 5 graphics that might look like this: On screen a Slider might look like this: "},"ui_components/textfields.html":{"url":"ui_components/textfields.html","title":"TextField","keywords":"","body":"TextField What if you wanted the player of your game to type in a special name to call the main character? Where would they type it into? Yes, a text field, of course. A TextField widget is used for inputting text. It supports touch event, focus, percent positioning and percent content size. To create a TextField widget: #include \"ui/CocosGUI.h\" auto textField = TextField::create(\"\",\"Arial\",30); textField->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ std::cout addChild(textField); In this example a TextField is created and a callback specified. TextField objects are versatile and can meet all of your input needs. Would you like the user to enter a secret password? Do you need to limit the number of characters a user can input? TextField objects have this all built-it and much more! Let's take a look at an example: #include \"ui/CocosGUI.h\" auto textField = TextField::create(\"\",\"Arial\",30); // make this TextField password enabled textField->setPasswordEnabled(true); // set the maximum number of characters the user can enter for this TextField textField->setMaxLength(10); textField->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ std::cout addChild(textField); On screen a TextField might look like this: When you are editing a TextField, the onscreen keyboard comes up: "},"other_node_types/":{"url":"other_node_types/","title":"Other Node Types","keywords":"","body":"Other Node Types Besides Node, you can add more advanced objects that are derived from Node. "},"other_node_types/getting_started.html":{"url":"other_node_types/getting_started.html","title":"More than just a Node","keywords":"","body":"Getting Started You are using Sprite, Label and Action objects in your game and it is making progress. Besides the basic Node types described in previous chapters, Cocos2d-x also provides more advanced Node types to help build special functionality. Perhaps you want to make a tile-based game? Or maybe a 2d side scroller? Or maybe you want to add particle effects to your game? Cocos2d-x provides Node objects to help you accomplish these goals! "},"other_node_types/tilemap.html":{"url":"other_node_types/tilemap.html","title":"TileMap","keywords":"","body":"TileMap TileMaps are maps made up of tiles. Each tile can have independent behavior. TileMaps are stored in an XML-based map format called TMX. TMX was originally designed for tile-based maps but is also suitable for more generic game levels due to its support for various object types. TMX objects are easy to create: // reading in a tiled map. auto map = TMXTiledMap::create(\"TileMap.tmx\"); addChild(map, 0, 99); // with a tag of '99' Tile-based maps can have many layers, determined by a z-order. You can access a specific layer by it's name: // how to get a specific layer auto map = TMXTiledMap::create(\"TileMap.tmx\"); auto layer = map->getLayer(\"Layer0\"); auto tile = layer->getTileAt(Vec2(1, 63)); Each tile has a unique position and id. This makes it very easy to cherry pick specific tiles. You can access any tile by its id: // to obtain a specific tiles id unsigned int gid = layer->getTileGIDAt(Vec2(0, 63)); Example tiled-map layouts: How do you make a tiled-map? There are many tools that do this. Tiled is a popular tool. It is actively developed and has a great user community. The screen-shots above are actual Tiled projects. "},"other_node_types/particles.html":{"url":"other_node_types/particles.html","title":"Particle System","keywords":"","body":"Particle System Perhaps your game needs effects like burning fire, spell casting visuals or explosions. How would you make such complex effects? Is it even possible? Yes, it is. Using a particle system. The term particle system refers to a computer graphics technique that uses a large number of very small sprites or other graphic objects to simulate certain kinds of fuzzy phenomena, which are otherwise very hard to reproduce with conventional rendering techniques. Some realistic examples might include highly chaotic systems, natural phenomena, or processes caused by chemical reactions. Here are a few examples of particle effects: Tools for creating Particle Effects Even though you can always create particle effects by hand, massaging each property to your liking. There are several third party tools for creating particle effects. A few of these tools are: Effekseer: Effekseer is a tool editing particle effects. Particle Designer: A very powerful particle effects editor on Mac. V-play particle editor: A cross-platform particle editor for Cocos2d-x. Particle2dx: An online web particle designer. These tools usually export a .plist file that you can read in with Cocos2d-x to use your creation inside your game. Just like with all of the other classes we have worked with so far we use the create() method: // create by plist file auto particleSystem = ParticleSystem::create(\"SpinningPeas.plist\"); Built-In Particle Effects Are you ready to add particle effects to your game? We hope so! Are you not yet comfortable with creating custom particle effects? For ease of convenience there are a number of built-in particle effects that you can choose from. Take a look at this list: -ParticleFire: Point particle system. Uses Gravity mode. -ParticleFireworks: Point particle system. Uses Gravity mode. -ParticleSun: Point particle system. Uses Gravity mode. -ParticleGalaxy: Point particle system. Uses Gravity mode. -ParticleFlower: Point particle system. Uses Gravity mode. -ParticleMeteor: Point particle system. Uses Gravity mode. -ParticleSpiral: Point particle system. Uses Gravity mode. -ParticleExplosion: Point particle system. Uses Gravity mode. -ParticleSmoke: Point particle system. Uses Gravity mode. -ParticleSnow: Point particle system. Uses Gravity mode. -ParticleRain: Point particle system. Uses Gravity mode. Using ParticleFireworks as an example, you can use the built-in effects easily: auto emitter = ParticleFireworks::create(); addChild(emitter, 10); The result is a particle effect that looks something like: But what do you do if your particle effect isn't quite the way you want? That's right, you can manually manipulate it! Let's take the same fireworks example above and manipulate it even further by manually changing its properties: auto emitter = ParticleFireworks::create(); // set the duration emitter->setDuration(ParticleSystem::DURATION_INFINITY); // radius mode emitter->setEmitterMode(ParticleSystem::Mode::RADIUS); // radius mode: 100 pixels from center emitter->setStartRadius(100); emitter->setStartRadiusVar(0); emitter->setEndRadius(ParticleSystem::START_RADIUS_EQUAL_TO_END_RADIUS); emitter->setEndRadiusVar(0); // not used when start == end addChild(emitter, 10); -startSize: Start size of the particles in pixels. >-endSize: Use kCCParticleStartSizeEqualToEndSize if you want that the start size == end size. >-startColor: (a ccColor4F). >-endColor: (a ccColor4F). >-life: time to live of the particles in seconds. >-angle: (a float). Starting degrees of the particle. >-positon: (a Vec2). >-centerOfGravity: (a Point). Besides the properties each _particle_ has, the _particle system_ itself also has properties that can be changed to achieve your desired effects. Some of these include: >-emissionRate: How many particle are emitted per second? >-duration: How many seconds does the particle system live? Use kCCParticleDurationInfinity for infinity. >-blendFunc: The OpenGL blending function used for the system. (a ccBlendFunc). >-positionType: Use kCCPositionTypeFree (default one) for moving particles freely. Or use kCCPositionTypeGrouped to move them in a group. >-texture: The texture used for the particles. (a Texture2D). ### Particle System Modes _Particle systems_ have two modes of operation. _Gravity Mode_ and _Radius Mode_. #### Gravity Mode _Gravity Mode_ lets particles fly toward or away from a center point. It's strength is that it allows very dynamic, organic effects. ![](other_node_types-img/particle6.png \"Gravity Mode\") _Gravity Mode_ only has a few properties that you can change. They are: >-gravity: The gravity of the particle system. >-speed: The speed at which the particles are emitted. >-speedVar: The speed variance. >-tangencialAccel: The tangential acceleration of the particles. >-tangencialAccelVar: The tangential acceleration variance. >-radialAccel: The radial acceleration of the particles. >-radialAccelVar: The radial acceleration variance. #### Radius Mode _Radius Mode_ causes particles to rotate in a circle. It also allows you to create spiral effects with particles either rushing inward or rotating outward. ![](other_node_types-img/particle5.png \"Radius Mode\") _Radius Mode_ only has a few properties that you can change. They are: >-startRadius: The starting radius of the particles >-startRadiusVar: The starting radius variance >-endRadius: The ending radius of the particles. >-endRadiusVar: The ending radius variance >-rotatePerSecond: Number of degrees to rotate a particle around the source pos per second. >-rotatePerSecondVar: Number of degrees variance. This all sounds really complicated but the fact that the code is simple helps to clarify these concepts. Let's take a look at an example to tie everything together: ```cpp //Create by plist file auto particleSystem = ParticleSystem::create(\"SpinningPeas.plist\"); // set the duration particleSystem->setDuration(ParticleSystem::DURATION_INFINITY); // radius mode particleSystem->setEmitterMode(ParticleSystem::Mode::RADIUS); // radius mode: 100 pixels from center particleSystem->setStartRadius(100); particleSystem->setStartRadiusVar(0); particleSystem->setEndRadius(ParticleSystem::START_RADIUS_EQUAL_TO_END_RADIUS); particleSystem->setEndRadiusVar(0); // not used when start == end // radius mode: degrees per second // 45 * 4 seconds of life = 180 degrees particleSystem->setRotatePerSecond(45); particleSystem->setRotatePerSecondVar(0); ``` ![](other_node_types-img/particle4.png) ** JASON - Replace the above screenshot with example from chapter 7 demo code --> "},"other_node_types/parallax.html":{"url":"other_node_types/parallax.html","title":"Parallax","keywords":"","body":"Parallax A Parallax Node is a special Node type that simulates a parallax scroller. What did you say? A para.. what? Yes, parallax Simply put you can consider a ParallaxNode to be a special effect that makes it appear that the position or direction of an object appears to differ when viewed from different positions. Simple every day examples include looking through the viewfinder and the lens of a camera. You can think of many games that function this way, Super Mario Bros being a classic example. ParallaxNode objects can be moved around by a Sequence and also manually by mouse, touch, accelerometer or keyboard events. Parallax nodes are a bit more complex than regular nodes. Why? Because they require the use of multiple nodes to function. A ParallaxNode cannot function by itself. You need at least 2 other Node objects to complete a ParallaxNode. As usual, in true Cocos2d-x fashion, a ParallaxNode is easy to create: // create ParallaxNode auto paraNode = ParallaxNode::create(); Since you need multiple Node objects, they too are easily added: // create ParallaxNode auto paraNode = ParallaxNode::create(); // background image is moved at a ratio of 0.4x, 0.5y paraNode->addChild(background, -1, Vec2(0.4f,0.5f), Vec2::ZERO); // tiles are moved at a ratio of 2.2x, 1.0y paraNode->addChild(middle_layer, 1, Vec2(2.2f,1.0f), Vec2(0,-200) ); // top image is moved at a ratio of 3.0x, 2.5y paraNode->addChild(top_layer, 2, Vec2(3.0f,2.5f), Vec2(200,800) ); OK, looks and feels familiar, right? Notice a few items! Each Node object that was added is given a unique z-order so that they stack on top of each other. Also notice the additional 2 Vec2 type parameters in the addChild() call. These are the ratio and offset. These parameters can be thought of as the ratio of speed to the parent Node. It's hard to show a ParallaxNode in text, so please run the example Programmer Guide Sample code to see this in action! "},"event_dispatcher/":{"url":"event_dispatcher/","title":"Event Dispatcher","keywords":"","body":"Event Dispatcher Cocos2d-x provides a mecanism for handling touch, keyboard, mouse and custom events for user input and game play mechanics. "},"event_dispatcher/getting_started.html":{"url":"event_dispatcher/getting_started.html","title":"What is the EventDispatch mechanism","keywords":"","body":"What is the EventDispatch mechanism? EventDispatch is a mechanism for responding to user events. The basics: Event listeners encapsulate your event processing code. Event dispatcher notifies listeners of user events. Event objects contain information about the event. "},"event_dispatcher/types.html":{"url":"event_dispatcher/types.html","title":"Types of event listeners","keywords":"","body":"There are 5 types of event listeners. EventListenerTouch - responds to touch events EventListenerKeyboard - responds to keyboard events EventListenerAcceleration - responds to accelerometer events EventListenMouse - responds to mouse events EventListenerCustom - responds to custom events Swallowing Events When you have a listener and you want an object to accept the event it was given you must swallow it. To say it another way, you consume it so that it doesn't get passed to other objects in highest to lowest priority. This is easy to do. // When \"swallow touches\" is true, then returning 'true' from the // onTouchBegan method will \"swallow\" the touch event, preventing // other listeners from using it. listener1->setSwallowTouches(true); // you should also return true in onTouchBegan() listener1->onTouchBegan = [](Touch* touch, Event* event){ // your code return true; }; "},"event_dispatcher/priority.html":{"url":"event_dispatcher/priority.html","title":"Events Priority","keywords":"","body":"FixedPriority vs SceneGraphPriority The EventDispatcher uses priorities to decide which listeners get delivered an event first. Fixed Priority is an integer value. Event listeners with lower Priority values get to process events before event listeners with higher Priority values. Scene Graph Priority is a pointer to a Node. Event listeners whose Nodes have higher z-order values (that is, are drawn on top) receive events before event listeners whose Nodes have lower z-order values (that is, are drawn below). This ensures that touch events, for example, get delivered front-to-back, as you would expect. Remember the Basic Concepts chapter? Where we talked about the scene graph and we talked about this diagram? Well, when use Scene Graph Priority you are actually walking this above tree backwards... I, H, G, F, E, D, C, B, A. If an event is triggered, H would take a look and either swallow it (more on this below) or let is pass through to I. Same thing, I will either consume it or let is pass through to G and so on until the event eitherswallowed_ it or does not get answered. "},"event_dispatcher/touch.html":{"url":"event_dispatcher/touch.html","title":"Touch Events","keywords":"","body":"Touch Events Touch events are the most important event in mobile gaming. They are easy to create and provide versatile functionality. Let's make sure we know what a touch event is. When you touch the screen of your mobile device, it accepts the touch, looks at where you touched and decides what you touched. Your touch is then answered. It is possible that what you touched might not be the responding object but perhaps something underneath it. Touch events are usually assigned a priority and the event with the highest priority is the one that answers. Here is how you create a basic touch event listener: // Create a \"one by one\" touch event listener // (processes one touch at a time) auto listener1 = EventListenerTouchOneByOne::create(); // trigger when you push down listener1->onTouchBegan = [](Touch* touch, Event* event){ // your code return true; // if you are consuming it }; // trigger when moving touch listener1->onTouchMoved = [](Touch* touch, Event* event){ // your code }; // trigger when you let up listener1->onTouchEnded = [=](Touch* touch, Event* event){ // your code }; // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, this); As you can see there are 3 distinct events that you can act upon when using a touch event listener. They each have a distinct time in which they are called. onTouchBegan is triggered when you press down. onTouchMoved is triggered if you move the object around while still pressing down. onTouchEnded is triggered when you let up on the touch. "},"event_dispatcher/keyboard.html":{"url":"event_dispatcher/keyboard.html","title":"Keyboard Events","keywords":"","body":"Keyboard events For desktop games, you might want find using keyboard mechanics useful. Cocos2d-x supports keyboard events. Just like with touch events above, keyboard events are easy to create. // creating a keyboard event listener auto listener = EventListenerKeyboard::create(); listener->onKeyPressed = CC_CALLBACK_2(KeyboardTest::onKeyPressed, this); listener->onKeyReleased = CC_CALLBACK_2(KeyboardTest::onKeyReleased, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this); // Implementation of the keyboard event callback function prototype void KeyboardTest::onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) { log(\"Key with keycode %d pressed\", keyCode); } void KeyboardTest::onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) { log(\"Key with keycode %d released\", keyCode); } "},"event_dispatcher/accelerometer.html":{"url":"event_dispatcher/accelerometer.html","title":"Accelerometer Events","keywords":"","body":"Accelerometer events Some mobile devices come equipped with an accelerometer. An accelerometer is a sensor that measures g-force as well as changes in direction. A use case would be needing to move your phone back and forth, perhaps to simulate a balancing act. Cocos2d-x also supports these events and creating them is simple. Before using accelerometer events, you need to enable them on the device: Device::setAccelerometerEnabled(true); // creating an accelerometer event auto listener = EventListenerAcceleration::create(CC_CALLBACK_2( AccelerometerTest::onAcceleration, this)); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this); // Implementation of the accelerometer callback function prototype void AccelerometerTest::onAcceleration(Acceleration* acc, Event* event) { // Processing logic here } "},"event_dispatcher/mouse.html":{"url":"event_dispatcher/mouse.html","title":"Mouse Events","keywords":"","body":"Mouse events As it always has, Cocos2d-x supports mouse events. _mouseListener = EventListenerMouse::create(); _mouseListener->onMouseMove = CC_CALLBACK_1(MouseTest::onMouseMove, this); _mouseListener->onMouseUp = CC_CALLBACK_1(MouseTest::onMouseUp, this); _mouseListener->onMouseDown = CC_CALLBACK_1(MouseTest::onMouseDown, this); _mouseListener->onMouseScroll = CC_CALLBACK_1(MouseTest::onMouseScroll, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(_mouseListener, this); void MouseTest::onMouseDown(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Down detected, Key: \"; str += tostr(e->getMouseButton()); } void MouseTest::onMouseUp(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Up detected, Key: \"; str += tostr(e->getMouseButton()); } void MouseTest::onMouseMove(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"MousePosition X:\"; str = str + tostr(e->getCursorX()) + \" Y:\" + tostr(e->getCursorY()); } void MouseTest::onMouseScroll(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Scroll detected, X: \"; str = str + tostr(e->getScrollX()) + \" Y: \" + tostr(e->getScrollY()); } "},"event_dispatcher/custom.html":{"url":"event_dispatcher/custom.html","title":"Creating Custom Events","keywords":"","body":"Custom Events The event types above are defined by the system, and the events (such as touch screen, keyboard response etc) are triggered by the system automatically. In addition, you can make your own custom events which are not triggered by the system, but by your code, as follows: _listener = EventListenerCustom::create(\"game_custom_event1\", [=](EventCustom* event){ std::string str(\"Custom event 1 received, \"); char* buf = static_cast(event->getUserData()); str += buf; str += \" times\"; statusLabel->setString(str.c_str()); }); _eventDispatcher->addEventListenerWithSceneGraphPriority(_listener, this); A custom event listener has been defined above, with a response method, and added to the event dispatcher. So how is the event handler triggered? Check it out: static int count = 0; ++count; char* buf[10]; sprintf(buf, \"%d\", count); EventCustom event(\"game_custom_event1\"); event.setUserData(buf); _eventDispatcher->dispatchEvent(&event); The above example creates an EventCustom object and sets its UserData. It is then dispatched manually with _eventDispatcher->dispatchEvent(&event). This triggers the event handler defined previously. The handler is called immediately so a local stack variable can be used as the UserData. "},"event_dispatcher/registering.html":{"url":"event_dispatcher/registering.html","title":"Registering Events","keywords":"","body":"Registering events with the dispatcher It is easy to register an event with the Event Dispatcher. Taking the sample touch event listener from above: // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, sprite1); It is important to note that a touch event can only be registered once per object. If you need to use the same listener for multiple objects you should use clone(). // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, sprite1); // Add the same listener to multiple objects. _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(), sprite2); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(), sprite3); Removing events from the dispatcher An added listener can be removed with following method: _eventDispatcher->removeEventListener(listener); Although they may seem special, built-in Node objects use the event dispatcher in the same way we have talked out. Makes sense, right? Take Menu for an example. When you have a Menu with MenuItems when you click them you are dispatching a event. You can also removeEventListener() on built-in Node objects. "},"3d/":{"url":"3d/","title":"3D","keywords":"","body":"3D You probably started with Cocos2d-x and know it as a 2D game engine. Starting with version 3, 3D features are being added and refined. 3D gaming is a huge market and Cocos2d-x is adding all the features you need for 3D development. 3D development might be new to you and use some terminology that you are unfamiliar with. There are also additional software tools that you need to become familiar with. Let's jump right in and get our feet wet. "},"3d/terminology.html":{"url":"3d/terminology.html","title":"Terminology","keywords":"","body":"Terminology When using 3D, there are some commonly used terms that you should be familiar with: Mesh - vertices that construct a shape and texture with which you are rendering. Model - an object that can be rendered. It is a collection of meshes. In our engine Sprite3D. Texture - All surfaces and vertices of a 3D model can be mapped to a texture. In most cases you will have multiple textures per model, unwrapped in a texture atlas. Camera - Since a 3D world is not flat, you need to set a camera to look at it. You get different scenes with different camera parameters. Light - Lightening is applied to make scenes look realistic. To make an object look real, the color should change according to the light. When you face the light it is bright and the opposite is dark. Lightening an object means computing the object's color according to the light. getName (), getGLProgramState (), _blendFunc, & _quad, 1, _billboardTransform); renderer-> addCommandToTransparentQueue (& _ quadCommand); BillBoard more details see the use of the methods and examples of BillBoardTest with cpptests ### Coordinate transformation `Camera` provide helpers to transform coordinates from screen space to world space. Example: ```cpp void unproject (const Size & viewport, Vec3 * src, Vec3 * dst) const; ``` Here viewport is _viewport size_, use `src` as screen coordinates, the z axis of the `src` indicates clipping plane distance information, -1 means the near clipping plane, 1 means far clipping plane. The `dst` parameter will return world space coordinates. ## Ray `Ray` is super useful in 3D game. You can use `Ray` to achieve things like picking up an object in 3D or detect collision in 3D. Illustration: ![](3d-img/Ray.png) ### Creating a Ray You need two vectors to create a `Ray`, one is the origin, the other is the direction. Example: ```cpp Ray ray (Vec3 (0,0,0), Vec3 (0,0,1)); ``` This will create a `Ray` originated from (0,0,0) in the direction of the positive Z axis. With this `Ray`, you can call the function with space intersects AABB box or any box OBB collision, the code is as follows: ```cpp Ray ray (Vec3 (0,0,0), Vec3 (0,0,1)); AABB aabb (Vec (-1, -1, -1), Vec (1,1,1)); if (ray .intersects (aabb)) { // ray intersects with AABB } else { // ray does not intersect with the AABB } ``` ## AABB `AABB` mean axis aligned bounding box, a 3D AABB is a simple six-sided, each side is parallel to a coordinate plane. It would look like this: ![](3d-img/AABB.png) AABB properties: Two vertices is particularly important: Pmin = [Xmin Ymin Zmin], Pmax = [Xmax Ymax Zmax]. Other points on the box are met Xmin positions; std::vector normals; std::vector texs; Mesh::IndexArray indices; positions.push_back(-5.0f);positions.push_back(-5.0f);positions.push_back(0.0f); positions.push_back(5.0f);positions.push_back(-5.0f);positions.push_back(0.0f); positions.push_back(5.0f);positions.push_back(5.0f);positions.push_back(0.0f); positions.push_back(-5.0f);positions.push_back(5.0f);positions.push_back(0.0f); texs.push_back(0.0f);texs.push_back(0.0f); texs.push_back(1.0f);texs.push_back(0.0f); texs.push_back(1.0f);texs.push_back(1.0f); texs.push_back(0.0f);texs.push_back(1.0f); indices.push_back(0); indices.push_back(1); indices.push_back(2); indices.push_back(0); indices.push_back(2); indices.push_back(3); auto mesh = Mesh::create(positions, normals, texs, indices); mesh->setTexture(\"quad.png\"); ``` How to render the construct Mesh? When all the information is rendered after we finished building Mesh already have, but also need the appropriate data into the rendering pipeline to render, so you can consider building a custom class derived from Node, overloading the Draw method, and building a MeshCommand in the Draw method and pass relevant data into the Mesh render queue, eventually rendering. For example custom class Draw method can add the following code: ```cpp auto programstate = mesh->getGLProgramState(); auto& meshCommand = mesh->getMeshCommand(); GLuint textureID = mesh->getTexture() ? mesh->getTexture()->getName() : 0; meshCommand.init(_globalZOrder , textureID , programstate , _blend , mesh->getVertexBuffer() , mesh->getIndexBuffer() , mesh->getPrimitiveType() , mesh->getIndexFormat() , mesh->getIndexCount() , transform); renderer->addCommand(&meshCommand); ``` The results: ![](3d-img/quad.png) ---> "},"3d/sprite3d.html":{"url":"3d/sprite3d.html","title":"Sprite3D","keywords":"","body":"Sprite3D Just like 2D games, 3D games also have Sprite objects. Sprite objects are a core foundation of any game. One of the main differences between Sprite and Sprite3D is Sprite3D objects have 3 axes it can be positioned on: x, y and z. Sprite3D works in many ways just like a normal Sprite. It is easy to load and display a Sprite3D object: auto sprite = Sprite3D::create(\"boss.c3b\"); //c3b file, created with the FBX-converter sprite->setScale(5.f); //sets the object scale in float sprite->setPosition(Vec2(200,200)); //sets sprite position scene->addChild(sprite,1); //adds sprite to scene, z-index: 1 This creates and positions a Sprite3D object from .c3b file. Example: Now, let's rotate the model in a loop. For this we will create an action and run it: //rotate around the X axis auto rotation = RotateBy::create(15, Vec3(0, 360, 0)); //our sprite object runs the action sprite->runAction(RepeatForever::create(rotation)); To set an anchor point on the Sprite or Sprite3D use: sprite->setAnchorPoint(Point(0.0f,0.0f)); Attaching 3D models to Sprite3D objects. Recall above that a 3D model is a collection of meshes. You can attach 3D models to other 3D models to create rich effects. An example would be adding a weapon to a character. To do this you need to find the attachment point where the weapon is to be added. For this use the getAttachNode(attachment_point_name) function. And then we just add the new model to the attachment point as a child with addChild(). You can think of this as combining multiple simpler 3D models to create more complex models. For example adding a model to a Sprite3D object: auto sp = Sprite3D::create(\"axe.c3b\"); sprite->getAttachNode(\"Bip001 R Hand\")->addChild(sp); Swap 3D Model When doing 3D development you might want to make dynamic changes to your model. Perhaps due to power-ups, costume changes or visual cues to notify the user about status changes of your model. If your 3D model is comprised from meshes you can access the mesh data using getMeshByIndex() and getMeshByName(). Using these functions it is possible to achieve effects like swapping a weapon or clothing for a character. Let's take a look at an example of a girl wearing a coat: We can change the coat that the girl is wearing by changing the visibility of the mesh objects we are using. The following example demonstrates how to do this: auto sprite = Sprite3D::create(\"ReskinGirl.c3b\"); // display the first coat auto girlTop0 = sprite->getMeshByName(\"Girl_UpperBody01\"); girlTop0->setVisible(true); auto girlTop1 = sprite->getMeshByName(\"Girl_UpperBody02\"); girlTop1->setVisible(false); // swap to the second coat girlTop0->setVisible(false); girlTop1->setVisible(true); The results: "},"3d/animation.html":{"url":"3d/animation.html","title":"Animation","keywords":"","body":"Animation Sprite3D objects are essential to our game! We have learned how to manipulate them. However, we might want a more rich experience. Enter animation! To run a 3d animation, you can use the Animation3D and Animate3D objects. You then create an Animate3D action using the Animation3D object. Example: // the animation is contained in the .c3b file auto animation = Animation3D::create(\"orc.c3b\"); // creates the Action with Animation object auto animate = Animate3D::create(animation); // runs the animation sprite->runAction(RepeatForever::create(animate)); Run the example Programmer Guide Sample code to see this in action! Please keep in mind that 3D animations are exactly the same concepts as 2D. Please refer to Chapter 4 in this guide. Multiple animations What do you do when you want to run multiple animations at the same time? Using both the animation start time and animation length parameters you can create multiple animations. The unit for both parameters is seconds. Example: auto animation = Animation3D::create(fileName); auto runAnimate = Animate3D::create(animation, 0, 2); sprite->runAction(runAnimate); auto attackAnimate = Animate3D::create(animation, 3, 5); sprite->runAction(attackAnimate); In the above example there are two animations that get run. The first starts immediately and lasts for 2 seconds. The second starts after 3 seconds and lasts for 5 seconds. Animation speed The speed of the animation is a positive integer for forward while a negative speed would be reverse. In this case the speed is set to 10. This means that this animation can be considered to be 10 seconds in length. Animation blending When using multiple animations, blending is automatically applied between each animation. The purpose of blending is to create a smooth transition between effects. Given two animations, A and B, the last few frames of animation A and the first few frames of animation B overlap to make the change in animation look natural. The default transition time is 0.1 seconds. You can set the transition time by using Animate3D::setTransitionTime. Cocos2d-x only supports linear interpolation between keyframes. This fills in gaps in the curve to ensure a smooth path. If you use other interpolation methods in the model production, our built-in tool, fbx-conv will generate additional keyframes to compensate. This compensation is completed in accordance with the target frame. For more information on fbx-conv please refer to the section discussing it at the end of this chapter. "},"3d/camera.html":{"url":"3d/camera.html","title":"Camera","keywords":"","body":"Camera Camera objects are an important aspect of 3D development. Since a 3D world is not flat you need to use a Camera to look at it and navigate around it. Just like when you are watching a movie and the scene pans to the left or right. This same concept is applied when using a Camera object. The Camera object inherits from Node and therefore supports most of the same Action objects. There are two types of Camera objects: perspective camera and orthographic camera. The perspective camera is used to see objects having a near to far effect. A perspective camera view might look like this: As you can see with a perspective camera, objects in the near are larger and objects in the far are smaller. The orthogonal camera is used to see objects as large distance. You can think about it as converting a 3D world to a 2D representation. An orthogonal camera view might look like this: As you can see with an orthogonal camera, objects are the same size regardless of how far away from the Camera object they are. Mini Maps in games are commonly rendered with an orthogonal camera. Another example would be a top - down view, perhaps in a dungeon style game. Camera Use Don't worry! Camera objects may sound complicated but Cocos2d-x makes them easy. When using 3D you don't have to do anything special to create a Camera object. Each Scene automatically creates a default camera, based on the projection properties of the Director object. If you need more than one camera, you can use the following code to create one: auto s = Director::getInstance()->getWinSize(); auto camera = Camera::createPerspective(60, (GLfloat)s.width/s.height, 1, 1000); // set parameters for camera camera->setPosition3D(Vec3(0, 100, 100)); camera->lookAt(Vec3(0, 0, 0), Vec3(0, 1, 0)); addChild(camera); //add camera to the scene Creating orthogonal camera The default Camera is a perspective camera. If you want to create an orthogonal camera, it's easy to do by calling: Camera::createOrthographic(); Example: auto s = Director::getInstance()->getWinSize(); auto camera = Camera::createOrthographic(s.width, s.height, 1, 1000); Hiding objects from the camera Sometimes you don't want to have all objects visible in a Camera view. Hiding an object from one camera is very easy. Use setCameraMask(CameraFlag) on the Node and setCameraFlag(CameraFlag) on the Camera. Example: //Camera camera->setCameraFlag(CameraFlag::USER1); //Node node->setCameraMask(CameraFlag::USER1); "},"3d/cubemap.html":{"url":"3d/cubemap.html","title":"Cubemap Texture","keywords":"","body":"Cubemap Texture A cube map texture is a collection of six separate square textures that are put onto the faces of an imaginary cube. Most often they are used to display infinitely far away reflections on objects, similar to how sky box displays far away scenery in the background. This is what an expanded cube map might look like: In Cocos2d-x, you can create a cube map texture in this way: // create a textureCube object with six texture assets auto textureCube = TextureCube::create(\"skybox/left.jpg\", \"skybox/right.jpg\", \"skybox/top.jpg\", \"skybox/bottom.jpg\", \"skybox/front.jpg\", \"skybox/back.jpg\"); // set cube map texture parameters Texture2D::TexParams tRepeatParams; tRepeatParams.magFilter = GL_NEAREST; tRepeatParams.minFilter = GL_NEAREST; tRepeatParams.wrapS = GL_MIRRORED_REPEAT; tRepeatParams.wrapT = GL_MIRRORED_REPEAT; textureCube->setTexParameters(tRepeatParams); // create and set our custom shader auto shader = GLProgram::createWithFilenames(\"cube_map.vert\", \"cube_map.frag\"); auto _state = GLProgramState::create(shader); // bind cube map texture to uniform state->setUniformTexture(\"u_cubeTex\", textureCube); "},"3d/skybox.html":{"url":"3d/skybox.html","title":"Skybox","keywords":"","body":"Skybox Skybox is a wrapper around your entire scene that shows what the world looks like beyond your geometry. You might use a Skybox to simulate infinite sky, mountains and other phenomena. Creating a Skybox: // create a Skybox object auto box = Skybox::create(); // set textureCube for Skybox box->setTexture(_textureCube); // attached to scene _scene->addChild(box); "},"3d/lighting.html":{"url":"3d/lighting.html","title":"Lighting","keywords":"","body":"Light Light is really important for building mood and ambiance for a game. There are currently 4 lighting techniques supported. You would use different lighting techniques depending upon your needs. Each lighting effect achieves a different result. Ambient Light An AmbientLight object will apply light evenly for everything in the scene. Think of lighting in an office environment. The lights are overhead and when you look at objects around the office you see them in the same light. Example: auto light = AmbientLight::create (Color3B::RED); addChild(light); This produces: Directional Light DirectionalLight is often used to simulate a light source such as sunlight. When using DirectionalLight keep in mind that is has the same density no matter where you are in relationship to it. Also think about being outside on a sunny day with the sun beaming down on you. When you look directly at the sun, it is an intense light even if you move a few steps in any direction. Example: auto light = DirectionLight::create(Vec3(-1.0f, -1.0f, 0.0f), Color3B::RED); addChild(light); This produces: Point Light PointLight is often used to simulate the effect of light bulbs, lamps or torches. The direction of a PointLight is from the lighted position to the PointLight. Keep in mind that the density is different depending upon the distance from the PointLight. What does this mean? If you are close to the start of the PointLight it will be really strong. If you are towards the end of the PointLight it will be dim. PointLight also becomes weaker the larger the distance it is projected. Example: auto light = PointLight::create(Vec3(0.0f, 0.0f, 0.0f), Color3B::RED, 10000.0f); addChild(light); This produces: Spot Light A SpotLight object is often used to simulate a flashlight. This means that it is emitted in just one direction in the shape of a cone. Think about the power going out in your house. You may need to take a flashlight down into your basement to reset your circuits. The flashlight produces a cone shaped lighting pattern and you can only see objects inside that cone pattern. Another example is in dark, dungeon based games where your path is light by torches. You can only see the limited cone shape that those torches emit. Example: auto spotLight = SpotLight::create(Vec3(-1.0f, -1.0f, 0.0f), Vec3(0.0f, 0.0f, 0.0f), Color3B::RED, 0.0, 0.5, 10000.0f) ; addChild(spotLight); This produces: Light Masking What do you use for lights in your kitchen or living room? Probably a few lamps? Do you ever notice that perhaps you only use a lamp to light up a certain portion of the room? You are essentially applying a lighting mask! A lighting mask is used on a Node to only apply a particular lighting source to it. For example, if you had multiple lights in a Scene, a Node can only be lighted by one of the lights instead of all three. You can use setLightFlag(LightFlag) to control which Node objects are effected by the light. It is important to note that all lighting sources are rendered in a single pass. Due to mobile platform performance issues the use of multiple light sources is not recommended. The default maximum is 1. If you want to open multiple light sources you must define the following keys in info.plist: cocos2d.x.3d.max_dir_light_in_shader 1 cocos2d.x.3d.max_point_light_in_shader 1 cocos2d.x.3d.max_spot_light_in_shader 1 "},"3d/terrain.html":{"url":"3d/terrain.html","title":"Terrain","keywords":"","body":"Terrain Terrain is an important component in 3D game. A texture is used to stand for the height map. And up to 4 textures can be used to blend the details of the terrain, grass, road, and so on. HeightMap HeightMap objects are the core of the terrain. Different from the common image the height map represents the height of vertices. It determines the terrain's geometry shape. DetailMap DetailMap objects are a list of textures determining the details of the terrain, up to four textures can be used. AlphaMap AlphaMap objects are an image whose data is the blend weights of detail maps. The blending result is the final terrain's appearance. LOD policy Terrain uses an optimization technique called Level Of Detail or LOD. This is a rendering technique that reduces the number of verticies (or triangles) that are rendered ,for an object, as its distance from camera increases. Users can set the distance to the Camera by calling the Terrain::setLODDistance(float lod1, float lod2, float lod3) method. Neighboring chunks of Terrain objects, which have different LOD may cause the crack artifacts. Terrain provide two functions to avoid them: Terrain::CrackFixedType::SKIRT Terrain::CrackFixedType::INCREASE_LOWER Terrain::CrackFixedType::SKIRT will generate four, skirt-like meshes at each edge of the chunk. Terrain::CrackFixedType::INCREASE_LOWER will dynamically adjust each chunks indices to seamlessly connect them. How to create a terrain Creating a Terrain takes a few steps. Example: The following code snippet is creating a player and place it on the terrain: auto player = Sprite3D::create(\"chapter9/orc.c3b\"); player->setScale(0.08); player->setPositionY(terrain->getHeight(player->getPositionX(),player->getPositionZ())); create all DetailMap objects (up to four), you need pass the DetailMap objects to the Terrain::DetailMap struct: Terrain::DetailMap r(\"dirt.dds\"); Terrain::DetailMap g(\"grass.dds\"); Terrain::DetailMap b(\"road.dds\"); Terrain::DetailMap a(\"greenSkin.jpg\"); to create a TerrainData variable with detail maps, you need to specify the terrain's height map file path and alpha map file path: Terrain::TerrainData data(\"chapter9/heightmap16.jpg\",\"TerrainTest/alphamap.png\", r, g, b, a); pass the TerrainData object to Terrain::create, the last parameter determines the LOD policy (as talked about above). Example: _terrain = Terrain::create(data, Terrain::CrackFixedType::SKIRT); If you set a Terrain objects camera mask and add it to a Node or a Scene, be careful. When Terrain is added into a Node or a Scene, you can not use transform(translate, scale) on it anymore. If you do this after calling addChild(), some of the terrain's methods may calculate wrong results. Get Terrain Height Use the method Terrain::getHeight(float x, float z, Vec3 * normal= nullptr) to get the specified position's height. This method is very useful when you want to put a Sprite3D object or any Node on the terrain's surface. Ray-Terrain intersection test A Ray-Terrain intersection test will calculate the intersection point by giving a specified position. Terrain::CrackFixedType::SKIRT will generate four skirt-like meshes at each chunks edge. Terrain::CrackFixedType::INCREASE_LOWER will dynamically adjust each chunks index to seamlessly connect them. "},"3d/tools.html":{"url":"3d/tools.html","title":"Tools","keywords":"","body":"3D Software Packages 3D Editors 3D editors are collections of tools that you use to build your 3D graphics. There are both commercial and free tools available. These are the most popular editors: Blender (Free) 3DS Max Cinema4D Maya Most 3D editors usually save files in a common collection of formats for easy use within other editors as well as a standard way for game engines to import your files for use. Cocos2d-x Provided Tools Cocos2d-x provides tools to help with converting your 3D models to formats that Cocos2d-x uses to provide access to all aspects of your 3D files. fbx-conv command-line tool fbx-conv allows the conversion of an FBX file into the Cocos2d-x proprietary formats. FBX is the most popular 3D file format and is being supported by all the major editors. fbx-conv exports to .c3b by default. It is simple to use with just a few parameters: fbx-conv [-a|-b|-t] FBXFile The possible switches are: -?: show help -a: export both text and binary format -b: export binary format -t: export text format Example: fbx-conv -a boss.FBX There are a few things to note about fbx-conv: The model needs to have a material that contains at least one texture it only supports skeletal animation. it only supports one skeleton object no multiple skeleton support yet. You can create a 3d scene by exporting multiple static model The maximum amount of vertices or indices a mesh is 32767 3D File Formats Cocos2d-x currently supports two 3d file formats: Wavefront Object files: .obj files Cocos2d-x 3d ad-hoc format:c3t, c3b files. The Wavefront file format is supported because it has been widely adopted by 3D editors and it is extremely easy to parse. It is, however, limited and doesn't support advanced features like animations. On the other hand, c3t and c3b are Cocos2d-x proprietary file formats that were created to allow animations, materials and other advanced 3d features. The suffix t means text, while the suffix b means binary. Developers must use c3b for production because it is more efficient. In case you want to debug the file and track its changes in Git or any other version control system, you should c3t instead. Also, Animation3D objects can be created with c3b or c3t files as it is not possible to animate obj files. "},"3d/advanced.html":{"url":"3d/advanced.html","title":"Advanced 3D Topics","keywords":"","body":"Advanced Topics BillBoard You may not have heard of a BillBoard before. No, I'm not talking about an advertisement on the side of a highway. Rather, Billboard is a special Sprite that always faces the Camera. As you rotate the Camera, Billboard objects also rotate. Using aBillBoard is a very common rendering technique. Take for example a downhill skiing game. Any trees, rocks or other objects that are in the way of the skier are Billboard objects. This is how Camera and Billboard objects relate to each other. Billboard objects are easy to create. BillBoard is derived from Sprite, so it supports most of the features as a Sprite object. We can create one using the following create method: auto billboard = BillBoard::create(\"Blue_Front1.png\", BillBoard::Mode::VIEW_POINT_ORIENTED); You can also create a Billboard object for the camera XOY plane (like the plane of a floor) by changing the BillBoard objects mode: auto billboard = BillBoard::create(\"Blue_Front1.png\", BillBoard::Mode::VIEW_PLANE_ORIENTED); These create methods look a little different since an additional parameter of BillBoard::Mode is passed in. There are two BillBoard::Mode types, VIEW_POINT_ORIENTED and VIEW_PLANE_ORIENTED. VIEW_POINT_ORIENTED is where the BillBoard object is oriented to the Camera. Example: VIEW_PLANE_ORIENTED is where the BillBoard is oriented towards the XOY plane of the Camera. Example: You can also set properties for a BillBoard just like with any other Node. These include, but are not limited to: scale, position, rotation. Examples: billboard->setScale(0.5f); billboard->setPosition3D(Vec3(0.0f, 0.0f, 0.0f)); billboard->setBlendFunc(BlendFunc::ALPHA_NON_PREMULTIPLIED); addChild(billboard); ParticleSystem3D In Chapter 7, you learned about 2D particles and how to use them. When you use 3D you might also want to use a 3D particle system for rich, advanced effects. Many of the same concepts apply for a 3D particle system as they did with a 2D particle system. Cocos2d-x currently supports Particle Universe (//www.fxpression.com/) for particle system construction. Particle Universe provides a special particle editor that allows you to quickly and easily set up a variety of effects, such as explosions, fire, blood and other special effects. This editor uses a pu file extension when saving or exporting. When you are happy with your particle and ready to use it in code, exporting to its built-in format of pu is enough! Cocos2d-x supports this format directly. Also, as ParticleSystem3D is derived from Node, it supports most of the features that Node supports. PUParticleSystem3D is an object type specifically for dealing with Particle Universe particles. PUParticleSystem3D offers two ways for creating particles. The first way is to build a particle by passing in a Particle Universe file and its corresponding material file. Remember from Chapter 7 that a material file is what describes the particle. This is required. Example: auto ps = PUParticleSystem3D::create(\"lineStreak.pu\", \"pu_mediapack_01.material\"); ps->startParticleSystem(); this->addChild(ps); The second way is to build the particle system only by passing a particle universe file. When you create a particle this way, besides loading the particle, all material files in the same folder as the particle file will automatically be loaded. Here is an example: auto ps = PUParticleSystem3D::create(\"electricBeamSystem.pu\"); ps->startParticleSystem(); this->addChild(ps); Note: using this method will result in an increase in loading times and consumes more memory since everything will be loaded. If you know what material you want to use and don't need to load everything, using the first method would be preferred. In these images below, on the left is the particle in particle universe, while on the right is the effect running in Cocos2d-x: Once you have your particle, you can interact with it it fairly obvious ways. You can interact with with the particle system as a whole, starting, stopping, pausing, resuming and obtaining the total number of particles: virtual void startParticleSystem() override; virtual void stopParticleSystem() override; virtual void pauseParticleSystem() override; virtual void resumeParticleSystem() override; virtual int getAliveParticleCount() const override; As PUParticleSystem3D is derived from Node you can run Action and Sequence objects on your particles! Example: auto ps = PUParticleSystem3D::create(\"blackHole.pu\", \"pu_mediapack_01.material\"); ps->setPosition(-25.0f, 0.0f); auto moveby = MoveBy::create(2.0f, Vec2(50.0f, 0.0f)); auto moveby1 = MoveBy::create(2.0f, Vec2(-50.0f, 0.0f)); ps->runAction(RepeatForever::create(Sequence::create(moveby, moveby1, nullptr))); ps->startParticleSystem(); Combining Action and Sequence objects could produce an interesting black hole effect: Just like with other 3D objects you can also combine 3D objects using AttachNode. This allows for creating rich models. Example: auto sprite3d = Sprite3D::create(\"orc.c3b\"); sprite3d->setPosition3D(Vec3(0.0f, 0.0f, 0.0f)); sprite3d->setRotation3D(Vec3(0.0f, 180.0f, 0.0f)); auto animation = Animation3D::create(\"orc.c3b\"); if (animation) { auto animate = Animate3D::create(animation); sprite3d->runAction(RepeatForever::create(animate)); } auto handler = PUParticleSystem3D::create(\"lightningBolt.pu\"); handler->startParticleSystem(); sprite3d->getAttachNode(\"Bip001 L Hand\")->addChild(handler); this->addChild(sprite3d); "},"scripting/":{"url":"scripting/","title":"Scripting","keywords":"","body":"Scripting Cocos2d-x provides a simple mechanism for using Lua and JavaScript scripting inside of your game. "},"scripting/script_component.html":{"url":"scripting/script_component.html","title":"Script component","keywords":"","body":"Script component Script component is used to extend c++ Node objects. You can add a script component to a Node, then the script component will receive onEnter, onExit and update events. Script component supports both JavaScript and LUA. You should use the proper script component type for the language you are developing with. If you are developing with JavaScript, you would use ComponentJS, if you are developing with Lua, you would use ComponentLUA. But, you cannot mix them or use them in a c++ project! This is because the proper bindings for that language are required and these bindings are only available in their respective project types. Example with Lua: // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto luaComponent = ComponentLua::create(\"player.lua\"); player->addComponent(luaComponent); -- player.lua local player = { onEnter = function(self) -- do some things in onEnter end, onExit = function(self) -- do some things in onExit end, update = function(self) -- do some things every frame end } -- it is needed to return player to let c++ nodes know it return player Example with JavaScript: // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto jsComponent = ComponentJS::create(\"player.js\"); player->addComponent(jsComponent); // player.js Player = cc.ComponentJS.extend({ generateProjectile: function (x, y) { var projectile = new cc.Sprite(\"components/Projectile.png\", cc.rect(0, 0, 20, 20)); var scriptComponent = new cc.ComponentJS(\"src/ComponentTest/projectile.js\"); projectile.addComponent(scriptComponent); this.getOwner().getParent().addChild(projectile); // set position var winSize = cc.director.getVisibleSize(); var visibleOrigin = cc.director.getVisibleOrigin(); projectile.setPosition(cc.p(visibleOrigin.x + 20, visibleOrigin.y + winSize.height/2)); // run action var posX = projectile.getPositionX(); var posY = projectile.getPositionY(); var offX = x - posX; var offY = y - posY; if (offX One difference to keep in mind, between JavaScript and LUA components, is you should return the object in LUA component, in JavaScript, you only have to extend cc.ComponentJS For more detailed usage, please refer to tests projects: tests/lua-tests/src/ComponentTest and tests/js-tests/src/ComponentTest. getOpenGLView | | cc.GLViewImpl:create(\"Lua Empty Test\") | cocos2d::GLViewImpl::create(\"Lua Empty Test\") | | glView:setDesignResolutionSize(480, 320, cc.ResolutionPolicy.NO_BORDER) | glview->glView:setDesignResolutionSize(480, 320, ResolutionPolicy::NO_BORDER)| ``` From this table, we can see that the functions called in lua are very similar with the functions called in c++. These are some key points that we need to pay attention to: - `cc` is a module name like namespace name in c++,it is Cocos2d-x 3.0 new features. The relation between lua modules and c++ namespaces is as follow: ```cpp | Lua module name | c++ namespace | | cc | cocos2d, cocos2d::extension, CocosDenshion, cocosbuilder | | ccui | cocos2d::ui | | ccs | cocostudio, cocostudio::timeline | | sp | spine | | ccexp | cocos2d::experimental, cocos2d::experimental::ui | ``` - static and non-static c++ functions are called in lua using `:` - `cc.ResolutionPolicy.NO_BORDER` corresponds to `ResolutionPolicy::NO_BORDER` which is enum value in the c++. `enum` values are bound to lua by manual. Different modules use different lua files to keep the bindings value: ```cpp | moudle name | const value files | | cc | Cocos2dConstants.lua, ExtensionConstants.lua, NetworkConstants.lua| | ccui | GuiConstants.lua | | ccs | StudioConstants.lua| | ccexp | experimentalUIConstants.lua| ``` - For some functions, their parameters include cocos2d::Vec2, cocos2d::Vec3 we should do a conversion to call c++ function.For example: ```cpp void Node::setPosition(const Vec2& position) ``` In c++, we should call this function like this: ```cpp nodeObj->setPosition(Vec2(0.0f, 0.0f)) ``` In lua, we should call the function like this: ```cpp nodeObj:setPosition(cc.p(0.0, 0.0)) ``` `cc.p(0.0, 0.0)` is to construct an anonymous table like this {x = 0, y =0} The other parametric types that should be converted are: ``` | parametric types | lua conversional format | | cocos2d::Point | {x = numValue, y = numValue} | | cocos2d::Vec3 | {x = numValue, y = numValue, z = numValue} | | cocos2d::Vec4 | {x = numValue, y = numValue, z = numValue, w = numValue} | | cocos2d::Rect | {x = numValue, y = numValue, width = numValue, height = numValue} | | cocos2d::Size | {width = numValue, height = numValue} | | cocos2d::Color4B | {r = numValue, g = numValue, b = numValue, a = numValue} | | cocos2d::Color4F | {r = numValue, g = numValue, b = numValue, a = numValue} | | cocos2d::Color3B | {r = numValue, g = numValue, b = numValue} | | cocos2d::PhysicsMaterial | {density = numValue, restitution = numValue, friction = numValue} | | cocos2d::AffineTransform | {a = numValue, b = numValue, c = numValue, d = numValue, tx = numValue, ty = numValue} | | cocos2d::FontDefinition | {fontName = stringValue, fontSize = numValue, fontAlignmentH = numValue, fontAlignmentV = numValue, fontFillColor = {r = numValue, g = numValue, b = numValue}, fontDimensions = {width = numValue, height = numValue}, shadowEnabled = boolValue[,shadowOffset = {width = numValue, height = numValue}, shadowBlur = numValue, shadowOpacity = numValue], strokeEnabled = boolValue[,strokeColor = {r = numValue, g = numValue, b = numValue}, strokeSize = numValue]} | | cocos2d::Vector | {objValue1,objValue2,...,objValuen,...}| | cocos2d::Map| {key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} | | cocos2d::Value | {objValue1,objValue2,...,objValuen,...} or key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} or stringValue or boolValue or numValue | | cocos2d::ValueMap | {key1 = Value1, key2 = Value2,..., keyn = Valuen,...} | | cocos2d::ValueMapIntKey | {numKey1 = Value1, intKey2 = Value2, ...,intKeyn = Valuen,...} | | cocos2d::ValueVector | {Value1, Value2, ..., Valuen, ...} | | std::vector | {stringValue1, stringValue2, ..., stringValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | cocos2d::Mat4 | {numValue1,numValue2,..., numValue16} | | cocos2d::TTFConfig |{fontFilePath = stringValue, fontSize = numValue, glyphs = numValue, customGlyphs = stringValue, distanceFieldEnabled = boolValue, outlineSize = numValue} | cocos2d::MeshVertexAttrib| {size = numValue, type = numValue, vertexAttrib = numValue, vertexAttrib =numValue} | | cocos2d::BlendFunc | { src = numValue, dst = numValue} | ``` ### Call global functions Cocos2d-x v3 also binds some global functions to lua manually, such as `kmGLPushMatrix`, `kmGLTranslatef` and `kmGLLoadMatrix`. We can call these global functions in lua as follows: ```cpp kmGLPopMatrix() ``` ### Call OpenGL functions Cocos2d-x v3 binds some OpenGL functions to lua. All the OpenGL functions are in the `gl` module and can be called as follows: ```cpp local glNode = gl.glNodeCreate() glNode:setContentSize(cc.size(256, 256)) glNode:setAnchorPoint(cc.p(0.5, 0.5)) uniformCenter = gl.getUniformLocation(program,\"center\") uniformResolution = gl.getUniformLocation( program, \"resolution\") ``` You can refer to `lua-tests/DrawPrimitiveTest` and `lua-tests/OpenGLTest` for more information. ## Bind a c++ class to lua by bindings-generator automatically Since Cocos2d-x v3.0, there is a tools called [bindings-generator](https://github.com/cocos2d/bindings-generator) to bind c++ class to lua automatically. The _bindings-generator_ is based on _tolua++_. There is an _ini_ file in the `tools/tolua` directory and then run the _genbindings.py_ script to generate the binding code. ### Create a custom class Consider this code: ```cpp // CustomClass.h #ifndef __CUSTOM__CLASS #define __CUSTOM__CLASS #include \"cocos2d.h\" namespace cocos2d { class CustomClass : public cocos2d::Ref { public: CustomClass(); ~CustomClass(); static cocos2d::CustomClass* create(); bool init(); CREATE_FUNC(CustomClass); }; } //namespace cocos2d #endif // __CUSTOM__CLASS ``` Note: - the cpp file was omitted because the bindings-generator only scan the header files - The custom class should be inherited from the `Ref` class, this is mainly due to the destructor of `Ref` calling `removeScriptObjectByObject` to reduce the reference count of _userdata_ which gets created in the c++ automatically to avoid memory leak. ### Add a new cocos2dx_custom.ini file In _tools/lua_ folder create a new file named _cocos2dx_custom.ini_ as: ```cpp [cocos2dx_custom] # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_custom # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns # all classes will be embedded in that namespace target_namespace = cc android_headers = -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_flags = -D_SIZE_T_DEFINED_ clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include clang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__ cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/my -I%(cocosdir)s/cocos/2d -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/ui -I%(cocosdir)s/cocos/physics -I%(cocosdir)s/cocos/2d/platform -I%(cocosdir)s/cocos/2d/platform/android -I%(cocosdir)s/cocos/math/kazmath -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s cocos_flags = -DANDROID -DCOCOS2D_JAVASCRIPT cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse headers = %(cocosdir)s/cocos/my/CustomClass.h # what classes to produce code for. You can use regular expressions here. # When testing the regular expression, it will be enclosed in \"^$\", like # this: \"^Menu*$\". classes = CustomClass.* # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: # \"^ClassName$\" functions are also regular expressions, they will not be # surrounded by \"^$\". If you want to skip a whole class, just add a single # \"*\" as functions. See bellow for several examples. A special class name # is \"*\", which will apply to all class names. This is a convenience # wildcard to be able to skip similar named functions from all classes. skip = rename_functions = rename_classes = # for all class names, should we remove something when registering in the # target VM? remove_prefix = # classes for which there will be no \"parent\" lookup classes_have_no_parents = # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = # Determining whether to use script object(js object) to control the # lifecycle of native(cpp) object or the other way around. Supported # values are 'yes' or 'no'. script_control_cpp = no ``` All of the config files under _tools/tolua_ use the same format. Here is a list which you should consult when writing your own ini file: - [title]: To config the title which will by used by the *tools/tolua/gengindings.py* scripts. Generally, the title could be the file name. - prefix: To config the prefix of a function name, generally, we also use the file name as the prefix. - target_namespace: To config the module name in lua. Here we use the `cc` as the module name, when you want to use `CustomClass` in lua, you must put a prefix named `cc` in front of the name. For example, the `CustomClass` could be reference as `cc.CustomClass`. - headers: To config all the header files needed for parsing and the %(cocosdir)s is the engine root path of Cocos2d-x. - classes: To config all the classes needed to bind. Here it supports regular expression. So we could set MyCustomClass.* here. For looking more specified usage, you could ref to `tools/tolua/cocos2dx.ini`. - skip: To config the functions needed to be omit. Now the bindings-generator can't parse `void*` type and also the delegate type, so these types needed to be bind manually. And at this circumstance, you should omit all these types first and then to bind them manually. You could ref to the config files under path `cocos/scripting/lua-bindings/auto` . - rename_functions: To config the functions need to be renamed in the scripting layer. Due to some reasons, developers want more scripting friendly API, so the config option is for this purpose. - rename_classes: Not used any more. - remove_prefix: Not used any more. - classes_have_no_parents: To config the parent class needed to be filter. This option is seldom modified. - abstract_classes: To config the classes whose public constructor don't need to be exported. - script_control_cpp:yes. To config whether the scripting layer manage the object life time or not. If no, then the c++ layer cares about their life time. Now, it is imperfect to control native object's life time in scripting layer. So you could simply leave it to *no*. ## Subclassing Sometimes we want to add some new functions to extend the bindings, think inheritance in c++. Through `class(classname, super)` function in the `cocos/scripting/lua-bindings/script/cocos2d/extern.lua`, we can realize this requirement easily. The details function are as follow: ```cpp function class(classname, super) local superType = type(super) local cls if superType ~= \"function\" and superType ~= \"table\" then superType = nil super = nil end if superType == \"function\" or (super and super.__ctype == 1) then -- inherited from native C++ Object cls = {} if superType == \"table\" then -- copy fields from super for k,v in pairs(super) do cls[k] = v end cls.__create = super.__create cls.super = super else cls.__create = super end cls.ctor = function() end cls.__cname = classname cls.__ctype = 1 function cls.new(...) local instance = cls.__create(...) -- copy fields from class to native object for k,v in pairs(cls) do instance[k] = v end instance.class = cls instance:ctor(...) return instance end else -- inherited from Lua Object if super then cls = clone(super) cls.super = super else cls = {ctor = function() end} end cls.__cname = classname cls.__ctype = 2 -- lua cls.__index = cls function cls.new(...) local instance = setmetatable({}, cls) instance.class = cls instance:ctor(...) return instance end end return cls end ``` Through this function, we can see inheritance easily. Example, if we want to derive from `cc.Node`: 1. Define a subclass by `class` function ```cpp local SubNode = class(\"SubNode\",function() return cc.Node:create() end) --This function like the construtor of c++ class function SubNode:ctor() -- do initialized end function SubNode:addSprite(filePath) local sprite = cc.Sprite:create(filePath) sprite:setPosition(cc.p(0, 0)) self:addChild(sprite) end ``` 2. Create an object of subclass and use it: ```cpp local node = SubNode.new() node:addSprite(\"xxx.jpg\") ``` Note: `new` is implemented by default in the `class` function. Since the type of the second parameter is `function`, when we call `new`, this is what happens: ```cpp function SubNode.new(...) local instance = cc.Node:create() -- copy fields from SubNode to native object for k,v in pairs(SubNode) do instance[k] = v end instance.class = SubNode instance:ctor(...) return instance end ``` The object created by `new` have all the properties and behaviors of the `cc.Node` object. It also has the properties of the `SubNode` as it is derived from `cc.Node`: ```cpp function SubNode:setPostion(x,y) print(string.format(\"x = %0.2f, y = %0.2f\"), x, y) end ``` If we still need to call the function of the same name of super class: ```cpp getmetatable(SubNode):setPosition(x, y) ``` - The override functions of inherited class in lua can't be called in the c++. ## Memory Management Cocos2d-x v3.x uses the memory management and garbage collection of lua itself except the release of `userdata`. If the corresponding classes are derived from `Ref` the release of `userdata` is managed in c++ by the register table named `toluafix_refid_ptr_mapping` and `tolua_value_root`. ### Simple Test Case 1. Create a `Sprite` in the head of `createDog` function ```cpp local testSprite = cc.Sprite:create(\"res/land.png\") ``` 2. Then call the `Sprite` in the `tick` function as follow: ```cpp testSprite:getPosition() ``` 3. After a period of time, we will see the error message as follows: ```cpp cocos2d: [LUA-print] stack traceback: [string \"src/hello.lua\"]:13: in function [C]: in function 'getPosition' [string \"src/hello.lua\"]:98: in function cocos2d: [LUA-print] ---------------------------------------- cocos2d: [LUA-print] ---------------------------------------- cocos2d: [LUA-print] LUA ERROR: [string \"src/hello.lua\"]:98: invalid 'self' in function 'tolua_cocos2d_Node_getPosition' ``` This error is triggered because the _testsprite_ didn't add any other node as a child after creation. The corresponding c++ object was released at the end of the frame. ### Memory Management for Class Object #### The Class Members of Ref Class for Memory Management In `CCRef.h` we see the usage of `CC_ENABLE_SCRIPT_BINDING`: ```cpp #if CC_ENABLE_SCRIPT_BINDING public: /// object id, ScriptSupport need public _ID unsigned int _ID; /// Lua reference id int _luaID; /// scriptObject, support for swift void* _scriptObject; #endif ``` Notice `_ID` and `_luaID`, are very important when you push a `Ref` object to lua by calling `toluafix_pushusertype_ccobject` to store a key-value table named `toluafix_refid_ptr_mapping` in the registry. The `_ID` is key and the related c++ object pointer is value. The related code fragment in the `toluafix_pushusertype_ccobject` is: ```cpp //Extract from `toluafix_pushusertype_ccobject` in the tolua_fix.cpp lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushlightuserdata(L, vPtr); /* stack: refid_ptr refid ptr */ lua_rawset(L, -3); /* refid_ptr[refid] = ptr, stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ ``` Notes: - `TOLUA_REFID_PTR_MAPPING` is macro definition represent for \"toluafix_refid_ptr_mapping\" - `LUA_REGISTRYINDEX` is definition of `Pseudo-Index` for registry of Lua - `refid` is value of `_ID` - `vPtr` is value of related c++ object pointer #### Create a Ref object from Lua - Call the `cocos2d::Sprite::create(\"res/land.png\")` by lua bindings to create a Sprite object and push it into lua stack: ```cpp //Extract from `lua_cocos2dx_Sprite_create` in lua_cocos2dx_auto.cpp std::string arg0; ok &= luaval_to_std_string(tolua_S, 2,&arg0, \"cc.Sprite:create\"); if (!ok) { break; } cocos2d::Sprite* ret = cocos2d::Sprite::create(arg0); object_to_luaval(tolua_S, \"cc.Sprite\",(cocos2d::Sprite*)ret); return 1; ``` - Call `toluafix_pushusertype_ccobject` when push created object to lua stack ```cpp //Extract from `object_to_luaval` in luaBasicConversions.h if (std::is_base_of::value) { // use c style cast, T may not polymorphic cocos2d::Ref* dynObject = (cocos2d::Ref*)(ret); int ID = (int)(dynObject->_ID) ; int* luaID = &(dynObject->_luaID); toluafix_pushusertype_ccobject(L,ID, luaID, (void*)ret,type); } ``` In the `toluafix_pushusertype_ccobject` , we will use two tables named \"toluafix_refid_ptr_mapping\" and \"toluafix_refid_type_mapping\" in lua's registry to store the two key-value pairs about `_ID`-`object pointer` and `_ID`-`object type name`.The details are as follow: ```cpp //Extract from `toluafix_pushusertype_ccobject` in the tolua_fix.cpp if (*p_refid == 0) { *p_refid = refid; lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushlightuserdata(L, vPtr); /* stack: refid_ptr refid ptr */ lua_rawset(L, -3); /* refid_ptr[refid] = ptr, stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ lua_pushstring(L, TOLUA_REFID_TYPE_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_type */ lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_pushstring(L, vType); /* stack: refid_type refid type */ lua_rawset(L, -3); /* refid_type[refid] = type, stack: refid_type */ lua_pop(L, 1); /* stack: - */ //printf(\"[LUA] push CCObject OK - refid: %d, ptr: %x, type: %s\\n\", //*p_refid, (int)ptr, type); } ``` - Call `tolua_pushusertype_internal` to determine whether to create a new userdata, or just update the userdata. ```cpp void tolua_pushusertype_internal (lua_State* L, void* value, const char* type, int addToRoot) { if (value == NULL) lua_pushnil(L); else { luaL_getmetatable(L, type); /* stack: mt */ if (lua_isnil(L, -1)) { /* NOT FOUND metatable */ lua_pop(L, 1); return; } lua_pushstring(L,\"tolua_ubox\"); lua_rawget(L,-2); /* stack: mt ubox */ if (lua_isnil(L, -1)) { lua_pop(L, 1); lua_pushstring(L, \"tolua_ubox\"); lua_rawget(L, LUA_REGISTRYINDEX); }; lua_pushlightuserdata(L,value); /* stack: mt ubox key */ lua_rawget(L,-2); /* stack: mt ubox ubox[value] */ if (lua_isnil(L,-1)) { lua_pop(L,1); /* stack: mt ubox */ lua_pushlightuserdata(L,value); *(void**)lua_newuserdata(L,sizeof(void *)) = value; /* stack: mt ubox value newud */ lua_pushvalue(L,-1); /* stack: mt ubox value newud newud */ lua_insert(L,-4); /* stack: mt newud ubox value newud */ lua_rawset(L,-3); /* ubox[value] = newud, stack: mt newud ubox */ lua_pop(L,1); /* stack: mt newud */ /*luaL_getmetatable(L,type);*/ lua_pushvalue(L, -2); /* stack: mt newud mt */ lua_setmetatable(L,-2); /* update mt, stack: mt newud */ # ifdef LUA_VERSION_NUM lua_pushvalue(L, TOLUA_NOPEER); /* stack: mt newud peer */ lua_setfenv(L, -2); /* stack: mt newud */ #endif } else { /* check the need of updating the metatable to a more specialized class */ lua_insert(L,-2); /* stack: mt ubox[u] ubox */ lua_pop(L,1); /* stack: mt ubox[u] */ lua_pushstring(L,\"tolua_super\"); lua_rawget(L,LUA_REGISTRYINDEX); /* stack: mt ubox[u] super */ lua_getmetatable(L,-2); /* stack: mt ubox[u] super mt */ lua_rawget(L,-2); /* stack: mt ubox[u] super super[mt] */ if (lua_istable(L,-1)) { lua_pushstring(L,type); /* stack: mt ubox[u] super super[mt] type */ lua_rawget(L,-2); /* stack: mt ubox[u] super super[mt] flag */ if (lua_toboolean(L,-1) == 1) /* if true */ { lua_pop(L,3); /* mt ubox[u]*/ lua_remove(L, -2); return; } } /* type represents a more specilized type */ /*luaL_getmetatable(L,type);// stack: mt ubox[u] super super[mt] flag mt */ lua_pushvalue(L, -5); /* stack: mt ubox[u] super super[mt] flag mt */ lua_setmetatable(L,-5); /* stack: mt ubox[u] super super[mt] flag */ lua_pop(L,3); /* stack: mt ubox[u] */ } lua_remove(L, -2); /* stack: ubox[u]*/ if (0 != addToRoot) { lua_pushvalue(L, -1); tolua_add_value_to_root(L, value); } } } ``` We use a table named `ubox` to store key-value pairs about `userdata` and `object pointer`. This table would be used in the destruction of the object. - Call `tolua_add_value_to_root` to add a reference count for `userdata` in lua by the `tolua_value_root` table in lua registry. The mechanism will make the object in lua wouldn't collected by lua gc. Example: ```cpp local node = cc.Node:create() node.extendValue = 10000 nodeParent:addChild(node, 0 , 9999) ``` This code creates a `node` object and extends the attributes of the node object dynamically by lua's feature. When we want to get this node and its extended attribute somewhere, we can do as follows: ```cpp local child = lnodeParent:getChildByTag(9999) print(child.extendValue) ``` If we don't call the `tolua_add_value_to_root`, the result of `print(child.extendValue)` would be uncertain. Sometimes the result would be 10000 and sometimes it would be `nil`. This is because we wouldn't control lua's automatic gc effectively. When lua gc thinks there are no other references for this userdata it will collect this userdata. When we call `getChildByTag` to get a node object, it would create a new userdata and the extended attributes would disapper. We add a reference count for the userdata `tolua_value_root` table in lua registry in the c++ to avoid generating this error. #### The Release of the Userdata When calling the desturctor of `Ref`, it will trigger the release of the userdata. In the destructor of Ref, we can see: ```cpp #if CC_ENABLE_SCRIPT_BINDING // if the object is referenced by Lua engine, remove it if (_luaID) { ScriptEngineManager::getInstance()->getScriptEngine()->removeScriptObjectByObject(this); } ... #endif ``` After we push a c++ object to lua, the related _luaID would be not 0. We now can call `removeScriptObjectByObject` The `removeScriptObjectByObject` called would trigger the call of `toluafix_remove_ccobject_by_refid`, and this function would call some lua c APIs to operate the table like `toluafix_refid_ptr_mapping`, `toluafix_refid_type_mapping` and `tolua_value_root` table in the registry. The specific implementation of `toluafix_remove_ccobject_by_refid` is as follows: ```cpp TOLUA_API int toluafix_remove_ccobject_by_refid(lua_State* L, int refid) { void* ptr = NULL; const char* type = NULL; void** ud = NULL; if (refid == 0) return -1; // get ptr from tolua_refid_ptr_mapping lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_rawget(L, -2); /* stack: refid_ptr ptr */ ptr = lua_touserdata(L, -1); lua_pop(L, 1); /* stack: refid_ptr */ if (ptr == NULL) { lua_pop(L, 1); // Lua stack has closed, C++ object not in Lua. // printf(\"[LUA ERROR] remove CCObject with NULL ptr, refid: %d\\n\", refid); return -2; } // remove ptr from tolua_refid_ptr_mapping lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushnil(L); /* stack: refid_ptr refid nil */ lua_rawset(L, -3); /* delete refid_ptr[refid], stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ // get type from tolua_refid_type_mapping lua_pushstring(L, TOLUA_REFID_TYPE_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_type */ lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_rawget(L, -2); /* stack: refid_type type */ if (lua_isnil(L, -1)) { lua_pop(L, 2); printf(\"[LUA ERROR] remove CCObject with NULL type, refid: %d, ptr: %p\\n\", refid, ptr); return -1; } type = lua_tostring(L, -1); lua_pop(L, 1); /* stack: refid_type */ // remove type from tolua_refid_type_mapping lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_pushnil(L); /* stack: refid_type refid nil */ lua_rawset(L, -3); /* delete refid_type[refid], stack: refid_type */ lua_pop(L, 1); /* stack: - */ // get ubox luaL_getmetatable(L, type); /* stack: mt */ lua_pushstring(L, \"tolua_ubox\"); /* stack: mt key */ lua_rawget(L, -2); /* stack: mt ubox */ if (lua_isnil(L, -1)) { // use global ubox lua_pop(L, 1); /* stack: mt */ lua_pushstring(L, \"tolua_ubox\"); /* stack: mt key */ lua_rawget(L, LUA_REGISTRYINDEX); /* stack: mt ubox */ }; // cleanup root tolua_remove_value_from_root(L, ptr); lua_pushlightuserdata(L, ptr); /* stack: mt ubox ptr */ lua_rawget(L,-2); /* stack: mt ubox ud */ if (lua_isnil(L, -1)) { // Lua object has released (GC), C++ object not in ubox. //printf(\"[LUA ERROR] remove CCObject with NULL ubox, refid: %d, ptr: %x, type: %s\\n\", refid, (int)ptr, type); lua_pop(L, 3); return -3; } // cleanup peertable lua_pushvalue(L, LUA_REGISTRYINDEX); lua_setfenv(L, -2); ud = (void**)lua_touserdata(L, -1); lua_pop(L, 1); /* stack: mt ubox */ if (ud == NULL) { printf(\"[LUA ERROR] remove CCObject with NULL userdata, refid: %d, ptr: %p, type: %s\\n\", refid, ptr, type); lua_pop(L, 2); return -1; } // clean userdata *ud = NULL; lua_pushlightuserdata(L, ptr); /* stack: mt ubox ptr */ lua_pushnil(L); /* stack: mt ubox ptr nil */ lua_rawset(L, -3); /* ubox[ptr] = nil, stack: mt ubox */ lua_pop(L, 2); //printf(\"[LUA] remove CCObject, refid: %d, ptr: %x, type: %s\\n\", refid, (int)ptr, type); return 0; } ``` The steps are as follows: - Get related object pointer stored in the `toluafix_refid_ptr_mapping` table by the value of `_luaID`. Store it. - Remove reference relationship of the object pointer from `toluafix_refid_ptr_mapping` table by `_luID` - Get related type name stored in the `tolua_refid_type_mapping` table by the value of `_luaID`,then store it - Remove reference relationship of type name from `tolua_refid_type_mapping` table by `_luID` - Get the related metatable by the type name - Get the `ubox` table - Remove reference relationship of userdata from `tolua_value_root` table by the object pointer got in the upper step - Clean userdata and remove reference relationship of userdata from `ubox` by the object pointer got in the upper step.Note:To destroy an object cited by lua, we only called '*ud = NULL;' Through the above steps,the refernce relationships in the `toluafix_refid_ptr_mapping`,`tolua_refid_type_mapping` and `tolua_refid_type_mapping` table in the registry would be removed, release the `userdata` which is created when push c++ object to lua stack, and when lua gc trigger, the related object would be collected if there is no other place refer to it. ### Memory Management for Lua Callback Function Cocos2dx have been used `toluafix_refid_function_mapping` table in the registry to manage the gc of lua callback function #### Add a reference for Lua Callback Function When we define a lua function which would be called throuch c++ codes, we whould store the pointer of this function in the `toluafix_refid_function_mapping` table by calling `toluafix_ref_function` function in the `tolua_fix.cpp`.Cocos2d-x bound a series of functions like `registerScriptHandler` and `addEventListener` to finish this work. Let's use `registerScriptHandler` of `Node` as a sample,we could use it as follows in lua: ``` local function onNodeEvent(event) if \"enter\" == event then --do something end end nodeObject:registerScriptHandler(onNodeEvent) ``` The related bindings function is named `tolua_cocos2d_Node_registerScriptHandler` in the `lua_cocos2dx_manual.cpp`,the most important sections are as follows: ``` LUA_FUNCTION handler = toluafix_ref_function(tolua_S,2,0); ScriptHandlerMgr::getInstance()->addObjectHandler((void*)self, handler, ScriptHandlerMgr::HandlerType::NODE); ``` - `toluafix_ref_function` is implemented to store the related function pointer into `toluafix_refid_function_mapping` table in the registry with a static variable named `s_function_ref_id`.This operation makes lua function avoid being collected by lua gc because that `toluafix_refid_function_mapping` table have a reference of this function. The details are as follow: ``` TOLUA_API int toluafix_ref_function(lua_State* L, int lo, int def) { // function at lo if (!lua_isfunction(L, lo)) return 0; s_function_ref_id++; lua_pushstring(L, TOLUA_REFID_FUNCTION_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: fun ... refid_fun */ lua_pushinteger(L, s_function_ref_id); /* stack: fun ... refid_fun refid */ lua_pushvalue(L, lo); /* stack: fun ... refid_fun refid fun */ lua_rawset(L, -3); /* refid_fun[refid] = fun, stack: fun ... refid_ptr */ lua_pop(L, 1); /* stack: fun ... */ return s_function_ref_id; } ``` - `addObjectHandler` is used to stored the map of object pointer and pair of `s_function_ref_id` and handler type. #### Remove a reference for Lua Callback Function If lua callback function become useless, we should remove the reference in the `toluafix_refid_function_mapping` table in the registry. Cocos2d-x provided the `toluafix_remove_function_by_refid` function to realize it. This function could be called by `removeScriptHandler` of `LuaStack`,`removeScriptHandler` of `LuaEngine` or directly. The details are as follows: ``` TOLUA_API void toluafix_remove_function_by_refid(lua_State* L, int refid) { lua_pushstring(L, TOLUA_REFID_FUNCTION_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: ... refid_fun */ lua_pushinteger(L, refid); /* stack: ... refid_fun refid */ lua_pushnil(L); /* stack: ... refid_fun refid nil */ lua_rawset(L, -3); /* refid_fun[refid] = nil, stack: ... refid_fun */ lua_pop(L, 1); /* stack: ... */ } ``` Note: - `refid` is the corresponding value of `s_function_ref_id`. - For Ref object,we would call `ScriptHandlerMgr::getInstance()->removeObjectAllHandlers` to remove all the reference function relationship which added by the `ScriptHandlerMgr::getInstance()->addObjectHandler` automatically - Because Cocos2d-x v3.x support the features of c++ 11, we can call the related remove function through the lambda function. For example: ``` //Extract from `lua_cocos2dx_TextureCache_addImageAsync` in lua_cocos2dx_manual.cpp LUA_FUNCTION handler = ( toluafix_ref_function(tolua_S, 3, 0)); self->addImageAsync(configFilePath, [=](Texture2D* tex){ int ID = (tex) ? (int)tex->_ID : -1; int* luaID = (tex) ? &tex->_luaID : nullptr; toluafix_pushusertype_ccobject(tolua_S, ID, luaID, (void*)tex, \"cc.Texture2D\"); LuaEngine::getInstance()->getLuaStack()->executeFunctionByHandler(handler,1); LuaEngine::getInstance()->removeScriptHandler(handler); }); ``` By the mechanism of the lambda, we could get the value of handler which represents the corresponding value of `s_function_ref_id`. When we finish calling lua callback function,we could call `LuaEngine::getInstance()->removeScriptHandler(handler)` directly to remove the reference of lua callback function. ## Use Cocos Code IDE to Debug a Lua Game Cocos Code IDE is tool that can debug a lua script,it has windows and mac version. You can debug Windows and Android lua games through the windows version and you can debug Mac, iOS and android lua games through the Mac version. Now we will demonstrate how to use Cocos Code IDE to debug a lua game based on the mac version. The process of the windows version is almost the same. ## Prerequisite If you have been not installed the Cocos Code IDE,you can refer to [Cocos Code IDE Installation](https://cocos2d-x.org/wiki/Cocos_Code_IDE). ## Cocos Code IDE Configuration ### Basic Settings Click `Cocos Code IDE/Preferences` to open the configuration dialog,then select the `Cocos/Lua` to set the directory of Cocos2d-x v3.x in the `Lua Frameworks`: ![](10-img/lua_cocos_preferences.png) ### Additional Settings You should set directory of some compliling tools about android if you need to replace the Android runtime which Cocos Code IDE provided. Click `Cocos Code IDE/Preferences` then pitch on `Cocos` to configurate the directory of related tools: ![](10-img/cocos_preferences.png) ## Debug a Lua Game 1. Create a new Cocos Lua Project by the right click menu in the `Lua Projects Explorer` ![](10-img/lua_create_project.png) 2. Select `src/GameScene.lua` and open it,then toggle breakpoint by right click menu or double click ![](10-img/lua_toggle_breakpoint.png) 3.Click debug button on toolbar ![](10-img/lua_debug_button.png) 4.Trigger the breakpoint,select \"Yes\" to open `Debug Perspective`,and you will find many useful debug views like `Call stacks`, `Variables` and `Breakpoints`,etc. ![](10-img/lua_confirm_perspective.png) ![](10-img/lua_debug_dialog.png) 5.Use `Step over`, `Step into`, `Step out` in the tool bar to debug ![](10-img/lua_step_debug.png) ## Code Hot Updating when Debugging We could realize the hot updating of lua code when debugging by the Cocos Code IDE. If you want to change the moving path of dog int the src/GameScene.lua, you can modify the \"tick()\" function to control the dog's position ``` local function tick() if spriteDog.isPaused then return end local x, y = spriteDog:getPosition() if x > self.origin.x + self.visibleSize.width then x = self.origin.x else x = x + 1 end spriteDog:setPositionX(x) end ``` Modify the implementation of function, for example, change the value 1 to 10 and save your change. Then you will find that you have improved the speed of SpriteDog without restarting the app! ## How to Debug on the Other Target Platforms The above example is executed on the Mac platform because of the default configuration of Cocos Code IDE.If you debug on the other target platforms you should modify `Debug Configurations`. 1. Click `Debug Configurations` button on the toolbar to open `Debug Configurations` dialog ![](10-img/lua_config_button.png) 2. Select the `CocosLuaGame` item,then to configure ![](10-img/lua_debug_configure_dialog.png) ### Debug on the iOS Simulator 1. Check iOS Simulator radio button 2. Choose a runtime app 3. Click the Debug button,IDE will auto-install chosen runtime app and start runtime to debug ![](10-img/lua_configure_iOS_simulator.png) ### Debug on an iOS Device 1.You need a runtime IPA, you can build a custom runtime IPA by Cocos Code IDE, then [install runtime IPA](//www.solutionanalysts.com/blog/how-install-ipa-file-iphone-ipod-ipad-using-itunes-mac-windows) to iOS device. - Click `Build Runtime` on the toolbars ![](10-img/lua_configure_build_runtime.png) - Click `Yes` button on the pop-up `Cocos` dialog ![](10-img/lua_configure_build_runtime_first.png) - Click `Generate` button to Generate `Create Native Source Wizard` ![](10-img/lua_configure_creat_native_source_wizard.png) - Click `Close` button to finish `Create Native Source Wizard` ![](10-img/lua_configure_finish_create_native_source_wizard.png) - Click `Build Runtime` on the toolbars to open `Runtime Builder Wizard` dialog ![](10-img/lua_configure_runtime_builder_wizard.png) - Check `Build iOS Device Runtime` and click `Generate` button to generate ![](10-img/lua_configure_runtime_select_iOS_device.png) - Click `Close` button when Finished dialog pop up ![](10-img/lua_configure_finish_iOS_device.png) 2. Click `Debug Configuration`,then check `Remote Debug` radio button on the `Debug Configuration` dialog 3. Select `iOS` platform 4. Fill IP address of your device into the `Target IP` and Fill the IP address that your PC used on the `Host IP`(Make sure that the `Target IP` and `Host IP` can access each other) 5. Click 'Debug' button to begin to debug ![](10-img/lua_iOS_device_remote_setting.png) ### Debug on Android Device by ADB Mode 1. Prebuild Runtimelua.apk by `Build Runtime` like first of `Debug on the iOS Device` 2. Check `Android ADB Mode` radio button 3. Choose a runtime apk 4. Click the `Debug` button 5. IDE will auto-install the chosen runtime apk and start to debug ![](10-img/lua_debug_android_adb_mode.png) ### Debug on Android Device by WLAN 1. Install runtime apk to your device manually. It is placed in CocosLuaGame/runtime/android. 2. Start runtime on device manually 3. Click `Debug Configuration`,then check `Remote Debug` radio button on the `Debug Configuration` dialog 4. Fill IP address of your device into the `Target IP` and Fill the IP address that your PC used on the `Host IP`(Make sure that the `Target IP` and `Host IP` can access each other) 5. Click 'Debug' button to begin to debug ![](10-img/lua_anroid_device_remote_setting.png) --> "},"physics/":{"url":"physics/","title":"Physics","keywords":"","body":"Physics Your game is coming along nicely. You have Sprite objects, gameplay mechanics and your coding efforts are paying off. You are starting to feel like your game is playable. What do you do when you realize your game needs to simulate real world situations? You know, collision detection, gravity, elasticity and friction. Yes, you guessed it! This chapter is on physics and the use of a physics engine. Let's explore the when, wheres and whys of using a physics engine. "},"physics/getting_started.html":{"url":"physics/getting_started.html","title":"Physics is scary!","keywords":"","body":"Physics is scary, do I really need it? Please tell me no! Please don't run away there are no physics monsters under your bed! Your needs might be simple enough to not need to use a physics engine. Perhaps a combination of using a Node objects update() function, Rect objects and a combination of the containsPoint() or intersectsRect() functions might be enough for you? Example: void update(float dt) { auto p = touch->getLocation(); auto rect = this->getBoundingBox(); if(rect.containsPoint(p)) { // do something, intersection } } This mechanism works for very simple needs, but doesn't scale. What if you had 100 Sprite objects all continuously updating to check for intersections with other objects? It could be done but the the CPU usage and framerate would suffer severely. Your game would be unplayable. A physics engine solves these concerns for us in a scalable and CPU friendly way. Even though this might look foreign, let's take a look at a simple example and then nut and bolt the example, terminology and best practice together. // create a static PhysicsBody auto physicsBody = PhysicsBody::createBox(Size(65.0f , 81.0f ), PhysicsMaterial(0.1f, 1.0f, 0.0f)); physicsBody->setDynamic(false); // create a sprite auto sprite = Sprite::create(\"whiteSprite.png\"); sprite->setPosition(Vec2(400, 400)); // sprite will use physicsBody sprite->addComponent(physicsBody); //add contact event listener auto contactListener = EventListenerPhysicsContact::create(); contactListener->onContactBegin = CC_CALLBACK_1(onContactBegin, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(contactListener, this); Even though this example is simple, it looks complicated and scary. It really isn't if we look closely. Here are the steps that are happening: A PhysicsBody object is created. A Sprite object is created. The Sprite object applies the properties of the PhysicsBody object. A listener is created to respond to an onContactBegin() event. Once we look step by step the concept starts to make sense. "},"physics/concepts.html":{"url":"physics/concepts.html","title":"Terminology and concepts","keywords":"","body":"Physics terminology and concepts To better understand all the details of a physics engine you should understand the following terms and concepts: Bodies A PhysicsBody holds the physical properties of an object. These include mass, position, rotation, velocity and damping. PhysicsBody objects are the backbone for shapes. A PhysicsBody does not have a shape until you attach a shape to it. Material Materials describe material attributes: -density: It is used to compute the mass properties of the parent body. -restitution: It is used to make objects bounce. The restitution value is usually set to be between 0 and 1. 0 means no bouncing while 1 means perfect bouncing. -friction: It is used to make objects slide along each other realistically. Shapes Shapes describe collision geometry. By attaching shapes to bodies, you define a body’s shape. You can attach as many shapes to a single body as you need in order to define a complex shape. Each shape relates to a PhysicsMaterial object and contains the following attributes: type, area, mass, moment, offset and tag. Some of these you might not be familiar with: -type: describes the categories of shapes, such as circle, box, polygon, etc. -area: used to compute the mass properties of the body. The density and area gives the mass. -mass: the quantity of matter that a body contains, as measured by its acceleration under a given force or by the force exerted on it by a gravitational field. -moment: determines the torque needed for a desired angular acceleration. -offset: offset from the body’s center of gravity in body local coordinates. -tag: used to identify the shape easily for developers.​ You probably remember that you can assign all Node objects a tag for identification and easy access. We describe the various shapes as: -PhysicsShape: Shapes implement the PhysicsShape base class. -PhysicsShapeCircle: Circles are solid. You cannot make a hollow circle using the circle shape. -PhysicsShapePolygon: Polygon shapes are solid convex polygons. -PhysicsShapeBox: Box shape is one kind of convex polygon. -PhysicsShapeEdgeSegment: A segment shape. -PhysicsShapeEdgePolygon: Hollow polygon shapes. A edge-polygon shape consists of multiple segment shapes. -PhysicsShapeEdgeBox: Hollow box shapes. A edge-box shape consists of four segment shapes. -PhysicsShapeEdgeChain: The chain shape provides an efficient way to connect many edges together. Contacts/Joints Contacts and joint objects describe how bodies are attached to each other. World A world container is what your physics bodies are added to and where they are simulated. You add bodies, shapes and constraints to a world and then update the world as a whole. The world controls how all of these items interact together. Much of the interaction with the physics API will be with a PhysicsWorld object. There is a lot to remember here, keep these terms handy to refer back to them as needed. Physics World and Physics Body PhysicsWorld A PhysicsWorld object is the core item used when simulating physics. Just like the world we live in, a PhysicsWorld has a lot of things happening at once. PhysicsWorld integrates deeply at the Scene level because of it's many facets. Let's use a simple example that we can all relate to. Does your residence have a kitchen? Think of this as your physics world! Now your world has PhysicsBody objects, like food, knives, appliances! These bodies interact with each other inside the world. These objects touch and also react to those touches. Example: use a knife to cut food and put it in an appliance. Does the knife cut the food? Maybe. Maybe not. Perhaps it isn't the correct type of knife for the job. You can create a Scene that contains a PhysicsWorld just by calling the function initWithPhysics() in your Scene. Your init() function should have: if( !Scene::initWithPhysics() ) { } Every PhysicsWorld has properties associated with it: -gravity: Global gravity applied to the world. Defaults to Vec2(0.0f, -98.0f). -speed: Set the speed of physics world, speed is the rate at which the simulation executes. Defaults to 1.0. -updateRate: set the update rate of physics world, update rate is the value of EngineUpdateTimes/PhysicsWorldUpdateTimes. -substeps: set the number of substeps in an update of the physics world. The process of updating a PhysicsWorld is called stepping. By default, the PhysicsWorld updates through time automatically. This is called auto stepping. It automatically happens for you, each frame. You can disable auto steping of the PhysicsWorld by setting setAutoStep(false). If you do this, you would step the PhysicsWorld manually by setting step(time). Substeps are used to step the PhysicsWorld forward multiple times using a more precise time increment than a single frame. This allows for finer grained control of the stepping process including more fluid movements. PhysicsBody PhysicsBody objects have position and velocity. You can apply forces, movement, damping and impulses (as well as more) to PhysicsBody objects. PhysicsBody can be static or dynamic. A static body does not move under simulation and behaves as if it has infinite mass. A dynamic body is fully simulated. They can be moved manually by the user, but normally they move according to forces. A dynamic body can collide with all body types. Node provides setPhysicsBody() to associate a PhysicsBody to a Node object. Lets create a static and 5 dynamic PhysicsBody objects that are a box shape: auto visibleSize = Director::getInstance()->getVisibleSize(); s_centre = Vec2(visibleSize.width/2, visibleSize.height/2); auto physicsBody = PhysicsBody::createBox(Size(65.0f, 81.0f), PhysicsMaterial(0.1f, 1.0f, 0.0f)); physicsBody->setDynamic(false); //create a sprite auto sprite = Sprite::create(\"whiteSprite.png\"); sprite->setPosition(s_centre); addChild(sprite); //apply physicsBody to the sprite sprite->addComponent(physicsBody); //add five dynamic bodies for (int i = 0; i setGravityEnable(false); //set initial velocity of physicsBody physicsBody->setVelocity(Vec2(cocos2d::random(-500,500), cocos2d::random(-500,500))); physicsBody->setTag(10); sprite = Sprite::create(\"blueSprite.png\"); sprite->setPosition(Vec2(s_centre.x + cocos2d::random(-300,300), s_centre.y + cocos2d::random(-300,300))); sprite->addComponent(physicsBody); addChild(sprite); } The result is a stationary PhysicsBody with 5 additional PhysicsBody objects colliding around it. "},"physics/collisions.html":{"url":"physics/collisions.html","title":"Collision","keywords":"","body":"Collision Have you ever been in a car accident? What did you collide with? Just like with cars, PhysicBody objects can come in contact. Collisions are what happens when PhysicBody objects come in contact with each other. When a collision takes place it can be ignored or it can trigger events to be fired. Filtering Collisions Collision filtering allows you to enable or prevent collisions between shapes. This physics engine supports collision filtering using category and group bitmasks. There are 32 supported collision categories. For each shape you can specify which category it belongs to. You can also specify what other categories this shape can collide with. This is done with masking bits. For example: auto visibleSize = Director::getInstance()->getVisibleSize(); s_centre = Vec2(visibleSize.width/2, visibleSize.height/2); auto sprite1 = addSpriteAtPosition(Vec2(s_centre.x - 150,s_centre.y)); sprite1->getPhysicsBody()->setCategoryBitmask(0x02); // 0010 sprite1->getPhysicsBody()->setCollisionBitmask(0x01); // 0001 sprite1 = addSpriteAtPosition(Vec2(s_centre.x - 150,s_centre.y + 100)); sprite1->getPhysicsBody()->setCategoryBitmask(0x02); // 0010 sprite1->getPhysicsBody()->setCollisionBitmask(0x01); // 0001 auto sprite2 = addSpriteAtPosition(Vec2(s_centre.x + 150,s_centre.y),1); sprite2->getPhysicsBody()->setCategoryBitmask(0x01); // 0001 sprite2->getPhysicsBody()->setCollisionBitmask(0x02); // 0010 auto sprite3 = addSpriteAtPosition(Vec2(s_centre.x + 150,s_centre.y + 100),2); sprite3->getPhysicsBody()->setCategoryBitmask(0x03); // 0011 sprite3->getPhysicsBody()->setCollisionBitmask(0x03); // 0011 You can check for collisions by checking and comparing category and collision bitmasks like: if ((shapeA->getCategoryBitmask() & shapeB->getCollisionBitmask()) == 0 || (shapeB->getCategoryBitmask() & shapeA->getCollisionBitmask()) == 0) { // shapes can't collide ret = false; } Collision groups let you specify an integral group index. You can have all shapes with the same group index always collide (positive index) or never collide (negative index and zero index). Collisions between shapes of different group indices are filtered according the category and mask bits. In other words, group filtering has higher precedence than category filtering. Contacts/Joints Recall from the terminology above that joints are how contact points are connected to each other. Yes, you can think of it just like joints on your own body. Each joint type has a definition that derives from PhysicsJoint. All joints are connected between two different bodies. One body may be static. You can prevent the attached bodies from colliding with each other by joint->setCollisionEnable(false). Many joint definitions require that you provide some geometric data. Often a joint will be defined by anchor points. The rest of the joint definition data depends on the joint type. -PhysicsJointFixed: A fixed joint fuses the two bodies together at a reference point. Fixed joints are useful for creating complex shapes that can be broken apart later. -PhysicsJointLimit: A limit joint imposes a maximum distance between the two bodies, as if they were connected by a rope. -PhysicsJointPin: A pin joint allows the two bodies to independently rotate around the anchor point as if pinned together. -PhysicsJointDistance: Set the fixed distance with two bodies -PhysicsJointSpring: Connecting two physics bodies together with a spring -PhysicsJointGroove: Attach body a to a line, and attach body b to a dot -PhysicsJointRotarySpring: Likes a spring joint, but works with rotary -PhysicsJointRotaryLimit: Likes a limit joint, but works with rotary -PhysicsJointRatchet: Works like a socket wrench -PhysicsJointGear: Keeps the angular velocity ratio of a pair of bodies constant -PhysicsJointMotor: Keeps the relative angular velocity of a pair of bodies constant Collision detection Contacts are objects created by the physics engine to manage the collision between two shapes. Contact objects are not created by the user, they are created automatically. There are a few terms associated with contacts. -contact point: A contact point is a point where two shapes touch. -contact normal: A contact normal is a unit vector that points from one shape to another. You can get the PhysicsShape from a contact. From those you can get the bodies. bool onContactBegin(PhysicsContact& contact) { auto bodyA = contact.getShapeA()->getBody(); auto bodyB = contact.getShapeB()->getBody(); return true; } You can get access to contacts by implementing a contact listener. The contact listener supports several events: begin, pre-solve, post-solve and separate. -begin: Two shapes just started touching for the first time this step. Return true from the callback to process the collision normally or false to cause physics engine to ignore the collision entirely. If you return false, the preSolve() and postSolve() callbacks will never be run, but you will still receive a separate event when the shapes stop overlapping. -pre-solve: Two shapes are touching during this step. Return false from the callback to make physics engine ignore the collision this step or true to process it normally. Additionally, you may override collision values using setRestitution(), setFriction() or setSurfaceVelocity() to provide custom restitution, friction, or surface velocity values. -post-solve: Two shapes are touching and their collision response has been processed. -separate: Two shapes have just stopped touching for the first time this step. You also can use EventListenerPhysicsContactWithBodies, EventListenerPhysicsContactWithShapes, EventListenerPhysicsContactWithGroup to listen for the event you're interested with bodies, shapes or groups. Besides this you also need to set the physics contact related bitmask value, as the contact event won't be received by default, even if you create the relative EventListener. For example: bool init() { auto visibleSize = Director::getInstance()->getVisibleSize(); s_centre = Vec2(visibleSize.width/2, visibleSize.height/2); //create a static PhysicsBody auto sprite = addSpriteAtPosition(s_centre, 1); sprite->setTag(10); sprite->getPhysicsBody()->setContactTestBitmask(0xFFFFFFFF); sprite->getPhysicsBody()->setDynamic(false); //adds contact event listener auto contactListener = EventListenerPhysicsContact::create(); contactListener->onContactBegin = CC_CALLBACK_1(PhysicsDemoCollisionProcessing::onContactBegin, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(contactListener, this); schedule(CC_SCHEDULE_SELECTOR(PhysicsDemoCollisionProcessing::tick), 0.3f); return true; return false; } void tick(float dt) { auto sprite1 = addSpriteAtPosition(Vec2(s_centre.x + cocos2d::random(-300,300), s_centre.y + cocos2d::random(-300,300))); auto physicsBody = sprite1->getPhysicsBody(); physicsBody->setVelocity(Vec2(cocos2d::random(-500,500),cocos2d::random(-500,500))); physicsBody->setContactTestBitmask(0xFFFFFFFF); } bool onContactBegin(PhysicsContact& contact) { auto nodeA = contact.getShapeA()->getBody()->getNode(); auto nodeB = contact.getShapeB()->getBody()->getNode(); if (nodeA && nodeB) { if (nodeA->getTag() == 10) { nodeB->removeFromParentAndCleanup(true); } else if (nodeB->getTag() == 10) { nodeA->removeFromParentAndCleanup(true); } } //bodies can collide return true; } "},"physics/queries.html":{"url":"physics/queries.html","title":"Queries","keywords":"","body":"Queries Have you ever stood in one position and looked around? You see things near to you and far from you. You can gauge how close things are to you. Physics engines provide this same type of spatial query. PhysicsWorld objects currently support point queries, ray casts and rect queries. Point Queries When you touch something, say your desk, you can think of this as a point query. Point queries allow you to check if there are shapes within a certain distance of a point. Point queries are useful for things like mouse picking and simple sensors. You can also find the closest point on a shape to a given point or find the closest shape to a point. Ray Cast If you are looking around, some object within your sight is bound to catch your attention. You have essentially performed a ray cast here. You scanned until you found something interesting to make you stop scanning. You can ray cast at a shape to get the point of first intersection. For example: void tick(float dt) { Vec2 d(300 * cosf(_angle), 300 * sinf(_angle)); Vec2 point2 = s_centre + d; if (_drawNode) { removeChild(_drawNode); } _drawNode = DrawNode::create(); Vec2 points[5]; int num = 0; auto func = [&points, &num](PhysicsWorld& world, const PhysicsRayCastInfo& info, void* data)->bool { if (num getPhysicsWorld()->rayCast(func, s_centre, point2, nullptr); _drawNode->drawSegment(s_centre, point2, 1, Color4F::RED); for (int i = 0; i drawDot(points[i], 3, Color4F(1.0f, 1.0f, 1.0f, 1.0f)); } addChild(_drawNode); _angle += 1.5f * (float)M_PI / 180.0f; } Rect Queries Rect queries provide a fast way to check roughly which shapes are in an area. It is pretty easy to implement: auto func = [](PhysicsWorld& world, PhysicsShape& shape, void* userData)->bool { //Return true from the callback to continue rect queries return true; } scene->getPhysicsWorld()->queryRect(func, Rect(0,0,200,200), nullptr); A few examples of using a rect query while doing a logo smash: "},"physics/debugging.html":{"url":"physics/debugging.html","title":"Debugging/Disabling","keywords":"","body":"Debugging Physics Body and Shapes If you ever wish to have red boxes drawn around your physics bodies to aid in debugging, simple add these 2 lines to your core, where it makes sense to you. Perhaps AppDelegate is a good place? You can add the following code: Director::getInstance()->getRunningScene()->getPhysics3DWorld()->setDebugDrawEnable(true); Director::getInstance()->getRunningScene()->setPhysics3DDebugCamera(cameraObjecct); Disabling Physics Using the built-in physics engine is a good idea. It is solid and advanced. However, if you wish to use an alternative physics engine you can. All you need to do is disabling CC_USE_PHYSICS in base/ccConfig.h. "},"audio/":{"url":"audio/","title":"Audio","keywords":"","body":"Audio Your game will surely need sound! Cocos2d-x provides two audio engines. One API called SimpleAudioEngine and a more advanced API called AudioEngine. "},"audio/getting_started.html":{"url":"audio/getting_started.html","title":"Getting Started","keywords":"","body":"Getting Started Your game will surely need sound! Cocos2d-x provides an audio engine called SimpleAudioEngine. It can be used to play background music as well as sound effects through out your game play. SimpleAudioEngine is a shared singleton object so you can simple call it from anywhere in your code. When creating a sample HelloWorld project we do all the setup required for you, out of the box. Supported music formats Platform Supported File Formats Notes Android .mp3, .mid, .ogg, .wav All formats supported by android.media.MediaPlayer can be played iOS .aac, .caf, .mp3, .m4a, .wav All formats supported by AVAudioPlayer can be played Windows .mid, .mp3, .wav none Supported audio formats: Platform Common Supported File Formats Notes Android .ogg, .wav Wav support is not perfect iOS .caf, .m4a Can play all formats supported by Cocos2d-iPhone CocosDesion Windows .mid, .wav none "},"audio/playing.html":{"url":"audio/playing.html","title":"Playing Sound","keywords":"","body":"Play background music Play an audio file for use as background music. This can be repeated continuously. #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // set the background music and continuously play it. audio->playBackgroundMusic(\"mymusic.mp3\", true); // set the background music and play it just once. audio->playBackgroundMusic(\"mymusic.mp3\", false); Play a sound effect. Play a sound effect. #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // play a sound effect, just once. audio->playEffect(\"myEffect.mp3\", false, 1.0f, 1.0f, 1.0f); "},"audio/operations.html":{"url":"audio/operations.html","title":"Manipulating Sound","keywords":"","body":"Pausing, stopping, resuming music and sound effects After you start to play music and sound effects you might need to pause, stop or resume after certain operations. This can be done easily. Pause #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // pause background music. audio->pauseBackgroundMusic(); // pause a sound effect. audio->pauseEffect(); // pause all sound effects. audio->pauseAllEffects(); Stop #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // stop background music. audio->stopBackgroundMusic(); // stop a sound effect. audio->stopEffect(); // stops all running sound effects. audio->stopAllEffects(); Resume #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // resume background music. audio->resumeBackgroundMusic(); // resume a sound effect. audio->resumeEffect(); // resume all sound effects. audio->resumeAllEffects(); "},"audio/advanced.html":{"url":"audio/advanced.html","title":"Advanced Topics","keywords":"","body":"Advanced audio functionality Setup It is easy to get started using the SimpleAudioEngine API. There are considerations to keep in mind when using audio in your game. Mostly when operating on mobile devices such as phones and tablets. What happens when you multi-task on your phone and are switching between apps? Or when a phone call comes in? You need to handle these exceptions in your game. Fortunately, we help you here. In AppDelegate.cpp, notice the following methods: // This function will be called when the app is inactive. When comes a phone call, // it's be invoked too void AppDelegate::applicationDidEnterBackground() { Director::getInstance()->stopAnimation(); // if you use SimpleAudioEngine, it must be pause // SimpleAudioEngine::getInstance()->pauseBackgroundMusic(); } // this function will be called when the app is active again void AppDelegate::applicationWillEnterForeground() { Director::getInstance()->startAnimation(); // if you use SimpleAudioEngine, it must resume here // SimpleAudioEngine::getInstance()->resumeBackgroundMusic(); } Notice the commented out lines for SimpleAudioEngine? Make sure to uncomment these lines out if you are using audio for background sounds and sound effects. Pre-loading sound When your game starts you might want to pre-load the music and effects so they are ready when you need them. #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // pre-loading background music and effects. You could pre-load // effects, perhaps on app startup so they are already loaded // when you want to use them. audio->preloadBackgroundMusic(\"myMusic1.mp3\"); audio->preloadBackgroundMusic(\"myMusic2.mp3\"); audio->preloadEffect(\"myEffect1.mp3\"); audio->preloadEffect(\"myEffect2.mp3\"); // unload a sound from cache. If you are finished with a sound and // you wont use it anymore in your game. unload it to free up // resources. audio->unloadEffect(\"myEffect1.mp3\"); Volume You can increase and decrease the volume of your sounds and music programmatically. #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // setting the volume specifying value as a float audio->setEffectsVolume(0.5); audio->setBackgroundMusicVolume(0.5); "},"audio/engines.html":{"url":"audio/engines.html","title":"Audio Engines Compared","keywords":"","body":"Are your audio needs more advanced? This far we have just talked about SimpleAudioEngine. For most games, SimpleAudioEngine provides all the functionality that they need. If your audio needs move beyond what SimpleAudioEngine can provide, Cocos2d-x also offers a second choice called just AudioEngine. SimpleAudio Engine versus Audio Engine "},"advanced_topics/":{"url":"advanced_topics/","title":"Advanced Topics","keywords":"","body":"Advanced Topics Wow! You are on the last chapter. Good Job! By now you should feel comfortable creating your games with Cocos2d-x. However, please realize there is no limit to what you can create. This chapter covers advanced concepts. Note that this chapter gets more technical in its content and format. "},"advanced_topics/filesystem.html":{"url":"advanced_topics/filesystem.html","title":"File System Access","keywords":"","body":"File System Access Even though you can use functions in stdio.h to access files it can be inconvenient for a few reasons: You need to invoke system specific API to get full path of a file. Resources are packed into .apk file on Android after installing. You want to load a resource (such as a picture) based on resolution automatically. The FileUtils class has been created to resolve these issues. FileUtils is a helper class to access files under the location of your Resources directory. This includes reading data from a file and checking file existence. Functions to read file content These functions will read different type of files and will return different data types: function name return type support path type getStringFromFile std::string relative path and absolute path getDataFromFile cocos2d::Data relative path and absolute path getFileDataFromZip unsigned char* absolute path getValueMapFromFile cocos2d::ValueMap relative path and absolute path getValueVectorFromFile std::string cocos2d::ValueVector Functions to manage files or directories These functions will manage a file or a directory: function name support path type isFileExist relative path and absolute path isDirectoryExist relative path and absolute path createDirectory absolute path removeDirectory absolute path removeFile absolute path renameFile absolute path getFileSize relative path and absolute path "},"advanced_topics/networking.html":{"url":"advanced_topics/networking.html","title":"Networking with HTTP","keywords":"","body":"Networking with HTTP Sometimes it might be helpful to obtain resources or data from another source. One common way of doing this is by using an HTTP request. HTTP networking has three steps: Create an HttpRequest Create a setResponseCallback() callback function for replying to requests. Send HttpRequest by HttpClient HttpRequest can have four types: POST, PUT, DELETE, UNKNOWN. Unless specified the default type is UNKNOWN. The HTTPClient object controls sending the request and receiving the data on a callback. Working with an HTTPRequest is quite simple: HttpRequest* request = new (std :: nothrow) HttpRequest(); request->setUrl(\"//just-make-this-request-failed.com\"); request->setRequestType(HttpRequest::Type::GET); request->setResponseCallback(CC_CALLBACK_2 (HttpClientTest::onHttpRequestCompleted, this)); HttpClient::getInstance()->sendImmediate(request); request->release(); Notice that we specified a setResponseCallback() method for when a response is received. By doing this we can look at the data returned and use it how we might need to. Again, this process is simple and we can do it with ease: void HttpClientTest::onHttpRequestCompleted(HttpClient* sender, HttpResponse* response) { if (!response) { return; } // Dump the data std::vector* buffer = response->getResponseData(); for (unsigned int i = 0; i size (); i ++) { log (\"% c\", (* buffer) [i]); } } "},"advanced_topics/oppo.html":{"url":"advanced_topics/oppo.html","title":"OPPO Optimizations","keywords":"","body":"Optimizations for OPPO devices Note: This document applies to Cocos2d-x 3.17.2 and later only. Cocos2d-x has a few optimizations for OPPO devices. These optimizations will only work on OPPO devices (specially Reno devices). What's optimized There are two places that are optimized: loading a scene engine's internal shaders compiling Loading scene optimizations start when Scene is created, and ended in Scene::onEnter() and therefore you should create resources between them. Invoke optimization codes manually The application knows where more power is needed, better than the engine knows. You can invoke this API to get more power when needed. You can invoke this API in both C++ or Java. Example usage in C++ // Notify device that an event happends, such as start loading a scene. // It is available after v3.17.2. #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::setOptimise(const string&, const string&); #end if // Scene loading starts, need more power. #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onSceneLoaderBegin(); #end if // Scene loading ends. #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onSceneLoaderEnd(); #end if // Shader compiling begin, need more power. #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onShaderLoaderBegin(); #end if // Shader compiling ends. #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onShaderLoaderEnd(); #end if Example usage in Java: Cocos2dxDataManager::setOptimise(String thing, float value); Table Of Values task 1 0 load_scene start end shader_compile start end After v3.17.2, the type of value changed from float to string to make it more usable. "},"advanced_topics/optimizing.html":{"url":"advanced_topics/optimizing.html","title":"Optimizing Graphics","keywords":"","body":"How to optimize the graphics performance of your Cocos2d-x games Golden rules Know the bottlenecks and optimize the bottlenecks. When doing optimization, we should always stick to this rule. Only 20% code in your system contribute to the 80% performance issue. Always use tools to profile the bottleneck, don't guess randomly. There are many tools available now for profiling the graphics performance. Though we are optimize the performance of Android games, but Xcode could also be helpful to debugging. Xcode: https://github.com/rstrahl/rudistrahl.me/blob/master/entries/Debugging-OpenGL-ES-With-Xcode-Profile-Tools.md and the official document: https://developer.apple.com/library/ios/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/ToolsOverview/ToolsOverview.html There are three major mobile GPU vendors nowadays and they provide decent graphics profiling tools: For ARM Mali GPU: //malideveloper.arm.com/resources/tools/mali-graphics-debugger/ For Imagination PowerVR GPU: https://community.imgtec.com/developers/powervr/tools/pvrtune/ For Qualcomm Adreno GPU: https://developer.qualcomm.com/software/adreno-gpu-profiler Use these tools when you suffer from graphics issues. But not at the first beginning, usually the bottleneck resides on CPU. Know your target device and your game engine Know the CPU/GPU family of your target device which is important when sometimes the performance issues only occurs on certain kind of devices. And you will find they share the same kind of GPU(ARM or PowerVR or Mali). Know the limitations of your currently used game engine is also important. If you know how your engine organize the graphics command, how your engine do batch drawing. You could avoid many common pitfalls during coding. The principle of \"Good enough\". (“If the viewer cannot tell the difference between differently rendered images always use the cheaper implementation\".) As we know a PNG with RGBA444 pixel format has lower graphics quality than the one with RGBA888 pixel format. But if we can't tell the difference between the two, we should stick to RGBA4444 pixel format. The RGBA444 format use less memory and it will less likely to cause the memory issue and bandwidth issue. It is the same goes for the audio sample rate. Common Bottlenecks As a rules of thumb, your game will suffer CPU bottlenecks easily than graphics bottlenecks. The CPU is often limited by the number of draw calls and the heavy compute operations in your game loop Try to minimize the total draw calls of your game. We should use batch draw as much as possible. Cocos2d-x 3.x has auto batch support, but it needs some effort to make it work. Also try avoid IO operations when players are playing your game. Try to preload your spritesheets, audios, TTF fonts etc. Also don't do heavy compute operations in your game loop which means don't let the heavy operations called 60 times per frame. Never! The GPU is often limited by the overdraw(fillrate) and bandwidth. If you are creating a 2D game and you don't write complex shaders, you might not suffer GPU issues. But the overdraw problem still has trouble and it will slow your graphics performance with too much bandwidth consumption. Though modern mobile GPU have TBDR(Tiled-based Defered Rendering) architecture, but only PowerVR's HSR(Hidden Surface Removal) could reduce the overdraw problem significantly. Other GPU vendors only implement a TBDR + early-z testing, it only reduce the overdraw problem when you submit your opaque geometry with the order(font to back). And Cocos2d-x always submit rendering commands ordered from back to front. Because in 2D, we might have many transparency images and only in this order the blending effect is correct. Note: By using poly triangles, we could improve the fillrate. Please refer to this article for more information: https://www.codeandweb.com/texturepacker/tutorials/cocos2d-x-performance-optimization But don't worry too much of this issue, it doesn't perform too bad in practice. Simple checklist to make your Cocos2d-x game faster Always use batch drawing. Package sprite images in the same layer into a large atlas(Texture packer could help). As rule of thumb, try to keep your draw call below 50. In other words, try to minimize your draw call number. Prefer 16bit(RGBA4444+dithering) over raw 32bit(RGBA8888) textures. Use compressed textures: In iOS use PVRTC texture. In Android platform, use ETC1. but ETC1 doesn't has alpha, you might need to write a custom shader and provide a separate ETC1 image for the alpha channel. Don't use system font as your game score counter. It's slow. Try to use TTF or BMFont, BMfont is better. Try to preload audio and other game objects before usage. Use armeabi-v7a to build Android native code and it will enable neon instructors which is very fast. Bake the lighting rather than using the dynamic light. Avoid using complex pixel shaders. Avoid using discard and alpha test in your pixel shader, it will break the HSR(Hidden surface removal). Only use it when necessary. "},"advanced_topics/shaders.html":{"url":"advanced_topics/shaders.html","title":"Shaders and Materials","keywords":"","body":"Shaders and Materials What is a Shader From wikipedia: In the field of computer graphics, a shader is a computer program that is used to do shading: the production of appropriate levels of color within an image, or, in the modern era, also to produce special effects or do video post-processing. A definition in layman's terms might be given as \"a program that tells a computer how to draw something in a specific and unique way\". In other words, it is a piece of code that runs on the GPU (not CPU) to draw the different Cocos2d-x Nodes. Cocos2d-x uses the OpenGL ES Shading Language v1.0 for the shaders. But describing the GLSL language is outside the scope of this document. In order to learn more about the language, please refer to: OpenGL ES Shading Language v1.0 Spec. In Cocos2d-x, all Node objects that are renderable use shaders. As an example Sprite uses optimized shaders for 2d sprites, Sprite3D uses optimized shaders for 3d objects, and so on. Customizing Shaders Users can change the predefined shaders from any Cocos2d-x Node by calling: sprite->setGLProgramState(programState); sprite3d->setGLProgramState(programState); The GLProgramState object contains two important things: A GLProgram: Basically this is the shader. It contains a vertex and fragment shader. And the state, which basically are the uniforms of the shader. In case you are not familiar with the term uniform and why it is needed, please refer to the OpenGL Shading Language Specification Setting uniforms to a GLProgramState is as easy as this: glProgramState->setUniformFloat(\"u_progress\", 0.9); glProgramState->setUniformVec2(\"u_position\", Vec2(x,y)); glProgramState->setUniformMat4(\"u_transform\", matrix); You can even set callbacks as a uniform value: glProgramState->setUniformCallback(\"u_progress\", [](GLProgram* glProgram, Uniform* uniform) { float random = CCRANDOM_0_1(); glProgram->setUniformLocationWith1f(uniform->location, random); } ); And although it is possible to set GLProgramState objects manually, an easier way to do it is by using Material objects. What is a Material Assume that you want to draw a sphere like this one: The first thing that you have to do is to define its geometry, something like this: ...and then define the brick texture, like: But what if you want to use a lower quality texture when the sphere is far away from the camera? or what if you want to apply a blur effect to the bricks? or what if you want to enable or disable lighting in the sphere ? The answer is to use a Material instead of just a plain and simple texture. In fact, with Material you can have more than one texture, and much more features like multi-pass rendering. Material objects are created from .material files, which contain the following information: Material can have one or more Technique objects each Technique can have one more Pass objects each Pass object has: a RenderState object, a Shader object including the uniforms As an example, this is how a material file looks like: // A \"Material\" file can contain one or more materials material spaceship { // A Material contains one or more Techniques. // In case more than one Technique is present, the first one will be the default one // A \"Technique\" describes how the material is going to be renderer // Techniques could: // - define the render quality of the model: high quality, low quality, etc. // - lit or unlit an object // etc... technique normal { // A technique can contain one or more passes // A \"Pass\" describes the \"draws\" that will be needed // in order to achieve the desired technique // The 3 properties of the Passes are shader, renderState and sampler pass 0 { // shader: responsible for the vertex and frag shaders, and its uniforms shader { vertexShader = Shaders3D/3d_position_tex.vert fragmentShader = Shaders3D/3d_color_tex.frag // uniforms, including samplers go here u_color = 0.9,0.8,0.7 // sampler: the id is the uniform name sampler u_sampler0 { path = Sprite3DTest/boss.png mipmap = true wrapS = CLAMP wrapT = CLAMP minFilter = NEAREST_MIPMAP_LINEAR magFilter = LINEAR } } // renderState: responsible for depth buffer, cullface, stencil, blending, etc. renderState { cullFace = true cullFaceSide = FRONT depthTest = true } } } } And this is how to set a Material to a Sprite3D: Material* material = Material::createWithFilename(\"Materials/3d_effects.material\"); sprite3d->setMaterial(material); And if you want to change between different Techniques, you have to do: material->setTechnique(\"normal\"); Techniques Since you can bind only one Material per Sprite3D, an additional feature is supported that's designed to make it quick and easy to change the way you render the parts at runtime. You can define multiple techniques by giving them different names. Each one can have a completely different rendering technique, and you can even change the technique being applied at runtime by using Material::setTechnique(const std::string& name). When a material is loaded, all the techniques are loaded ahead too. This is a practical way of handling different light combinations or having lower-quality rendering techniques, such as disabling bump mapping, when the object being rendered is far away from the camera. Passes A Technique can have one or more passes That is, multi-pass rendering. And each Pass has two main objects: RenderState: contains the GPU state information, like depthTest, cullFace, stencilTest, etc. GLProgramState: contains the shader (GLProgram) that is going to be used, including its uniforms. Material file format in detail Material uses a file format optimized to create Material files. This file format is very similar to other existing Material file formats, like GamePlay3D's and OGRE3D's. Notes: Material file extensions do not matter. Although it is recommended to use .material as extension id is optional for material, technique and pass Materials can inherit values from another material by optionally setting a parent_material_id Vertex and fragment shader file extensions do not matter. The convention in Cocos2d-x is to use .vert and frag // When the .material file contains one material sprite3D->setMaterial(\"Materials/box.material\"); // When the .material file contains multiple materials sprite3D->setMaterial(\"Materials/circle.material#wood\"); material material_id : parent_material_id     {     renderState {} [0..1] block technique id {} [0..*] block }     technique technique_id     {     renderState {} [0..1] block pass id {} [0..*] block }     pass pass_id     {     renderState {} [0..1] block shader {} [0..1] block }     renderState     {     blend = false [0..1] bool blendSrc = BLEND_ENUM [0..1] enum blendDst = BLEND_ENUM [0..1] enum cullFace = false [0..1] bool depthTest = false [0..1] bool depthWrite = false [0..1] bool }       frontFace = CW | CCW [0..1] enum   depthTest = false [0..1] bool   depthWrite = false [0..1] bool   depthFunc = FUNC_ENUM [0..1] enum   stencilTest = false [0..1] bool   stencilWrite = 4294967295 [0..1] uint   stencilFunc = FUNC_ENUM [0..1] enum   stencilFuncRef = 0 [0..1] int   stencilFuncMask = 4294967295 [0..1] uint   stencilOpSfail = STENCIL_OPERATION_ENUM [0..1] enum   stencilOpDpfail = STENCIL_OPERATION_ENUM [0..1] enum   stencilOpDppass = STENCIL_OPERATION_ENUM [0..1] enum shadershader_id     {     vertexShader = res/colored.vert [0..1] file path fragmentShader = res/colored.frag [0..1] file path defines = semicolon separated list [0..1] string       uniform_name = scalar | vector [0..*] uniform uniform_name = AUTO_BIND_ENUM [0..*] enum sampler uniform_name {} [0..*] block }     sampler uniform_name     {     path = res/wood.png | @wood [0..1] image path mipmap = bool [0..1] bool wrapS = REPEAT | CLAMP [0..1] enum wrapT = REPEAT | CLAMP [0..1] enum minFilter = TEXTURE_MIN_FILTER_ENUM [0..1] enum magFilter = TEXTURE_MAG_FILTER_ENUM [0..1] enum }     Enums: TEXTURE_MIN_FILTER_ENUM   NEAREST Lowest quality non-mipmapped LINEAR Better quality non-mipmapped NEAREST_MIPMAP_NEAREST Fast but low quality mipmapping LINEAR_MIPMAP_NEAREST   NEAREST_MIPMAP_LINEAR   LINEAR_MIPMAP_LINEAR Best quality mipmapping TEXTURE_MAG_FILTER_ENUM   NEAREST Lowest quality LINEAR Better quality BLEND_ENUM   ZERO ONE_MINUS_DST_ALPHA ONE CONSTANT_ALPHA SRC_ALPHA ONE_MINUS_CONSTANT_ALPHA ONE_MINUS_SRC_ALPHA SRC_ALPHA_SATURATE DST_ALPHA   CULL_FACE_SIDE_ENUM BACK Cull back-facing polygons. FRONT Cull front-facing polygons. FRONT_AND_BACK Cull front and back-facing polygons. FUNC_ENUM NEVER ALWAYS LESS GREATER EQUAL NOTEQUAL LEQUAL GEQUAL STENCIL_OPERATION_ENUM KEEP REPLACE ZERO INVERT INCR DECR INCR_WRAP DECR_WRAP Types: scalar is float, int or bool. vector is a comma separated list of floats. Predefined uniforms The following are predefined uniforms used by Cocos2d-x that can be used in your shaders: CC_PMatrix: A mat4 with the projection matrix CC_MVMatrix: A mat4 with the Model View matrix CC_MVPMatrix: A mat4 with the Model View Projection matrix CC_NormalMatrix: A mat4 with Normal Matrix CC_Time: a vec4 with the elapsed time since the game was started CC_Time[0] = time / 10; CC_Time[1] = time; CC_Time[2] = time * 2; CC_Time[3] = time * 4; CC_SinTime: a vec4 with the elapsed time since the game was started: CC_SinTime[0] = time / 8; CC_SinTime[1] = time / 4; CC_SinTime[2] = time / 2; CC_SinTime[3] = sinf(time); CC_CosTime: a vec4 with the elapsed time since the game was started: CC_CosTime[0] = time / 8; CC_CosTime[1] = time / 4; CC_CosTime[2] = time / 2; CC_CosTime[3] = cosf(time); CC_Random01: A vec4 with four random numbers between 0.0f and 1.0f CC_Texture0: A sampler2D CC_Texture1: A sampler2D CC_Texture2: A sampler2D CC_Texture3: A sampler2D "},"advanced_topics/sqlite.html":{"url":"advanced_topics/sqlite.html","title":"SQLite","keywords":"","body":"SQLite SQLite is a self-contained SQL database engine. This means there is no server involved. SQLite runs while your game is running and you write code to connect to the database and manipulate its contents. This is by no means a comprehensive guide, in fact, we cover 1% of what SQLite can do for you. Please read their website for a lot more detail as to what functionality SQLIte offers developers. Getting Started. In-order to use SQLite you must download it and add it to your project. Please see the SQLite Downloads page for more details. For our purposes you will just need sqlite.h and sqlite.c in your project. Add these files to your environment and make sure they are part of your build process. How Does SQL Work In A Game? Now that you have SQLite you must understand how using a database in your app works. There isn't any automatic benefit, unless you code it. There are no wizards and no functionality for free. This is hand coded, by you, to meet your specific needs. Generally speaking, you will need to evaluate the following: Does your database already exist? Yes? Connect to it. No? Create it, probably using create table queries. Then connect to it. Are you connected to the database? Yes? Issue queries against it to achieve your goals. No? Connect to it, then issue queries against it to achieve your goals. Do you need to update your database based upon player achievements? Yes? Run insert/update queries to change the database. No? Probably select queries are enough to use the database to drive your game play. Is the player done with your game? Yes? Make sure to close the database when your game exists. Failure to do so may corrupt your database and make it unusable. Basic Database Creation And Manipulation Let's cover how to create a simple database, connect to it and then manipulate it. Creating A Simple Database In order to use your database, it must exist. SQLite is file based. Simply creating a new file to house your database is sufficient. Notice that we use a .db file extension to help notate that this is indeed our database. It is also important to understand where the database lives on the players device. When you create the database it must be put in a location that the device allows the player to write data to. Cocos2d-x helps make this easy with a file system API called getWriteablePath(). Here is an example: sqlite3* pdb; pdb = NULL; std::string dbPath = cocos2d::FileUtils::getInstance()->getWritablePath() + \"mydatabase.db\"; int result = sqlite3_open(dbPath.c_str(), &pdb); if(result == SQLITE_OK) std::cout With the database open, you can now use it. Creating A Table Databases use tables to store data. You need at least one table in your database. The caveat is that you must know what data your table will contain in-order to create it. You can always use the SQL alter table command if at a later tine you need to modify your tables structure. This is outside the scope of this document, however. Creating a simple table: int result = 0; std::string sql; sql = \"create table \" + std::string(\"Master\") + std::string(\" (id TEXT PRIMARY KEY, value INT);\"); result = sqlite3_exec(pdb, sql.c_str(), NULL, NULL, NULL); if(result == SQLITE_OK) { // table created successfully } else { // table was NOT created successfully } Querying Data When you want information from your database you must execute a select query to get it. A select query is a read-only query. You don't have to worry about accidentally modifying your game data when running these types of queries. An example select query; std::string key = \"Brown\"; std::string sql = \"SELECT NAME \" + std::string(\" FROM \") + std::string(\"Master\") + std::string(\" WHERE id='\") + std::string(key.c_str()) + std::string(\"' LIMIT 1;\"); sqlite3_stmt* statement; if (sqlite3_prepare_v2(&pdb, sql.c_str(), -1, &statement, 0) == SQLITE_OK) { int result = 0; while(true) { result = sqlite3_step(statement); if(result == SQLITE_ROW) { // do something with the row. } else { break; } } } Inserting Data You may need to insert data into your database to use again at a later time. Use an insert query to do this. Example: Updating Data Closing The Database "},"installation/":{"url":"installation/","title":"Software Installations","keywords":"","body":"Software Installations Cocos2d-x can be installed on OS X, Windows, Linux for development with the ability to deploy to iOS, Android, OS X, Windows and even game consoles. See Installation Prerequisites Android Studio Android Command-line (Deprecated) Android Eclipse (Deprecated) Android Visual Studio (Deprecated) iOS Linux macOS Tizen (Deprecated) Windows Windows Phone (Deprecated) "},"installation/prerequisites.html":{"url":"installation/prerequisites.html","title":"Prerequisites","keywords":"","body":"Prerequisites Build Requirements v3.17.2 Mac OS X 10.13+, Xcode 10+ Ubuntu 16.04+, CMake 3.1+ (use apt install to get the latest version) Windows 7+, VS 2017+ Python 2.7.5+, Python 2,7.10 reccomended, NOT Python 3+ NDK r91c+ is required to build Android games (tested with r19c) May be called 19.2.xx from within Android Studio Android Studio 3.4+ to build Android games (tested with 3.0) v3.17, v3.17.1 Mac OS X 10.13+, Xcode 10+ Ubuntu 16.04+, CMake 3.1+ (use apt install to get the latest version) Windows 7+, VS 2015+ Python 2.7.5+, Python 2,7.10 reccomended, NOT Python 3+ NDK r16+ is required to build Android games (tested with r16) Android Studio 3.0+ to build Android games (tested with 3.0) v3.16 Mac OS X 10.7+, Xcode 7+ Ubuntu 12.10+, CMake 2.6+ Windows 7+, VS 2013+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ is required to build Android games (tested with r14) Android Studio 2.3.3+ to build Android games (tested with 2.3.3 and 3.0) JRE or JDK 1.6+ is required for web publishing v3.15 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Android Studio 2.3+ to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 Tizen SDK 2.3+ is required to build Tizen games JRE or JDK 1.6+ is required for web publishing v3.14 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.13, v3.13.1 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.12 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Clang for developing Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.8, v3.9, v3.10, v3.11, v3.11.1 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.7 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+, CMake 2.6+ Windows 7+, VS 2013+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ JRE or JDK 1.6+ is required for web publishing v3.4, v3.5, v3.6 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+ Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ v3.3 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+ Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ v3.0, v3.1, v3.1.1, v3.2 Mac OS X 10.7+, Xcode 4.6+ Ubuntu 12.04+, gcc 4.7 Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r9d is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ Runtime Requirements iOS 6.0+ for iPhone / iPad games Android 2.3+ for Android games Windows 8.1 or Windows 10.0 for Windows Phone/Store 8.1 games Windows 10.0 for Windows Phone/Store 10.0 games Mac OS X v10.6+ for Mac games Windows 7+ for Win games Modern browsers and IE 9+ for web games Revision history 11/28/2017 - slackmoehrle - added Python 2.7.5+, but not Python 3+ and Visual C++ Redistributable requirements. 1/2/2017 - slackmoehrle - reviews while comparing to README for each tagged release. "},"installation/Android-Studio.html":{"url":"installation/Android-Studio.html","title":"Android","keywords":"","body":"Android Studio Installation and Setup Prerequisites A supported environment. See Installation Prerequisites Android Studio 2.3.3 or Studio 3.0 https://developer.android.com/studio/index.html Setup unzip the Android Studio Bundle launch Android Studio. This may take quite some time as additional downloads and setup steps are completed. These steps are necessary for Studio to run properly. after the previous step is complete, it is necessary install the SDK and build tools. SDK Manager is located in: Tools --> Android --> SDK Manager. It is also possible to access the SDK Manager without opening a project by selecting it from the dialog box Android Studio presents at startup: The SDK Manager window looks like this: Make sure to install the platforms and tools that your project requires. Compiling cpp-tests cpp-tests is a project you can run to get familiar with how to code using Cocos2d-x. To run this project with Android Studio: import the cpp-tests project from cocos2d-x root/tests/cpp-tests/proj.android in Android Studio. Android Studio will do everything required. You can run cpp-tests by clicking on the Play button. note: Android Studio is going to download many components. It may even throw errors that you just click to fix. These errors may include: gradle version updates, installing missing build tools, agreeing to license agreements, etc. Starting a new project Starting a new project requires a few steps: first, use cocos new ... to create your project. See the Cocos Command-line tool for additional help. next, launch Android Studio. next, you must specify what version of the Android SDK you are using. You can do this by modifying gradle.properties Debugging c++ Starting with cocos2d-x v3.15, you can use Android Studio 2.3+ to debug c++ code by setting breakpoints where you wish. Build for release mode There are a few required steps to build in release mode: change Build Variant to release set signing information in gradle.properties for lua projects, if you want to encrypt lua codes, you should set encrypt information in gradle.properties too Installing new SDK versions and build tools use the built in SDK Manager to install the SDK versions and build tools that you are targetting. Note: It is important to note that Android Studio uses a location to install SDK versions and build tools that is not the same as if you were doing command-line development. Double check that you have everything you need installed from inside Android Studio. Troubleshooting Please see this F.A.Q for troubleshooting help. "},"installation/Android-terminal.html":{"url":"installation/Android-terminal.html","title":"Command-line (Deprecated)","keywords":"","body":"Android with Command-line Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Environment Requirements A supported environment. See Installation Prerequisites Starting decisions Android development is a complicated beast. Not only are there several development environment options, each also requires several dependencies. These all need to be working before you can attempt to build a Cocos2d-x project. Read these steps a few times and take a few minutes to think about what workflow best suites you. Prerequisites Before we even talk about Cocos2d-x specific tasks, you need a working Android environment. This includes: JDK/SDK 1.6+ http://www.oracle.com/technetwork/java/javase/downloads/index.html Android NDK https://developer.android.com/tools/sdk/ndk/index.html Apache Ant http://ant.apache.org/bindownload.cgi Python 2.7.5 https://www.python.org/downloads/ NOT PYTHON 3 Your system may already have some of these items. Download the items that you need to inorder to have a complete environment. Nothing on this list can be missing. macOS Instructions Python macOS systems come with Python installed by default. Verify that your system has Python and ensusre that it is a version less than 3. From Terminal.app or iTerm 2 execute the following: > python --version If you see output, such as: Python 2.7.10 You are good to go. If you see anything else you may need to install Python. Use the link above. You cannot move on in this document until this step is working. JAVA macOS systems usually do not come with JAVA installed. It is necessary to download and install it using the link above. Make sure that you install the JDK. It is not enough to just install the JRE. Once installed, it is necessary to set JAVA_HOME in your .bash_profile. Example: export JAVA_HOME=$\"(/usr/libexec/java_home -v 1.8)\" Once you are done with this step, re-source your .bash_profile: source ~/.bash_profile. Now you can test that JAVA is available on your system: > java -v You should see some version info as output. Example: java version \"1.8.0_111\" Java(TM) SE Runtime Environment (build 1.8.0_111-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode) If you see any of the following types of errors, the JDK is either not installed or is not accessible. Verify you have set JAVA_HOME. Example errors: Unable to find any JVMs matching version \"(null)\". Matching Java Virtual Machines (0): No Java runtime present, requesting install. Unable to find any JVMs matching version \"(null)\". No Java runtime present, try --request to install. If you are unsure, you can always execute /usr/libexec/java_home -V for a listing of JAVA JDKs on your system. Example: > usr/libexec/java_home -V Matching Java Virtual Machines (1): 1.8.0_111, x86_64: \"Java SE 8\" /Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home /Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home Apache Ant Apache Ant is another required tool. It is not installed on an OSX system by default. It is neccessary to download it using the link above. Using a binary distribution is fine. There is no need to download the source and compile by hand unless this is your preferred method. After downloading, unzip the Apache Ant archive. You only need to place the Apache Ant folder someplace in your $PATH and then set an $ANT_ROOT environment variable in your .bash_profile. Exactly the same way $JAVA_HOME was added above. Example, if your Apache ANT folder is named apache-ant-1.10.0: export ANT_ROOT=/Applications/Cocos/tools/ant/bin export PATH=$ANT_ROOT:$PATH Android NDK and SDK Obviously, you need the Android NDK and SDK to do Android development. These are not installed on an OSX system by default. It is neccessary to download it using the link above. Brew Using brew is one option for installing the Android NDK and SDK. Installing with brew makes the installation simple. A single command, a few environment variables and you are done. Example: $ brew tap caskroom/cask $ brew cask install android-sdk android-ndk This will take a while to complete. Once it is done, you need to set a few envorinment variables in your .bash_profile. export NDK_ROOT=/usr/local/Cellar/android-ndk/r12b export PATH=$NDK_ROOT:$PATH export ANDROID_HOME=/usr/local/opt/android-sdk export ANDROID_SDK_ROOT=/usr/local/Cellar/android-sdk/24.4.1_1 export PATH=$ANDROID_SDK_ROOT:$PATH export PATH=$ANDROID_SDK_ROOT/tools:$ANDROID_SDK_ROOT/platform-tools:$PATH Make sure to re-source your .bash_profile! Installing manually. If you choose not to use brew you can still download and install the Android NDK and SDK by hand. After downloading, set the same environment variables as above, but using your custom paths. For example, if you downloaded the Android NDK and SDK to ~/Projects/: export NDK_ROOT=/Users/username/Projects/android-ndk/r12b export PATH=$NDK_ROOT:$PATH export ANDROID_HOME=/Users/username/Projects/android-sdk export ANDROID_SDK_ROOT=/Users/username/Projects/android-sdk/24.4.1_1 export PATH=$ANDROID_SDK_ROOT:$PATH export PATH=$ANDROID_SDK_ROOT/tools:$ANDROID_SDK_ROOT/platform-tools:$PATH Installing additional Android SDKs Depending upon what Android OS versions you wish to target, you may need to install additional Android SDKs to cover those OS versions. As Android SDKs evolve, sometimes older OS suppot is dropped. This means that your game might not be able to target older devices. This is a personal decision on the part of the game developer. If you wish to install additional Android SDKs, use the built in android GUI tool to install whatever you need. Example: > android It is only necessary to install the Android SDK Tools for each release you want installed on your system. It is always a good idea to update the Android SDK Platform-Tools when a new version becomes available. Cocos2d-x Installing Cocos2d-x is probably the easiest part of this process. You can get started with Cocos2d-x by either downloading a self-contained .zip from the website or by cloning our GitHub Repo. Pick what works for you. There is no need to do both. By downloading a .zip archive Download Cocos2d-x and unzip it. (maybe: ~/ or ~/Projects ) Cloning from GitHub Use the following commands to clone our GitHub repo and get your environment setup. If you are not familar with GitHub's workflow, learn it or download using the step above, By downloading a .zip archive. cd git clone git@github.com:cocos2d/cocos2d-x.git git submodule update --init git submodule update ./download-deps.py Making sure you are ready to create the next hit game! Next, you are ready to build cpp-tests. It is a good idea to perform this step before starting a new project. It ensures that your environment is setup completely. If anything fails during this step, it is important to read the error message carefully and re-visit the step above that is related to the error message you see. Change your directory to the where the android-build.py script is located. (usually Cocos2d-x/build). To see what targets are available. run: > android list targets Now you can execute the command to build: > python android-build.py -p cpp-tests Everything should build successfully! Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. How to deploy it on your Android phone via command line Enable USB Debugging on your phone and then connect your phone via USB. Change your directory to the the bin directory of your android project Use adb to install the .apk to your Android phone by executing: > adb install MyGame-debug.apk "},"installation/Android-VisualStudio.html":{"url":"installation/Android-VisualStudio.html","title":"Visual Studio (Deprecated)","keywords":"","body":"Android with Visual Studio Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Environment Requirements A Supported OS. See Installation Prerequisites Visual Studio 2015 update 2+ (NOT Visual Studio Code!) https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx Prerequisites Download and install Visual Studio 2015 update 2+. Download and install Python. Ensure that it is available in your $PATH. Download Cocos2d-x and unzip it where you wish. From a command-line, change to the location you unzipped Cocos2d-x to and run: python setup.py Using Visual Studio with Cocos2d-x Make sure that you are using Cocos2d-x v3.12. Creating a new project Read our document on the Cocos Command-line tool and create a new project. Download proj.visualstudio copy proj.visualstudio.zip into your project's root directory and unzip it. It should fall inline with your other project directories. Example: By default proj.visualstudio contains a project called Cocos2d.sln, open this .sln file. Build and run! Integrating with an existing project Download proj.visualstudio copy proj.visualstudio.zip into your project's root directory and unzip it. It should fall inline with your other project directories. Example: By default proj.visualstudio contains a project called Cocos2d.sln, feel free to re-name this to your project's name. Open the .sln file. Add any source files and resources that are required to build your project. Change any necessary build settings required by your project. Build and troubleshoot any integration needs. "},"installation/Android-Eclipse.html":{"url":"installation/Android-Eclipse.html","title":"Eclipse (Deprecated)","keywords":"","body":"Android with Eclipse Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Prerequisites Completed the Android Command-Line Instructions Eclipse ADT Bundle http://www.eclipse.org/downloads/ Open the proj.android project with Eclipse. Launch Eclipse Right click your mouse at the empty area of the Package Explorer and choose Import. Choose Existing Android Code Into Workspace from the pop up dialog and Click Next. Click the Browse button to choose the directory of CPP-Tests proj.android and Click Ok. Click Finish. Import Libcocos2dx Project Same steps as above only using the path of the libcocos2dx project is your own game project folder/cocos/2d/platform/android/java. Build and Run the Android Project Connect your Android phone with USB remote debugging option enabled. Make sure your computer can recognize your phone (you might need to install drivers for your specific phone) Right click on the project and choose Run as -> Android Application. "},"installation/iOS.html":{"url":"installation/iOS.html","title":"iOS","keywords":"","body":"iOS and macOS Installation and Setup Prerequisites A supported environment. See Installation Prerequisites Setting up Cocos2d-x You can get started with Cocos2d-x by either downloading a self-contained .zip from the website or by cloning our GitHub Repo. Pick what works for you. There is no need to do both. By downloading a .zip archive Download Cocos2d-x and unzip it. (maybe: ~/ or ~/Projects ) Cloning from GitHub Use the following commands to clone our GitHub repo and get your environment setup. If you are not familar with GitHub's workflow, learn it or download using the step above, By downloading a .zip archive. cd git clone git@github.com:cocos2d/cocos2d-x.git git submodule update --init git submodule update ./download-deps.py Make sure you have a working environment! See Prerequisites above. This means a working Python, having run /setup.py>, updated your $PATH and run source ~/.bash_profile. Build and Run iOS Enter /build and open cocos2d_tests.xcodeproj Choose cpp-tests iOS from targets drop-down box Click run to compile and run cpp-tests macOS In /build, open cocos2d_tests.xcodeproj Choose cpp-tests Mac from targets drop-down box Click run to compile and run cpp-tests Running on an iOS Device In order to run on iOS Device an iOS Developer Program membership is needed. You can purchase one from Apple: https://developer.apple.com/programs/ios/ . The steps to run on iOS device are the same as running in a simulator except you select you device from the device list. Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. Troubleshooting Please see this F.A.Q for troubleshooting help. Revision history 1/2/2017 - slackmoehrle - tested steps, re-worded, added Github, combined iOS and OSX instructions. "},"installation/OSX.html":{"url":"installation/OSX.html","title":"macOS","keywords":"","body":"macOS Installation and Setup Prerequisites A supported environment. See Installation Prerequisites Setting up Cocos2d-x You can get started with Cocos2d-x by either downloading a self-contained .zip from the website or by cloning our GitHub Repo. Pick what works for you. There is no need to do both. By downloading a .zip archive Download Cocos2d-x and unzip it. (maybe: ~/ or ~/Projects ) Cloning from GitHub Use the following commands to clone our GitHub repo and get your environment setup. If you are not familar with GitHub's workflow, learn it or download using the step above, By downloading a .zip archive. cd git clone git@github.com:cocos2d/cocos2d-x.git git submodule update --init git submodule update ./download-deps.py Build and Run In /build, open cocos2d_tests.xcodeproj Choose cpp-tests Mac from targets drop-down box Click run to compile and run cpp-tests Running on an iOS Device In order to run on iOS Device an iOS Developer Program membership is needed. You can purchase one from Apple: https://developer.apple.com/programs/ios/. The steps to run on iOS device are the same as running in a simulator except you select you device from the device list. Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. Troubleshooting Please see this F.A.Q for troubleshooting help. "},"installation/Linux.html":{"url":"installation/Linux.html","title":"Linux","keywords":"","body":"Linux Installation and Setup Prerequisites A supported environment. See Installation Prerequisites Ubuntu versions We support Ubuntu 12.10+, however, newer versions of Ubuntu have changed and the steps to install Cocos2d-x and required dependencies are a bit different. This requires some manual effort and this doc will outline what is required. Setting up Cocos2d-x You can get started with Cocos2d-x by either downloading a self-contained .zip from the website or by cloning our GitHub Repo. Pick what works for you. There is no need to do both. By downloading a .zip archive Download Cocos2d-x and unzip it. (maybe: ~/ or ~/Projects ) Cloning from GitHub Use the following commands to clone our GitHub repo and get your environment setup. If you are not familar with GitHub's workflow, learn it or download using the step above, By downloading a .zip archive. Install Python // Ubuntu 16.x sudo apt-get install python2 // Ubuntu 17.x sudo apt-get install python2.7 // Ubuntu 18.x sudo apt-get install python-minimal Clone Repo and setup dependencies sudo apt-get install git cd git clone https://github.com/cocos2d/cocos2d-x.git cd cocos2d-x-root #where your cocos2d-x directory is located. git submodule update --init git submodule update ./download-deps.py Make sure you have a working environment! See Prerequisites above. This means a working Python, having run cocos2d-x root/setup.py, updated your $PATH and run source ~/.bash_profile. Dependencies that you need Cocos2d-x requires a number of dependencies be installed on your system. Please perform the following steps: Update your system, execute: sudo apt-get update sudo apt-get upgrade Install Dependencies (Ubuntu 16.x only) Install dependencies// Ubuntu 16.x sudo apt-get install g++ libgdk-pixbuf2.0-dev python-pip cmake libx11-dev libxmu-dev libglu1-mesa-dev libgl2ps-dev libxi-dev libzip-dev libpng-dev libcurl4-gnutls-dev libfontconfig1-dev libsqlite3-dev libglew-dev libssl-dev libgtk-3-dev libglfw3 libglfw3-dev xorg-dev Install Dependencies (Ubuntu 17.x only) Add a repo to /etc/apt/sources.list deb //cz.archive.ubuntu.com/ubuntu xenial main Install Dependencies sudo apt-get install g++ libgdk-pixbuf2.0-dev python-pip cmake libx11-dev libxmu-dev libglu1-mesa-dev libgl2ps-dev libxi-dev libzip-dev libpng-dev libcurl4-gnutls-dev libfontconfig1-dev libsqlite3-dev libglew-dev libssl-dev libgtk-3-dev libglfw3 libglfw3-dev xorg-dev Install Dependencies (Ubuntu 18.x only) Install dependencies. sudo apt-get install g++ libgdk-pixbuf2.0-dev python-pip cmake libx11-dev libxmu-dev libglu1-mesa-dev libgl2ps-dev libxi-dev libzip-dev libpng-dev libcurl4-gnutls-dev libfontconfig1-dev libsqlite3-dev libglew-dev libssl-dev libgtk-3-dev libglfw3 libglfw3-dev xorg-dev Building Cocos2d-x Run cmake to generate makefile: cd cocos2d-x-root # where your cocos2d-x directory is located. cd build mkdir linux-build cd linux-build cmake ../.. When cmake finishes, many files & folders will be generated in coocs2dx_root/build/linux-build Run make to compile: make -j 4 Everything will be generated in cocos2dx_root/build/linux-build/bin/cpp-tests/ if compiled successfully. Run cpp-tests cd cocos2dx_root/build/linux-build/bin/Debug/cpp-tests/ ./cpp-tests Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. Troubleshooting Please see this F.A.Q for troubleshooting help. Linux has a few known issues. "},"installation/Tizen.html":{"url":"installation/Tizen.html","title":"Tizen (Deprecated)","keywords":"","body":"Tizen Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Environment Requirements Windows, macOS or Ubuntu (a relatively recent version should suffice) Cocos2d-x v3.11 https://cocos2d-x.org/download Tizen 2.4 Rev3+ SDK https://developer.tizen.org/development/tools/download Java JDK for your platform (a relatively recent version should suffice) Prerequisites Download Cocos2d-x. Download Tizen installer. Download Java JDK for your platform. Installation Install Java JDK for your platform. You may or may not need to do this depending upon your current setup. Install Tizen using the installer you downloaded. If you haven't downloaded it, please refer to prerequisites above. Double click the Tizen installer that you downloaded and follow the prompts. Click the 'Done' button, then when prompted to run the Update Manager, click 'Yes(Y)'. Select 2.4 Mobile and click the down-arrow at the right side to install. If you install version 2.4, the resulting TPK could also be installed on Tizen device runs 2.3 version system. The resulting TPK is back compatible for old version devices. After completing all steps, you should be able to launc the Tizen IDE 2.4. Running the built in tests Just like with any platform Cocso2d-x supports, you can run our sample tests to understand the engine's functionality. For c++ you want to look at cpp-tests and for Lua, lua-tests. Launch the Tizen IDE Select File -> Import Under General, select Existing Projects into Workspace Browse to where the Cocos2d-x root is. Then select cpp-tests and libcocos2d-x ensuring that the path for both contains proj.tizen as it is possible to import projects for Android, but we don't want to do this. By default, a project has three configurations Debug, Release and Emulator. Debug and Release are settings that build for hardware. Emulator is for simulating a hardware device when one is not available. It is always best to test on actual hardware before deploying your app to production. To change either Debug or Release, right click on the libcocos2d-x project and select Properties. When this window opens, select C/C++ Build -> Tizen Settings. A few items here need to be changed. Change the properties with the red boxes on the screenshot below. Choose Mobile 2.4, x86 and GCC 4.9 of the toolchain. Then click the OK button. Repeat this same step for the cpp-tests project. To build for the Emulator, right click on the libcocos2d-x project and select Build Configurations -> Set Active -> Emulator Now, we can build. First, build libcocos2d-x. Right click on the libcocos2d-x project and select Build Project or press the F10 key. Repeat this same step for the cpp-tests project. Once everything is built cpp-tests will run and you can experiment with it's functionality. Compiling & Running with Command-line tool You also can compile & run your project on Tizen with cocos command. There are some arguments for the Tizen platform: | Argument | Available Value | Description | | ----|----|----| | --tizen-arch | x86, arm | Determines the architecture type for the rootstrap. Default is x86. (x86 is for simulators, and arm for devices) | | --tizen-profile | Path of signing profile | Set the profile path for signing. | | --tizen-sign | String | Set the profile name to use for signing. | | --tizen-strip | - | Determines whether to strip the native binary. | Sample commands: cocos compile -s PROJECT_PATH -p tizen -m release --tizen-arch arm --tizen-profile PROFILE_PATH --tizen-sign SIGN_STRING --tizen-strip Compile the project for the ARM architecture. A .tpk file will be generated. cocos run -s PROJECT_PATH -p tizen --tizen-profile PROFILE_PATH --tizen-sign SIGN_STRING Launch the Tizen simulator and then run the project on the Tizen simulator. (Note: it is important to remember that the Tizen simulator must always be running in-order to run your project.) Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. "},"installation/Windows.html":{"url":"installation/Windows.html","title":"Windows","keywords":"","body":"Windows Installation and Setup Prerequisites A supported environment. See Installation Prerequisites Setting up Cocos2d-x You can get started with Cocos2d-x by either downloading a self-contained .zip from the website or by cloning our GitHub Repo. Pick what works for you. There is no need to do both. Make sure you have a working environment. This means a working Python, having run /setup.py> and updated your $PATH. By downloading a .zip archive Download Cocos2d-x and unzip it. (maybe: c:\\Users\\your_user_id) Cloning from GitHub Use the following commands to clone our GitHub repo and get your environment setup. If you are not familar with GitHub's workflow, learn it or download using the step above, By downloading a .zip archive. c:\\ git clone git@github.com:cocos2d/cocos2d-x.git git submodule update --init git submodule update ./download-deps.py Compile and run the cpp-tests project Open cocos2d-win32.vc2012.sln in the build folder Right click the TestCpp project, and select Set as StartUp Project. Compile and run the TestCpp project. Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. Distributing a Cocos2d-x app on Windows Note: this falls outside of the realm of Cocos2d-x. Please consult Microsoft resources for assistance. If you try to run a game created with Cocos2d-x on a non-development machine, it may be required for this machine to have the Visual Studio runtime installed. The easiest way is to create an installer for your game, but it is possible to do it without by installing all required pieces manually. Use Dependency Walker to check what DLLs your game requires. Install the required Visual Studio runtime. Microsoft has now merged VS2015, 2017 and 2019 runtimes into one, which you can find here. For the installer, check these posts: InnoSetup (also shows you a sample for how to install the VS C++ runtime using it). Sample InnoSetup script for Cocos2d-x here. Troubleshooting Please see this F.A.Q for troubleshooting help. "},"installation/Windows-Phone.html":{"url":"installation/Windows-Phone.html","title":"Windows Phone (Deprecated)","keywords":"","body":"Windows Phone 8 Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Prerequisites A supported environment. See Installation Prerequisites Register to be a Windows Phone Developer https://developer.microsoft.com/en-us/windows Setting up Cocos2d-x Download Cocos2d-x and unzip it. (maybe: ~/) Make sure you have a working environment see Prerequisites above. This means a working Python, having run /setup.py> and updated your $PATH. Compile and run the cpp-tests project Open cocos2d-wp8.vc2012.sln in the build folder Right click the cpp-tests project, and select Set as StartUp Project. Select Emulator or a Device to run the project on. If you select Device you need to connect your phone device using usb. Compile and run the TestCpp project. How to debug in project Right click cpp-tests, select Properties, in Debug, select debug target. If you select Managed Only in UI Task, it's to debug c# code in cpp-tests. If you select Native Only, it's to debug c++ code in cpp-testsComponent. If you select Native Only and want to use CCLog function, right click cpp-testsComponent and define COCOS2D_DEBUG=1 in Preprocessor Definitions. Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. "},"installation/CMake-Guide.html":{"url":"installation/CMake-Guide.html","title":"CMake Guide","keywords":"","body":"CMake Guide CMake is an open-source, cross-platform family of tools designed to build, test and package software. CMake is used to control the software compilation process using simple platform and compiler independent configuration files, and generates native makefiles and workspaces that can be used in the compiler environment of your choice. Requirement Open your terminal and execute: cmake --version If the CMake version is lower than 3.1, please upgrade. You should use out-of-source builds, this means you need to create a different directory than cocos2d-x to execute the cmake command. Step by Step Linux cd cocos2d-x mkdir linux-build && cd linux-build cmake .. make Execute make help to see all build targets, make build specified target Generate Visual Studio projects cd cocos2d-x mkdir win32-build && cd win32-build cmake .. -G\"Visual Studio 15 2017\" -Tv141 Execute cmake --build . to compile, or open Cocos2d-x.sln in Explorer to use the generated project. Generate macOS Project cd cocos2d-x mkdir mac-build && cd mac-build cmake .. -GXcode open Cocos2d-x.xcodeproj Generate iOS Project cd cocos2d-x mkdir ios-build && cd ios-build cmake .. -GXcode -DCMAKE_TOOLCHAIN_FILE=../cmake/ios.toolchain.cmake open Cocos2d-x.xcodeproj The default build is for running on actual iOS hardware, if you want to run in the simulator, please add -DIOS_PLATFORM=SIMULATOR for architecture i386 or -DIOS_PLATFORM=SIMULATOR64 for x86_64. Android Studio We use the Gradle for Android applications, and Gradle use cmake to build the native code, see gradle.properties: PROP_NDK_MODE, it controls how native builds work. # android native code build type # none, native code will never be compiled. # cmake, native code will be compiled by CMakeLists.txt # ndk-build, native code will be compiled by Android.mk PROP_BUILD_TYPE=ndk-build If you want to add cmake build arguments, please add it at external Native Build block of app/build.gradle file. Any other cpp project can use prebuilt in this way When using the prebuilt libraries on Android there is a small difference as CMake can't find system environment when built using Gradle. You need to [supply a path](https://github.com/cocos2d/cocos2d-x/blob/c087be314c2c56a757bf66163b173746b5d6ad34/tests/cpp-empty-test/proj.android/app/build.gradle#L34) as the location of prebuilt libs. --> Build Options CMake Common Build Options -G, generate native build project you specified, for example -GXcode generate Xcode project files. -GVisual Studio 15 2017 generate Visual Studio 2017 project, the default toolset is v141, add -T option to specify toolset, like this -Tv140 CMAKE_BUILD_TYPE, specify the build mode, Debug or Release -DCMAKE_BUILD_TYPE=Release to generate the Release mode project, the default build mode is Debug -H -B, -H specify the CMake project Home directory, -B specify CMake-generated project binary directory. for example -H..\\cocos2d-x -Bmsvc_build the generated native project's location will be msvc_build directory. --build , build a CMake-generated project binary tree, for example cmake --build ./msvc_build, cmake will sellect corresponding build tools. Useful Links CMake Official website: cmake.org CMake Documentation: cmake.org/documentation CMake FAQ: Wiki/CMake_FAQ "},"editors_and_tools/":{"url":"editors_and_tools/","title":"Tools","keywords":"","body":"Editors and Tools The Cocos platform provides the following editors and tools to aid in development. Cocos Creator Creator to Cocos2d-x tool Cocos Command-line tool Cocos GUI (Deprecated) "},"editors_and_tools/cocosCLTool.html":{"url":"editors_and_tools/cocosCLTool.html","title":"Command-Line tool","keywords":"","body":"Cocos command-line tool What is the cocos command-line tool? Cocos2d-x comes with a command-line tool called cocos. It is a cross-platform tool that allows you to create new Cocos2d-x applications as well as run them and deploy them. cocos works for all cocos2d-x supported platforms, which include: ios, android, mac, linux, win32, wp8_1, wp10 and web. You don't need to use an IDE unless you want to. It has many options, so let's go through them grouped by function. Setting up cocos it is a good idea to run /setup.py to properly setup your PATH. Doing so ensures that you can run Cocos2d-x and its related tools. Example: # Option 1 > ./setup.py # Option 2 > python setup.py On macOS, it is also a good idea to add a few lines to your ~/.bash_profile to ensure your character encoding is set to UTF-8. Example: export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 After adding these lines, it is necessary to run source ~/.bash_profile or restart your shell. Testing your path for cocos It is necessary for cocos to be in your path or to specify the complete path to it when using it. An easy test: > cocos -v If you see output like 1.2 you are all set. If you see anything else you need to either add the location to your PATH. On macOS run source ~/.bash_profile after updating your PATH or specify the full path to \\tools\\cocos2d-console\\bin. Creating a new project To create a new project you use the cocos new command. The command is formatted as: cocos new -p -l -d Examples: cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany You can run cocos new --help to see even more options as well as platform specific options. Compiling a project As you make changes to your code it is necessary to compile it. We all know this has to happen, let's go through it. The command is formatted as: cocos compile -s -p -m -o Examples: cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin cocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bin cocos compile -s c:\\MyCompany\\MyGame -p win32 -m release -o c:\\MyCompany\\MyGame\\bin There is a lot going on here so let's go over the finer points. -p is the platform you are compiling for. -m is mode, debug or release with the default being debug if this parameter is not specified. Also, it is important to know that the -s and -o parameters are optional as well as long as you are already in your project's working directory. Taking the example above if you are already in ~/MyCompany/MyGame then the cocos compile command can be shortened: cocos compile . -p ios -m release You can also specify an optional parameter -q for quiet. This lessens the output that is outputted to the console. Taking an example from above: cocos compile -q -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin As cocos supports a lot of platforms there are also platform specific options which allow you to fine tune targeting specific SDK versions, signing code, lua options as well as web specific options. You can run cocos compile --help to see all available options broken down by platform. Android compiling could require specifying an API level. If you are compiling for Android, the cocos command is flexible and allows developers to compile using specific Android API versions. You may have Android-22 installed on your system (or any other version). You will want to add --ap android-api-version to the end of the cocos command to specify. Example: cocos compile -p android --ap android-22 You can always check project.properties to see what api-version is being targetted. For more info, please read out Release Notes. Running a project Once you have created a project you can run it right from the command-line. cocos takes care of launching the environment you specify. The command is formatted as: cocos run -s -p Examples: cocos run -s ~/MyCompany/MyGame -p ios cocos run -s ~/MyCompany/MyGame -p android cocos run -s c:\\MyCompany\\MyGame -p win32 You can also specify to run in debug or release mode using the optional -m parameter. Excluding this parameter defaults to debug. cocos run -s ~/MyCompany/MyGame -p ios -m release As with the cocos compile command above, it is important to know that the -s and -o parameters are optional as well as long as you are already in your project's working directory. Taking the example above if you are already in ~/MyCompany/MyGame then the cocos run command can be shortened: cocos run . -p ios -m release When running for the web there are additional parameters that allow you to specify what web browser you want to run in. You can also specify ip address and port. This, again is done via command-line parameters. Examples, specifying Google Chrome: cocos run -s ~/MyCompany/MyGame -p web -b /Applications/Google\\ Chrome.app cocos run -s ~/MyCompany/MyGame -p web -b C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe cocos run -s ~/MyCompany/MyGame -p web -b /usr/local/bin/chrome You can run cocos run --help to see all available options broken down by platform. Deploy a project Once you are ready to ship your game cocos provides an easy mechanism for deploying it. Just like with the commands above you specify what want to do. The command is formatted as: cocos deploy -s -p -m Examples: cocos deploy -s ~/MyCompany/MyGame -p ios -m release cocos deploy -s ~/MyCompany/MyGame -p android -m release cocos deploy -s c:\\MyCompany\\MyGame -p win32 -m release You can also specify an optional parameter -q for quiet. This reduces the output that is logged to the console. Taking an example from above: cocos deploy -q -s ~/MyCompany/MyGame -p ios -m release You can run cocos deploy --help to see all available options broken down by platform. Unique command-line options cocos has a number of unique options you can use to help build your games. To see all of these options, please run cocos --help. Let's us talk about these optios. Command Description no-apk compile without building an apk. luacompile Encrypt the lua scripts in your game. This is invoked once cocos compile is invoked with the -m release argument. Developers can invoke this manually for encrypting their scripts. jscompile Encrypt the JavaScript scripts in your game. This is invoked once cocos compile is invoked with the -m release argument. Developers can invoke this manually for encrypting their scripts. gen-simulator The simulator powers the preview function in Cocos Creator. "},"editors_and_tools/creator_to_cocos2dx.html":{"url":"editors_and_tools/creator_to_cocos2dx.html","title":"Creator to Cocos2d-x","keywords":"","body":"Using Cocos Creator With C++ and Lua Projects Cocos Creator supports JavaScript, built in. Edit your Scenes and source code all from within. However, If you are a C++ or Lua developer, Cocos Creator allows exporting of Scenes to sour code for further development. Why isn't C++ built in, you ask? There is no need to re-invent the wheel. There are many really good development environments out there. Writing a text editor is no trivial task. For this reason, it is best to allow developers to edit source code in the editor of their choice. What Is Supported? Cocos2d-x v3.14 and Cocos Creator v1.4 and above are required. If you find some Nodes are not supported, upgrading Cocos2d-x and Cocos Creator may add support for them. The following Nodes are supported. Node Node Node Node Node Scene Sprite Canvas ScrollView Label EditBox ParticleSystem TiledMap Button ProgressBar RichText SpineSkeleton Widget Animations VideoPlayer WebView Slider Toggle ToggleGroup PageView Mask Collider Prefab DragonBones Installing The Plugin Adding C++ and Lua language support to Cocos Creator is easy: clone the Creator To Cocos2d-x repo. from this repo, copy the creator_project/packages/creator_luacpp_support folder into your Creator project in packages. directory In the Project menu inside Creator a new menu option will appear LuaCPP Support. Plugin Setup To run the plugin: select Project -> LuaCPP Support -> Setup Target Project. It is required to tell Cocos Creator where to build all the necessary files. select Build. Always use the Build button to build your project before running it. The result is all the needed code and resources to drop into your external build system. C++ projects use these paths: source code: NATIVE_PROJECT_ROOT/Classes/reader resources: NATIVE_PROJECT_ROOT/Resources/creator LUA projects use these paths: source code: NATIVE_PROJECT_ROOT/frameworks/runtime-src/Classes/reader resources: NATIVE_PROJECT_ROOT/frameworks/runtime-src/Resources/Creator Moving from Creator to an external build system After using the Build function the source code and resources are exported to the filesystem. From here, you can use these items in an external build system. Header and Include search paths It is still necessary to set some header and include search paths. For C++: ```sh reader ``` For Lua: ```sh reader reader/collider reader/animation reader/dragonbones/cocos2dx reader/dragonbones/armature reader/dragonbones/animation reader/dragonbones/events reader/dragonbones/factories reader/dragonbones/core reader/dragonbones/geom ``` Android When developing for Android the Android.mk needs to be modified. There are a few simple lines to add, For C++: ```sh LOCAL_STATIC_LIBRARIES += creator_reader # _COCOS_LIB_ANDROID_BEGIN # _COCOS_LIB_ANDROID_END $(call import-module, ./../../Classes/reader) # import module path ``` For Lua: ```sh # for lua include $(CLEAR_VARS) LOCAL_MODULE := creator_reader_lua LOCAL_MODULE_FILENAME := libcreatorreaderlua LOCAL_ARM_MODE := arm LOCAL_SRC_FILES := $(cpp_src) \\ lua-bindings/creator_reader_bindings.cpp \\ lua-bindings/reader/lua_creator_reader_auto.cpp \\ lua-bindings/reader/lua_creator_reader_manual.cpp \\ lua-bindings/dragonbones/lua_dragonbones_manual.cpp \\ lua-bindings/dragonbones/lua_dragonbones_auto.cpp LOCAL_STATIC_LIBRARIES += creator_reader_lua # _COCOS_LIB_ANDROID_BEGIN # _COCOS_LIB_ANDROID_END $(call import-module, ./../../Classes/reader) ``` Example Usage Once everything is done, you can add code to tie everything together. It's elegant and simple: For C++ projects, just 1 step: // mygame.cpp #include \"reader/CreatorReader.h\" void some_function() { creator::CreatorReader* reader = creator::CreatorReader::createWithFilename(\"creator/CreatorSprites.ccreator\"); // will create the needed spritesheets + design resolution reader->setup(); // get the scene graph Scene* scene = reader->getSceneGraph(); // ...and use it Director::getInstance()->replaceScene(scene); } For Lua projects, require 2 steps: register the creator reader bindings #include \"reader/lua-bindings/creator_reader_bindings.hpp\" ... register_creator_reader_manual(L); add code to access the exported files. local creatorReader = creator.CreatorReader:createWithFilename('creator/CreatorSprites.ccreator') creatorReader:setup() local scene = creatorReader:getSceneGraph() cc.Director:getInstance():replaceScene(scene) How to use ColliderManager ColliderManager is used to manage collisions. Every Scene has an instance of ColliderManager. You can use it to listen for collision events: creator::CreatorReader* reader = creator::CreatorReader::createWithFilename(\"creator/CreatorSprites.ccreator\"); // will create the needed spritesheets + design resolution reader->setup(); // get the scene graph Scene* scene = reader->getSceneGraph(); auto colliderManager = scene->getColliderManager(); colliderManager->registerCollitionCallback([=](creator::Contract::CollisionType type, creator::Collider* collider1, creator::Collider* collider2) { if (type == creator::Contract::CollisionType::ENTER) colliderManager->enableDebugDraw(true); if (type == creator::Contract::CollisionType::EXIT) colliderManager->enableDebugDraw(false); }, \"\"); To read about additional features of ColliderManager, refer to the header file. "},"tutorials/":{"url":"tutorials/","title":"Tutorials","keywords":"","body":"Cocos2d-x Mini Tutorials Get started with particular areas of the Cocos Engine by reading any one our mini tutorials. Storing Game Data "},"tutorials/storing-game-data/":{"url":"tutorials/storing-game-data/","title":"Storing Game Data","keywords":"","body":"Storing Game Data In most every game there are probably items that need to be stored and re-read in again between game play. This could be player information, stats, leaderboards, level progress and so much more. As always there are many ways a developer can choose to store this data. Each approach has advantages and disadvantages. In this tutorial we will explore storing game data with UserDefault and SQLite. UserDefault UserDefault is simple key/value pair data structure. It is a global singleton that can be accessed at any time, much like the Director. UserDefault is always present, even if you never invoke it. It is just empty. The first time you add a key/value pair an instance is created. Accessing UserDefault Accessing UserDefault is as simple as: cocos2d::UserDefault::getInstance()->someFunction(); However, if you plan to access UserDefault more than once, it is best to grab the instance once and then use it versus accessing it each and every time you need it. Example: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setIntegerForKey(\"score\", 10); Adding values to UserDefault Adding key/value pairs to UserDefault is easy: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setIntegerForKey(\"score\", 10); userdefaults->setFloatForKey(\"some_float\", 2.3f); userdefaults->setDoubleForKey(\"some_double\", 2.4); userdefaults->setBoolForKey(\"some_bool\", true); Changing values in UserDefault It may be necessary to change a key/value pair in UserDefault. Perhaps you are storing the players score and it needs to be updated. This is achieved by simply setting the value a second time. Example: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setStringForKey(\"message\", \"Hello Again\"); Deleting values to UserDefault Deleting key/value pairs from UserDefault is also easy: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->deleteValueForKey(\"message\"); userdefaults->deleteValueForKey(\"score\"); userdefaults->deleteValueForKey(\"some_float\"); userdefaults->deleteValueForKey(\"some_double\"); userdefaults->deleteValueForKey(\"some_bool\"); Resetting UserDefault If you wish to clear out UserDefault completely and start from scratch you can simple call: cocos2d::UserDefault::getInstance()->flush(); Assigning UserDefault value to Labels You probably will want to use values stored in UserDefault and assign them to Label objects for the players to see. You can achieve this with just a few lines of code. Example: char strTemp[256] = \"\"; std::string ret = UserDefault::getInstance()->getStringForKey(\"message\"); sprintf(strTemp, \"string is %s\", ret.c_str()); some_label->setString(strTemp); SQLite If your needs are more advanced than a simple key/value pair you can evaluate using a database to store and manipulate your game data. SQLite is a very popular and commonly used relational database. You can read more about SQLite on the SQLite website. Setting up SQLite Download the SQLite bundle that works for your needs. There are both source code and pre-compiled binary releases. If you use the source code release you can simply drop sqlite3.h and sqlite3.c into your source tree and use include to bring in SQLite. If you use pre-compiled binaries you will need to add this as part of your library search paths. Creating a database There are a few ways to create a new SQLite database. Shipping a default database If you download the SQLite CLI you can use the command-line to interact with SQLite and all of it's functionality. If you choose this approach you will need to ship your database with you game as you are not creating it in code. This method allows you to use less SQL code up front, making your coding a bit less. However, you will still need to use SQL code when your game needs to interact with the database. Programatically creating a database If you don't wish to ship a default/pre-populated database you can always create a new database on the first launch of the game and then check if the database exists on each subsequent launch. This approach means more code. We will cover this approach in the next sections. Working with SQLite programatically There are several working pieces that are needed to interact with any database, not just SQlite. Let's take a look at what they are: a connection to the database: You can either maintain a persistent database connection while you game is running or open and close the connection as needed. If you maintain a persistent database connection, if the dataase connection gets lost you will need to handle these type of error and re-connect (this is unlikely with SQLite). If you open and close as needed you always have a connection but if multiple parts of your game are doing this at the same time you may experience locking issues or database corruption. a database to work with: either ship one with your game or create one programatically on the first launch. In either case you will need to have a database to work with. populating the database with default values: either shipping a pre-populated database with your game or creating the default values on first launch. checking values from the database: reading data from the database to make decisions in your game. updating the database as values change: as values change, storing them for fuure use (as your game dictates) closing the database connection when it is not in use: this should be done with both a persistent connection and opening a connection as needed. Failure to close the connection can result in data-loss. Use a Manager class? Using a singleton as a manager class might be a good option. This encapsulates all of the SQL functionality to a single place provided easy access to functions without a lot of mess. A singleton pattern helps provide a single(or global) instance of a class. You can read more about singleton patterns. A simple singleton may look something like this: c++ header: #ifndef _SQLMANAGER_H_ #define _SQLMANAGER_H_ #include #include class sqlite3; class SQLManager { public: static SQLManager* Instance(); virtual ~SQLManager() {} void initInstance(); bool connect(); bool isDatabasePopulated(); bool createDatabaseContents(); bool createMainTable(); inline bool getIsDatabaseReady() { return _bDatabaseReady; }; inline sqlite3*& getDatabase() { return _pdb; }; static int executeSelectQueryReturnSingleInt(const std::string& _sql); int getKeyByID(const std::string& _key, const std::string& _value); static std::string getSQLToCheckCounts(const std::string& _tableName); static void updateKey(const std::string& _key, const int& _value); private: SQLManager(); SQLManager(const SQLManager&); SQLManager& operator= (const SQLManager&); static SQLManager* pinstance; bool _bDatabaseReady = false; sqlite3* _pdb; std::string _dbFile = \"MyDatabase.db3\"; std::string _dbName = \"MyDatabase\"; std::string _dbPath; int _dbVersion = 1; // increment this when database structure changes }; #endif // _SQLMANAGER_H_ c++ source: #include \"SQLManager.hpp\" #include \"sqlite3.h\" #include \"cocos2d.h\" SQLManager* SQLManager::pinstance = 0; SQLManager::SQLManager() {} SQLManager* SQLManager::Instance() { if (pinstance == 0) { pinstance = new SQLManager; pinstance->initInstance(); } return pinstance; } void SQLManager::initInstance() { // what do we need to do when this class is instantiated? } bool SQLManager::connect() { // connecting to SQLite } bool SQLManager::isDatabasePopulated() { // is our database already populated? } bool SQLManager::createDatabaseContents() { // creating the database contents } bool SQLManager::createMainTable() { // creating the main table, but you may need more tables... } int SQLManager::executeSelectQueryReturnSingleInt(const std::string& _sql) { // returning an int as a result from a query } int SQLManager::getKeyByID(const std::string& _key, const std::string& _value) { // obtaining a key } std::string SQLManager::getSQLToCheckCounts(const std::string& _tableName) { // checking how many rows a table has } void SQLManager::updateKey(const std::string& _key, const int& _value) { // when we need to update data } This singleton class will continue to be used through the rest of this tutorial, adding to it as needed. There are arguments for why singleton patterns can be bad Creating a database To create a new database, it is best to see if an existing database already exists. If it does, it means your game has been played before on this device, no need to create a new one. Let's check for an existing database and if not create a new one using SQLManager::initInstance(), SQLManager::connect() and SQLManager::isDatabasePopulated(): void SQLManager::initInstance() { if (connect()) { if (isDatabasePopulated()) { // the database was found and is populated. } else { // a new database was created, so we need to pupulate it. } } else { // we failed to connect, handle this more gracefully for production!!! std::cout getWritablePath() + _dbFile; int result = sqlite3_open(_dbPath.c_str(), &_pdb); if(result == SQLITE_OK) { //std::cout The above code tries to open the specified database, at the specified path. If the file is already present, it opens, ig the file is not present it is still opened, but it would be empty. We don't know which! One solution is to check for the existence of a database table that would be present if your game has already been played. We will go into detail about this next. Before we do, let's make sure that we also understand that calling cocos2d::FileUtils::getInstance()->getWritablePath() will ensure that the path we get back is indeed the writeable path on this specific device. As operating systems handle this differently and also have different locations it is important that this call be made and it's return value be used. It is not advised to try and make custom locations outside what the device vendor wishes to allow. Populating a database As learned above, when trying to open a SQLite database, if it doesn't exist it will be created by the SQLite code. Therefore once you connect to the database, you don't know if the database already has data for your game or if this was the first time it is being played and therefore has zero data in it. You need to make this decision before proceeding because if the database doesn't have the data your game needs, your game fails immediately with errors and the player may never play it again because they think it is a broken or poorly made game. How might we go about doing this? Remember the unexplained call above to SQLManager::isDatabasePopulated()? Let's do the checking there and return true; if the database has previous data and return false; if it does not. If return false; then populating the database with default data is necessary. Consider this code which attepmpts to check for a table named Master to be present: bool SQLManager::isDatabasePopulated() { bool _bPopulated = false; sqlite3_stmt *statement; std::string _sql = \"SELECT count(*) FROM (SELECT * FROM sqlite_master UNION ALL SELECT * FROM sqlite_temp_master) WHERE type='table' AND name='\" + std::string(\"Master\") + std::string(\"' ORDER BY name LIMIT 1;\"); //std::cout If a table named Master exists, true will be returned and then we know we have a database that has been populated before this launch of the game. Meaning we don't need to populate it. We can continue on knowing our database is ready to read/write/update data. If a table named Master does not exist false is returned and this means we need to populate our database before using it. To do this we need to create tables with rows in them. It's hard to be specific here because each game requires unique data. However, the idea is to use the SQL CREATE TABLE command along with inserting a few rows: // a vector with what values to initially need in the Master table. const std::vector AppDBMasterTableID = {\"HighScore\", \"HighTime\", \"CurrentScore\", \"CurrentTime\", \"CurrentVersion\"}; //std::cout AppDBMasterTableValue = {0, 0, 0, 0, 1.0}; for (unsigned i = 0; i With this concept, next time the game starts a database will exist and have the default values that are needed. It wont be created every time the game is started. Any new data that is updated or inserted into the database will persist between launches! Querying data in the database After you have the database starting when the game starts and doing a quick integrity check to make sure it has the minimum necessary daya you will need to query the database from time to time to get values to make decisions. This might mean checking to see if the player beat a previous high score or if a player has beat a particular boss. Querying the database is an easy and common operation using the SQL SELLECT statement. Example: SELECT value from Master WHERE id=\"high score\"; SQLite is pretty flexible in getting back data and looping over it. Consider something like: std::string _sql = \"SELECT \" + std::string(value) + std::string(\" FROM \") + std::string(\"Master\") + std::string(\" WHERE _id='high score' LIMIT 1;\"); sqlite3_stmt* statement; if (sqlite3_prepare_v2(Instance()->getDatabase(), _sql, -1, &statement, 0) == SQLITE_OK) { int cols = sqlite3_column_count(statement); int result = 0; while(true) { result = sqlite3_step(statement); if(result == SQLITE_ROW) { for(int col = 0; col With this code the high score is returned as a string so that it can be used in a Label object. Note that since we are just selecting the value column we only iterate over just that column in the SQL table. Updating data in the database Updating works just the same as selecting data but with a different SQL statement format. A SQL UPDATE statement will be used instead. Consider: std::string _sql = \"UPDATE \" + std::string(\"Master\") + std::string(\" SET _value\") + std::string(\"=\") + std::to_string(10) + std::string(\" WHERE _id='high score';\"); //std::cout getDatabase(), _sql, NULL, NULL, NULL); if (result == SQLITE_OK) { std::cout In this example the high score is updated. Inserting new data into the database Inserting data is also easy and the format looks as familiar as the SQL SELECT and SQL UPDATE statements. Consider: std::string _sql = \"INSERT INTO \" + std::string(\"Master\") + std::string(\" VALUES ('15')\"); Closing the database connection While it isn't totally necessary to close a SQLite database, it is a good idea to play it safe and do so. Database corruption is possible if you don't. Consider closing the database where it makes sense in your code, possible on game exit. sqlite3_close(); "},"tutorials/youre-on-camera/":{"url":"tutorials/youre-on-camera/","title":"You're On Camera","keywords":"","body":"Smile, you're on camera! Yes, exactly like that! Just like using a camera to shoot your friends having fun at a party, you can use similar concepts to what you already intuitively know, to add camera functionality to your game. Why could a camera be important? It gives dimension to a 2D game and is required for 3D games. You couldn't have a true 3D game without a camera (although you can fake to a certain extent with art). In a 2D game a camera could add functionality like a mini-map. The basics of using a camera There are a few basic points to know when getting started using a Camera object. There are 2 types of cameras: perspective camera and orthographic camera. Perspective camera can be thought of as how we see every day objects...near and far. Orthographic camera can be thought of as a flat, top down view to a Scene. Every Scene automatically creates a default camera, based on the projection properties of the Director object. For more detailed information, please review the camera documentation. Getting Started Creating a demo project The easiest thing to do is to run cocos new CameraDemo -l cpp -d . to create a new Cocos project. We can re-use the default HelloWorldScene class to get us started. Housekeeping First, to be sure, let's create a few variables to help us with screen size and then quickly navigate around the screen as needed. Example, using origin and visibleSize that are already defined in the default class: cocos2d::Vec2 centerPosition = cocos2d::Vec2(visibleSize.width / 2.f, visibleSize.height / 2.f); cocos2d::Vec2 leftPosition = cocos2d::Vec2(visibleSize.width / 4.f, visibleSize.height / 2.f); cocos2d::Vec2 rightPosition = cocos2d::Vec2((visibleSize.width / 2.f + visibleSize.width / 4.f), visibleSize.height / 2.f); Second, let's create a few Sprite objects to use in our Scene. Maybe just two: /* Creatingthe sprites */ /* Sprite 1 */ auto alien1 = Sprite::create(\"Blue_Front1.png\"); alien1->setPosition(leftPosition); this->addChild(alien1); /* Sprite 2 */ auto alien2 = Sprite::create(\"White_Front1.png\"); alien2->setPosition(rightPosition); this->addChild(alien2); Creating a camera You can create as many Camera objects as you need although it is wise to use care and consider the task at hand before creating many Camera objects to handle tasks other methods are better suited to handle. "},"faq/":{"url":"faq/","title":"FAQ of Solutions","keywords":"","body":"F.A.Q Of Commonly Asked Technical Questions Android CMake Linux MacOS Windows "},"faq/android.html":{"url":"faq/android.html","title":"Android","keywords":"","body":"Android generateJsonModelDebug FAILED To solve this issue, please import the project into Android Studio, click Build/Refresh Linked C++ Projects. Android Studio uses the ninja build system Android Studio, itself, uses ninja to build native codes. There is ninja binary under Cmake folder. If Android Studio cannot find ninja on Windows, it is the Android Studio issue. You should set an environment variable that specifies the path to ninja: ninja binaries are available as is ninja documentation. "},"faq/cmake.html":{"url":"faq/cmake.html","title":"CMake","keywords":"","body":"CMake CMake PIE It may be necessary to add the following line to CMakeLists.txt if a can not be used when making a PIE object; compiler is thrown: set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -no-pie -fexceptions -std=c++11 -Wno-deprecated-declarations -Wno-reorder\") "},"faq/linux.html":{"url":"faq/linux.html","title":"Linux","keywords":"","body":"Linux FMOD issues Some users report issues with libfmod. If you encounter issues, please reference this post: Error while building for linux: libfmod.so.6 CMake PIE It may be necessary to add the following line to CMakeLists.txt if a can not be used when making a PIE object; compiler is thrown: set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -no-pie -fexceptions -std=c++11 -Wno-deprecated-declarations -Wno-reorder\") "},"faq/macos.html":{"url":"faq/macos.html","title":"MacOS","keywords":"","body":"MacOS XCode PNG Compression issue It is possible that your PNG images contain incorrect color profiles. You can convert color profiles using ImageMagick and the following command: find . -type f -name \"*.png\" -exec convert {} \\; "},"faq/windows.html":{"url":"faq/windows.html","title":"Windows","keywords":"","body":"Windows Re-target the Windows SDK If you see these types of errors: This is because the template project was created in an older version of Visual Studio. To fix: Right click on every project select Retarget Projects click Ok. Next, rebuild the project. If you create a new project in the future you will need to repeat these steps. Distributing a Cocos2d-x app on Windows If you try to run a game created with Cocos2d-x on a non-development machine, it may be required for this machine to have the Visual Studio runtime installed. The easiest way is to create an installer for your game, but it is possible to do it without by installing all required pieces manually. Use Dependency Walker to check what DLLs your game requires. Install the required Visual Studio runtime. Microsoft has now merged VS2015, 2017 and 2019 runtimes into one, which you can find here. For the installer, check these posts: InnoSetup (also shows you a sample for how to install the VS C++ runtime using it). Sample InnoSetup script for Cocos2d-x here. Distributing a Cocos2d-x app on Windows Note: this falls outside of the realm of Cocos2d-x. Please consult Microsoft resources for assistance. If you try to run a game created with Cocos2d-x on a non-development machine, it may be required for this machine to have the Visual Studio runtime installed. The easiest way is to create an installer for your game, but it is possible to do it without by installing all required pieces manually. Use Dependency Walker to check what DLLs your game requires. Install the required Visual Studio runtime. Microsoft has now merged VS2015, 2017 and 2019 runtimes into one, which you can find here. For the installer, check these posts: InnoSetup (also shows you a sample for how to install the VS C++ runtime using it). Sample InnoSetup script for Cocos2d-x here. "}}