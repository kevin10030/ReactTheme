{"./":{"url":"./","title":"了解引擎","keywords":"","body":"Cocos2d-x v3 用户手册 Q3 2019 r.2 ======= 欢迎使用 Cocos2d-x 用户手册，本手册包含引擎的介绍，功能组件的使用方法以及引擎在多个平台的环境搭建。能够帮助您快速上手 Cocos2d-x！ 特别推荐 Cocos2d-x 3.17 已发布，请参阅 版本发布说明。 3.17 支持全平台的 CMake 构建，请参阅 CMake 指南 快速上手 手册通过四个部分向您介绍 Cocos2d-x：新手入门部分，可以了解到 Cocos2d-x 引擎是什么、如何学习引擎、如何参与引擎开发，以及引擎中一些基本的概念；基本功能部分，着重介绍引擎中一些基础同时核心的组件如何使用，包括精灵、动作、场景。 进阶内容部分，是对引擎更近一步的阐述，包含如何进行一些高级控制、显示一些特殊效果；环境与工具部分，包含详细的开发环境搭建教程，以及一些引擎可利用的工具，比如使用 cocos 命令行。以下是手册的章节索引，可以帮助您快速定位。 新手入门：了解引擎 / 基本概念 基本功能：精灵 / 动作 / 场景 / UI 组件 进阶内容：特殊节点对象 / 事件分发机制 / 3D 支持 / 使用脚本 / 物理引擎 / 音乐和音效 / 高级话题 环境与工具：环境搭建 / 引擎工具 在手册的使用过程中，您大可不必按照目录的顺序，一章一章的阅读，完全可以跳跃，比如阅读完新手入门部分后，直接进入环境搭建章节，按照教程在自己 PC 上搭建好开发环境，完成后，一边看源码一边看手册，或许这样能有更好的学习效果。您也可以把本文档当做一个查询手册，将你想查询的直接输入到左上角的全局搜索框，回车一下，结果将立刻显现在页面中。 致谢 感谢 Cocos2d-x 的所有开发者，是你们让这个文档有了存在的意义！ 本文档主要翻译自英文文档，同时参考了旧有的 Cocos2d-x 中文文档。由于引擎内容较多，逻辑较复杂，文档可能会存在一些不完善之处。在您阅读的过程中，如果发现了错误的地方，欢迎通过 中文社区，或右下角 Have Feedback 向我们反馈。 本文档示例代码在 GitHub 下载 "},"about/getting_started.html":{"url":"about/getting_started.html","title":"About Cocos2d-x","keywords":"","body":"Where to get Cocos2d-x and what do I get? You can clone the GitHub Repo and follow the steps in the README. You can also download as part of the Cocos package on our download page. No matter if you choose to develop in C++, JavaScript or Lua, everything you need is in one package. The Cocos family of products has a few different pieces. Cocos2d-x - this is the game engine, itself. It includes the engine and the cocos command-line tool. You can download a production release or stay bleeding edge by cloning our GitHub Repo. Cocos Creator - is a unified game development tool. You can create your entire game, from start to finish, using this tool. It uses JavaScript natively and can export to C++. Read more about Cocos Creator. Cocos Launcher - is EOL'd. No replacement. Coco Studio - is EOL'd and has been replaced by Cocos Creator. Code IDE - is EOL'd. Common text editors and IDE's can be used instead. Conventions used in this documentation auto is used for creating local variables. using namespace cocos2d; is used to shorten types. each chapter has a compilable source code sample to demonstrate concepts. class names, methods names and other API components are rendered using fixed fonts. eg: Sprite. italics are used to notate concepts and keywords. "},"about/why.html":{"url":"about/why.html","title":"Why Cocos2d-x","keywords":"","body":"Why choose Cocos2d-x Why would you want to choose Cocos2d-x over other available game engines? Modern C++ API (please refer to the modernizing done in version 3.0) Cross-platform - desktop and mobile Capability to test and debug your game on the desktop and then push it to a mobile or desktop target A vast API of functionality including sprites, actions, animations, particles, transitions, timers, events (touch, keyboard, accelerometer, mouse), sound, file IO, persistence, skeletal animations, 3D "},"about/learn.html":{"url":"about/learn.html","title":"学习资源","keywords":"","body":"学习资源 官方资源 本文档就是最好的入门学习资源，其它一些有用的资源如下： Cocos官网 中文社区 引擎官方测试项目 测试项目的编译和运行在 环境搭建章节 介绍 网络资源 zilongshanren.com/categories/Cocos2d-x/ learnopengl-cn.github.io/ github.com/fusijie/Cocos-Resource "},"about/help.html":{"url":"about/help.html","title":"获取帮助","keywords":"","body":"获取帮助 在 Cocos2d-x 的使用过程中，您可以通过下面的方式获取帮助： Cocos 中文社区 Cocos2d-x GitHub API 编程接口 Cocos引擎官方微博 "},"about/how.html":{"url":"about/how.html","title":"参与开发","keywords":"","body":"参与开发 参与文档开发 期待您也能和我们一起参与到文档的完善中，参与方法： Fork 文档仓库 cocos2d-x-docs en/ 目录对应英文文档, zh/ 目录对应中文文档。 代码块要以一种特殊的方式包裹，例如 C++ 代码块: 包裹方法： 最终效果： auto mySprite = Sprite::create(\"mysprite.png\", Rect(0,0,40,40)); 使用 gitbook serve 命令测试改动在 GitBook 中的效果 提交 pull request 到 cocos2d/cocos2d-x-docs 仓库 我们会 review 这个 pull request 并 merge 参与引擎开发 使用 Cocos2d-x 的过程中，对于一般的问题，欢迎通过 论坛 向我们反馈。对于明确是 BUG 的，请参照下述方法反馈。 反馈 BUG 在 Cocos2d-x 的使用过程中，遇到 BUG 可以通过下面的方式在 GitHub 上向我们反馈。 新建 Cocos2d-x 的 Issues，传送门 增加一些必要的信息，帮助开发者定位修复 BUG BUG 出现的环境, Cocos2d-x 的版本，如 3.16 使用的 IDE，如 Xcode 8.3.3 测试设备，如 iPhone 7 BUG 的重现步骤 如果有和 BUG 相关的其它信息，也可以一并提交，如 资源链接 贡献代码 Cocos2d-x 在 GitHub 开源，你可以通过下面的方式贡献自己的代码，成为 Cocos2d-x 的贡献者。 从 GitHub 克隆最新的开发分支到本地 git clone git://github.com/cocos2d/cocos2d-x.git cd cocos2d-x git checkout v3 ./download-deps.py git submodule update --init 把代码改动添加到最新的开发分支 将改动提交到自己的代码仓库中 为本次代码提交创建一个新分支 如：$ git checkout -b my_fix_branch push 新分支到自己的 GitHub 公共仓库 创建一个 Pull request 给 cocos2d/cocos2d-x 改动一定要完善，并且符合发布规则，参考下面： 补丁要求 C++ 代码遵循 代码风格 Python 代码遵循 代码风格 描述补丁的功能 包括测试用例（如果适用） 包括单元测试（如果适用） 必须在所有支持的平台上进行测试 [*] 不得降低性能 不得破坏现有测试用例 不得破坏持续集成的构建 不能破坏向后的兼容性 编译必须无错误,无告警 新的 API 必须易于使用 代码必须易于扩展和维护 C ++ API 需要按照 Doxygen 注释规范注释 必须有一个描述如何使用该工具的 README.md 文件(补丁是工具) 必须高效（快/低内存需求） 不能重复现有的代码 重构关键组件的补丁只能在下一个主要版本中合并 [*]：如果您无法在所有支持的平台中测试代码，请告知我们。 宣传 Cocos2d-x 当您使用 Cocos2d-x 开发了游戏，希望您能将 Cocos2d-x 的 Logo 放到游戏中，或者把 Cocos2d-x 加到致谢中。让我们一起提高 Cocos2d-x 的知名度，让更多的人参与到 Cocos 开源社区的建设中。 Cocos2d-x Logo 资源 "},"basic_concepts/":{"url":"basic_concepts/","title":"基本概念","keywords":"","body":"基本概念 本章假设您刚刚开始使用 Cocos2d-x，准备开始你的游戏开发之旅。不要因为自己是新手而担心，整个学习过程会很有趣。 让我们开始！ 游戏引擎是一种特殊的软件，它提供游戏开发时需要的常见功能；引擎会提供许多组件，使用这些组件能缩短开发时间，让游戏开发变得更简单；专业引擎通常会能比自制引擎表现出更好的性能。游戏引擎通常会包含渲染器，2D/3D 图形元素，碰撞检测，物理引擎，声音，控制器支持，动画等部分。 Cocos2d-x 就是这样的一个游戏引擎，它提供了许多易于使用的组件，有着更好的性能，还同时支持移动端和桌面端。Cocos2d-x 通过封装底层图形接口提供了易用的API，降低了游戏开发的门槛，让使用者可以专注于开发游戏，而不用关注底层的技术细节。更重要的是 Cocos2d-x 是一个完全开源的游戏引擎，这就允许您在游戏开发过程中根据实际需要，定制化引擎的功能，如果您想要一个功能但又不知如何修改，提出这个需求，全世界的开发者可以一起为您完成。 只使用 Cocos2d-x 引擎，你就能完成一款游戏的开发，因为 Cocos2d-x 提供了游戏开发所需的一切。 组件简介 精通 Cocos2d-x 很难，但是上手 Cocos2d-x 很容易，让我们从一些基本概念开始。 下面是一个简单的游戏界面: 让我们再来看一下，分解这个游戏界面的组件构成。 能看到一个菜单(Menu)，几个精灵(Sprite)，和几个标签(Label)，观察一下喜欢的游戏，会发现这些组件以某种形式存在其中。 "},"basic_concepts/getting_started.html":{"url":"basic_concepts/getting_started.html","title":"Main Components","keywords":"","body":"Main Components It might seem overwhelming at first, but getting started with Cocos2d-x is simple. Before we dive into depth we must understand some of the concepts Cocos2d-x utilizes. At the heart of Cocos2d-x are Scene, Node, Sprite, Menu and Action objects. Look at any of your favorite games, and you will see all of these components in one form or another! Let's have a look. This might look a bit similar to a very popular game you might have played: Let's take another look, but splitting up the screenshot and identifying the components used to build it: You can see a menu, some sprites and labels, which all have an equivalent in Cocos2d-x. Take a look at a few of your own game design documents, and see what components you have, you'll probably have a few that match up. Let's Build A Game - Step 2 From the previous step, you now have a working Cocos2d-x project created FirstGame. This is good, it allows you to verify that your development environment is working. However, it also lets you see what code starts the game and how some basic decisions are made when the game starts. Let's take a look at a few of these Classes to gain some understanding. Cross-platform code is stored in the Classes/ directory while platform dependent code is stores in a folder for each platform, i.e proj.android, proj.ios_mac, proj.linux, proj.win32. AppDelegate AppDelegate is a very important class. AppDelegate is called once all the platform dependent code is run. The magic starts here! Take a look at it. Let's discuss a few key pieces! Design resolution - help to determine how large or small to design your Sprite objects (and much more). This is based upon the screen size of the device the game is running on. Because of this, it is always best to test your game on several devices of different screen resolution. Here is the relevant piece from AppDelegate: static cocos2d::Size designResolutionSize = cocos2d::Size(480, 320); static cocos2d::Size smallResolutionSize = cocos2d::Size(480, 320); static cocos2d::Size mediumResolutionSize = cocos2d::Size(1024, 768); static cocos2d::Size largeResolutionSize = cocos2d::Size(2048, 1536); AppDelegate::applicationDidFinishLaunching() - this is the main place you will start coding your game. This function does a lot for you already, but it may require tweaking, according to your needs. Consider the following lines where the first Scene is loaded and run, using the HelloWorld class: // create a scene. it's an autorelease object auto scene = HelloWorld::createScene(); // run director->runWithScene(scene); Making a few code changes So that we can get started making this game a bit more personal, we can change the Title of the glView. This is a simple change, made in the AppDelegate class. Take a look (or use Find) for the following lines: if(!glview) { #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) || (CC_TARGET_PLATFORM == CC_PLATFORM_MAC) || (CC_TARGET_PLATFORM == CC_PLATFORM_LINUX) glview = GLViewImpl::createWithRect(\"FirstGame\", cocos2d::Rect(0, 0, designResolutionSize.width, designResolutionSize.height)); #else glview = GLViewImpl::create(\"FirstGame\"); #endif director->setOpenGLView(glview); } Notice where the code says: FirstGame. We can change this to Bubble Shooter. Make sure to change it in both places! This doesn't change the name of any IDE project names or directory names. Once you have this step done, keep on reading... Who is the Director? "},"basic_concepts/director.html":{"url":"basic_concepts/director.html","title":"导演(Director)","keywords":"","body":"导演(Director) Cocos2d-x 使用导演的概念，这个导演和电影制作过程中的导演一样！导演控制电影制作流程，指导团队完成各项任务。在使用 Cocos2d-x 开发游戏的过程中，你可以认为自己是执行制片人，告诉 导演(Director) 该怎么办！一个常见的 Director 任务是控制场景替换和转换。 Director是一个共享的单例对象，可以在代码中的任何地方调用。 这是一个典型的游戏流程实例。当您的游戏设计好时，Director 就负责场景的转换： 你是你的游戏的导演。你决定着发生什么，何时发生，如何发生。 "},"basic_concepts/scene.html":{"url":"basic_concepts/scene.html","title":"场景(Scene)","keywords":"","body":"场景(Scene) 在游戏开发过程中，你可能需要一个主菜单，几个关卡和一个结束场景。如何组织所有这些分开的部分？使用 场景(Scene) ！当你想到喜欢的电影时，你能观察到它是被分解为不同场景或不同故事线。现在我们对游戏开发应用这个相同的思维过程，你应该很容易就能想出几个场景。 来看一张熟悉的图片： 这是一个主菜单场景，这个场景是由很多小的对象拼接而成，所有的对象组合在一起，形成了最终的结果。场景是被 渲染器(renderer) 画出来的。渲染器负责渲染精灵和其它的对象进入屏幕。为了更好的理解这个过程，我们需要讨论一下 场景图。 场景图(Scene Graph) 场景图(Scene Graph)是一种安排场景内对象的数据结构，它把场景内所有的 节点(Node) 都包含在一个 树(tree) 上。(场景图虽然叫做\"图\"，但实际使用一个树结构来表示)。 听起来这好像很复杂，可能你会问，我为什么要关注这个技术细节，Cocos2d-x 值得我研究的这么深入吗？值得！这个对你真正了解渲染器是如何绘制场景的非常重要。 当你开发游戏的时候，你会添加一些节点，精灵和动画到一个场景中，你期望的是每一个添加的对象都能被正确的展示，可是如果有个对象没有被展示呢？可能你错误的把这个对象隐藏到背景中了。怎么办？别着急，这是个小问题，停下来，拿出一张纸，把场景图画出来，你肯定能很容易的发现错误。 既然场景图是一个树结构，你就能遍历它，Cocos2d-x 使用 中序遍历，先遍历左子树，然后根节点，最后是右子树。中序遍历下图的节点，能得到 A, B, C, D, E, F, G, H, I 这样的序列。 初步了解了场景图，让我们看一下这个游戏场景。 分解这个场景，看一下它有哪些元素，这些最终会被渲染为一个树。 另一点要考虑的是，z-order 为负的元素，z-order 为负的节点会被放置在左子树，非负的节点会被放在右子树。实际开发的过程中，你可以按照任意顺序添加对象，他们会按照你指定的 z-order 自动排序。 如上图，左侧的场景是由很多节点对象组成的，他们根据被指定的 z-order 相互叠加。在 Cocos2d-x 中，通过 Scene 的 addChild() 方法构建场景图. // Adds a child with the z-order of -2, that means // it goes to the \"left\" side of the tree (because it is negative) scene->addChild(title_node, -2); // When you don't specify the z-order, it will use 0 scene->addChild(label_node); // Adds a child with the z-order of 1, that means // it goes to the \"right\" side of the tree (because it is positive) scene->addChild(sprite_node, 1); 渲染时 z-order 值大的节点对象会后绘制，值小的节点对象先绘制。如果两个节点对象的绘制范围有重叠，z-order 值大的可能会覆盖 z-order 值小的。 "},"basic_concepts/sprites.html":{"url":"basic_concepts/sprites.html","title":"精灵(Sprite)","keywords":"","body":"精灵(Sprite) 不知你是否意识到，所有的游戏都有 精灵(Sprite) 对象，精灵是您在屏幕上移动的对象，它能被控制。你喜欢玩的游戏中主角可能就是一个精灵，我知道你在想是不是每个图形对象都是一个精灵，不是的，为什么? 如果你能控制它，它才是一个精灵，如果无法控制，那就只是一个节点(Node)。 看下面的图片，我们来指出一下，哪个是精灵(Sprite)，哪个是节点(Node)。 精灵在所有游戏中都很重要，每个游戏都有这样的情景：一个舞台，上面站着一个某种形式的主角，那主角就是精灵。Sprite 很容易被创建，它有一些可以被配置的属性，比如：位置，旋转角度，缩放比例，透明度，颜色 等等。 // This is how to create a sprite auto mySprite = Sprite::create(\"mysprite.png\"); // this is how to change the properties of the sprite mySprite->setPosition(Vec2(500, 0)); mySprite->setRotation(40); mySprite->setScale(2.0); // sets both the scale of the X and Y axis uniformly mySprite->setAnchorPoint(Vec2(0, 0)); 让我们举例说明每个属性的含义，思考下面不同截图中精灵的区别： 设置位置 mySprite->setPosition(Vec2(500, 0));： 现在这个精灵的位置就变成了，我们设置的新地方。 设置旋转角度 mySprite->setRotation(40);： 可以发现这个精灵已经被旋转了设置的角度 设置缩放比例 mySprite->setScale(2.0);： 看到了精灵的大小，由于我们设置缩放而变化了。 我们再来说一下 锚点(anchor point) ，所有的节点(Node)对象都有锚点值，Sprite 是 Node 的子类，自然也具有锚点。锚点是节点对象在计算坐标位置时的一个基准点。 以我们刚才的展示的精灵为例，设置锚点(0,0)： mySprite->setAnchorPoint(Vec2(0, 0)); 精灵的左下角就变为了 setPosition() 调用，计算坐标的基础。再看看其它的锚点效果： 注意每张图片中的红点，红点表示锚点的位置。 正如你所看到的那样，锚点对于确定节点对象的位置是非常有用的，你可以在你的游戏中动态的调整锚点值以实现你想要的效果。 现在我们可以静态调整精灵的各个方面，但是你要想这些属性按照时间自动变化该如何做呢? 继续阅读，很快你就会有答案。 "},"basic_concepts/actions.html":{"url":"basic_concepts/actions.html","title":"动作(Action)","keywords":"","body":"动作(Action) 创建一个场景，在场景里面增加精灵只是完成一个游戏的第一步，接下来我们要解决的问题就是，怎么让精灵动起来。动作(Action) 就是用来解决这个问题的，它可以让精灵在场景中移动，如从一个点移动到另外一个点。你还可以创建一个动作 序列(Sequence) ，让精灵按照这个序列做连续的动作，在动作过程中你可以改变精灵的位置，旋转角度，缩放比例等等。 在 代码示例 中，有对应的章节，执行效果是这样： 5s 后，精灵移动到了一个新的位置： Action 对象的创建： auto mySprite = Sprite::create(\"Blue_Front1.png\"); // Move a sprite 50 pixels to the right, and 10 pixels to the top over 2 seconds. auto moveBy = MoveBy::create(2, Vec2(50,10)); mySprite->runAction(moveBy); // Move a sprite to a specific location over 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50,10)); mySprite->runAction(moveTo); "},"basic_concepts/sequences.html":{"url":"basic_concepts/sequences.html","title":"序列(Sequence)","keywords":"","body":"序列(Sequence) 能在屏幕上移动精灵，是制作一个游戏所需的一切，是吗？不是的，至少要考虑一下如何执行多个 Action。Cocos2d-x 通过 序列(Sequence) 来支持这种需求。 顾名思义，序列就是多个动作按照特定顺序的一个排列，当然反向执行这个序列也是可以的，Cocos2d-x 能很方便的完成这项工作。 让我们来看一个通过序列控制精灵移动的例子： 创建 Sequence ： auto mySprite = Node::create(); // move to point 50,10 over 2 seconds auto moveTo1 = MoveTo::create(2, Vec2(50,10)); // move from current position by 100,10 over 2 seconds auto moveBy1 = MoveBy::create(2, Vec2(100,10)); // move to point 150,10 over 2 seconds auto moveTo2 = MoveTo::create(2, Vec2(150,10)); // create a delay auto delay = DelayTime::create(1); mySprite->runAction(Sequence::create(moveTo1, delay, moveBy1, delay.clone(), moveTo2, nullptr)); 这个例子执行了一个动作的 Sequence 序列，那要是想让所有的特定动作同时执行呢？Cocos2d-x 也支持！通过引擎中的 Spawn 对象，你能让多个动作同时被解析执行。可能不同动作的执行时间不一致，在这种情况下，他们不会同时结束。 auto myNode = Node::create(); auto moveTo1 = MoveTo::create(2, Vec2(50,10)); auto moveBy1 = MoveBy::create(2, Vec2(100,10)); auto moveTo2 = MoveTo::create(2, Vec2(150,10)); myNode->runAction(Spawn::create(moveTo1, moveBy1, moveTo2, nullptr)); 为什么要有同时执行多个动作的需求呢？当然是有原因的啦！比如你的游戏角色被电了，或者在关卡结束打 boss 的时候，想一想类似的场景. "},"basic_concepts/parent_child.html":{"url":"basic_concepts/parent_child.html","title":"节点关系","keywords":"","body":"节点关系 Cocos2d-x 的 节点关系，是被附属和附属的关系，就像数据结构中的父子关系，如果两个节点被添加到一个父子关系中，那么父节点的属性变化会被自动应用到子节点中。想一下处于父子关系中的精灵有什么特性。 这三个精灵被添加到了一个父子关系中，当父精灵(被其它精灵附属的精灵)设置了旋转角度之后，子精灵也会自动做同样的改变： auto myNode = Node::create(); // rotating by setting myNode->setRotation(50); 和旋转角度一样，如果你改变了父精灵的缩放比例，子精灵也会做同样的改变： auto myNode = Node::create(); // scaling by setting myNode->setScale(2.0); // scales uniformly by 2.0 需要注意的是，不是所有的父节点属性都会被自动应用到子节点，如改变父节点的锚点只会影响转换效果(比例缩放，位置变化，角度旋转，变形等)，不会影响子节点锚点，子节点的锚点总会是左下角 (0,0)。 "},"basic_concepts/logging.html":{"url":"basic_concepts/logging.html","title":"日志输出","keywords":"","body":"日志输出 有时，在你的游戏正在运行的时候，为了了解程序的运行过程或是为了查找一个 BUG，你想看到一些运行时信息，可以! 这个需求引擎已经考虑到了，使用 log() 可以把信息输出到控制台，这样使用： // a simple string log(\"This would be outputted to the console\"); // a string and a variable string s = \"My variable\"; log(\"string is %s\", s); // a double and a variable double dd = 42; log(\"double is %f\", dd); // an integer and a variable int i = 6; log(\"integer is %d\", i); // a float and a variable float f = 2.0f; log(\"float is %f\", f); // a bool and a variable bool b = true; if (b == true) log(\"bool is true\"); else log(\"bool is false\"); 对于使用 C++ 进行游戏开发的用户来说，可能想使用 std::cout 而不用 log()，实际上 log() 更易于使用，它格式化复杂的输出信息更简单。 "},"sprites/":{"url":"sprites/","title":"精灵(Sprite)","keywords":"","body":"精灵(Sprite) 之前我们提到，精灵是屏幕上移动的对象，它能被控制。你喜欢玩的游戏中主角可能就是一个精灵，我知道你在想是不是每个图形对象都是一个精灵，不是的，为什么? 如果你能控制它，它才是一个精灵，如果无法控制，那就只是一个节点(Node)。 准确的说，精灵(Sprite) 是一个能通过改变自身的属性：角度，位置，缩放，颜色等，变成可控制动画的 2D 图像。 "},"sprites/getting_started.html":{"url":"sprites/getting_started.html","title":"What are Sprites","keywords":"","body":"What are Sprites A Sprite is a 2D image that can be animated or transformed by changing its properties, including rotation, position, scale, color, etc. "},"sprites/creating.html":{"url":"sprites/creating.html","title":"精灵创建","keywords":"","body":"精灵的创建 可以使用一张图像来创建精灵，PNG, JPEG, TIFF, WebP, 这几个格式都可以。当然也有一些其它的方式可以创建精灵，如使用 图集 创建，通过 精灵缓存 创建，我们会一个一个的讨论。本节介绍通过图像创建精灵。 使用图像创建 Sprite 能用一个特定的图像去创建: auto mySprite = Sprite::create(\"mysprite.png\"); 上面直接使用了 mysprite.png 图像来创建精灵。精灵会使用整张图像，图像是多少的分辨率，创建出来的精灵就是多少的分辨率。比如图像是 200 x 200，Sprite 也是 200 x 200。 使用矩形 上一个例子，精灵和原始图像的尺寸一致。但是如果你想创建一个尺寸只有原始图像一部分的精灵，那你可以在创建的时候指定一个矩形，指定矩形需要四个值，初始 x 坐标，初始 y 坐标，矩形宽，矩形高。 auto mySprite = Sprite::create(\"mysprite.png\", Rect(0,0,40,40)); 矩形的初始坐标，从图形的左上角开始算，即左上角的坐标是 (0, 0)，不是从左下角。因此结果精灵是图像左上角的一小块，从左上角开始算起，40 x 40 的大小。 如果你没指定一个矩形，Cocos2d-x 引擎就会自动使用这个图像全部的宽和高，看下面的例子，如果你把矩形的宽高指定为图像的宽高，矩形的初始坐标指定为 (0, 0)，那这就和第一种情况的效果是完全一样的。 auto mySprite = Sprite::create(\"mysprite.png\"); auto mySprite = Sprite::create(\"mysprite.png\", Rect(0,0,200,200)); "},"sprites/spritesheets.html":{"url":"sprites/spritesheets.html","title":"使用图集","keywords":"","body":"使用图集 图集(Sprite Sheet) 是通过专门的工具将多张图片合并成一张大图，并通过 plist 等格式的文件索引的资源，使用图集比使用多个独立图像占用的磁盘空间更少，还会有更好的性能。这种方式已经是游戏行业中提高游戏性能的标准方法之一。 在使用图集时，首先将其全部加载到 SpriteFrameCache 中，SpriteFrameCache 是一个全局的缓存类，缓存了添加到其中的 SpriteFrame 对象，提高了精灵的访问速度。SpriteFrame 只加载一次，后续一直保存在 SpriteFrameCache 中。 示例： 单看这个图集，似乎很难分析出什么，让我们对比一下： 这就很容易看出来，它至少完成了将多个图像素材合为一个，同时减少了磁盘空间占用。 继续来看如何在代码中使用。 加载图集 获取到 SpriteFrameCache 的实例，把图集添加到实例中。 // load the Sprite Sheet auto spritecache = SpriteFrameCache::getInstance(); // the .plist file can be generated with any of the tools mentioned below spritecache->addSpriteFramesWithFile(\"sprites.plist\"); 这样我们就完成了，将一个图集添加到 SpriteFrameCache 中，现在我们就能利用这个对象创建精灵了！ 创建图集 手动创建图集资源是一个单调乏味的过程，幸运的是有一些工具能帮助我们自动创建，下面是推荐的几个工具： Texture Packer Zwoptex ShoeBox Sprite Sheet Packer 其中 Texture Packer 有一个专门为 Cocos2d-x 写的图集创建指南。传送门 "},"sprites/spriteframe_cache.html":{"url":"sprites/spriteframe_cache.html","title":"使用精灵缓存","keywords":"","body":"使用精灵缓存 精灵缓存是 Cocos2d-x 为了提高精灵的访问速度，提供的一个精灵的缓存机制。 我们可以创建一个精灵并把精灵放到精灵的缓存对象 SpriteFrameCache 中： // Our .plist file has names for each of the sprites in it. We'll grab // the sprite named, \"mysprite\" from the sprite sheet: auto mysprite = Sprite::createWithSpriteFrameName(\"mysprite.png\"); 相对的，我们也可以从精灵的缓存对象 SpriteFrameCache 访问一个精灵，访问方法是先从缓存对象中获取对应的 SpriteFrame，然后从 SpriteFrame创建精灵，方法： // this is equivalent to the previous example, // but it is created by retrieving the SpriteFrame from the cache. auto newspriteFrame = SpriteFrameCache::getInstance()->getSpriteFrameByName(\"Blue_Front1.png\"); auto newSprite = Sprite::createWithSpriteFrame(newspriteFrame); "},"sprites/manipulation.html":{"url":"sprites/manipulation.html","title":"精灵控制","keywords":"","body":"精灵的控制 在创建完精灵后，现在你能试着修改精灵的属性去控制它了。 创建精灵： auto mySprite = Sprite::create(\"mysprite.png\"); 锚点 锚点确定了精灵对象在计算坐标位置的一个基准点，这个点是精灵内部的点，锚点影响精灵的缩放，旋转，倾斜这种转换，不影响颜色，透明度这种属性。锚点使用的坐标系以左下角为原点 (0, 0)，在你设置锚点的值时，要注意到这一点。默认情况下，所有的节点对象锚点是 (0.5, 0.5)。 设置锚点： // DEFAULT anchor point for all Sprites mySprite->setAnchorPoint(0.5, 0.5); // bottom left mySprite->setAnchorPoint(0, 0); // top left mySprite->setAnchorPoint(0, 1); // bottom right mySprite->setAnchorPoint(1, 0); // top right mySprite->setAnchorPoint(1, 1); 观察下面的图，感受锚点对精灵位置的影响，红点是旁边精灵的锚点。 位置 精灵的位置受锚点影响，看一下这个具体是怎样的，以红线红点为环境参考，看精灵的不同位置。注意，我们设置了锚点值，精灵的位置变化了，我们并没有使用 setPosition() 方法设置精灵的位置。 当我们想设置一个精灵的位置时，主要是使用 setPosition() 方法，只有想改变精灵与基准坐标点的相对位置时，才考虑使用 setAnchorPoint() 设置锚点。 // position a sprite to a specific position of x = 100, y = 200. mySprite->setPosition(Vec2(100, 200)); 旋转 通过 setRotation() 方法，设置一个角度值可以控制精灵的旋转，正值精灵顺时针旋转，负值精灵逆时针旋转，默认位置的角度值是 0.0。 // rotate sprite by +20 degrees mySprite->setRotation(20.0f); // rotate sprite by -20 degrees mySprite->setRotation(-20.0f); // rotate sprite by +60 degrees mySprite->setRotation(60.0f); // rotate sprite by -60 degrees mySprite->setRotation(-60.0f); 缩放 通过 setScale() 方法控制精灵的缩放。可以控制精灵水平缩放，垂直缩放，也可以整体缩放。默认水平和竖直的缩放值都是 1.0。 // increases X and Y size by 2.0 uniformly mySprite->setScale(2.0); // increases just X scale by 2.0 mySprite->setScaleX(2.0); // increases just Y scale by 2.0 mySprite->setScaleY(2.0); 倾斜 通过 setSkewX() 控制精灵的倾斜度，可以控制精灵水平倾斜，竖直倾斜，或者水平竖直同时倾斜，默认水平和竖直的倾斜值都是 0.0。 // adjusts the X skew by 20.0 mySprite->setSkewX(20.0f); // adjusts the Y skew by 20.0 mySprite->setSkewY(20.0f); 颜色 通过 setColor() 控制精灵的颜色。将一个 RGB 值设置到 Color3B 对象，调用精灵的 setColor() ，就能完成精灵颜色的设置。RGB 是三个从 0-255 的值，三个值分别代表红绿蓝的颜色深度，数值越大，颜色越深。特别的 RGB(255, 255, 255) 是白色。如果你不想自己指定 RGB 的三个值，也可以使用 Cocos2d-x 提供的预定义颜色，比如: Color3B::White，Color3B::Red。 // set the color by passing in a pre-defined Color3B object. mySprite->setColor(Color3B::WHITE); // Set the color by passing in a Color3B object. mySprite->setColor(Color3B(255, 255, 255)); // Same as Color3B::WHITE 透明度 精灵的透明度可以通过 setOpacity() 传入一个特定的值来设置，这个值的范围是 0-255，数值越大透明度越低，255 代表完全不透明，0 代表完全透明。 // Set the opacity to 30, which makes this sprite 11.7% opaque. // (30 divided by 256 equals 0.1171875...) mySprite->setOpacity(30); "},"sprites/polygon.html":{"url":"sprites/polygon.html","title":"多边形精灵","keywords":"","body":"多边形精灵 多边形精灵(Polygon Sprite) 也是一个精灵，同样是为了展示一个可以被控制的图像，但是和普通精灵的区别是，普通精灵在绘图处理中被分为了两个三角形，多边形精灵则是被分为了一系列三角形。 为什么要使用多边形精灵 提高性能! 要深入分析这个是如何提高性能的，会需要很多和像素填充率有关的技术术语。幸好本节是入门性质的文档，能让大家理解多边形精灵比普通精灵性能好就可以了，不用讨论特定宽高矩形绘制时的性能问题。 注意左右两种情况的不同。 左侧，是一个典型的精灵绘制时的处理，精灵被处理成一个有两个三角形组成的矩形。 右侧，是一个多边形精灵绘制时的处理，精灵被处理成一系列小的三角形。 显然可以看到，右侧多边形精灵需要绘制的像素数量比左侧精灵需要的像素数量更小，但是由于划分了多个三角形出现了更多的顶点，由于在现代的图形处理中，一般绘制定点比绘制像素消耗的性能少。所以多边形精灵的性能更好，实际的测试结果也验证了这一点。 AutoPolygon AutoPolygon 是一个工具类，它可以在程序运行时，通过跟踪关键点和三角测量，将一个矩形图像划分成一系列小三角形块。 首先将图像资源传入 AutoPolygon 进行处理，然后我们使用它生成的对象进行精灵的创建就能得到多边形精灵。 // Generate polygon info automatically. auto pinfo = AutoPolygon::generatePolygon(\"filename.png\"); // Create a sprite with polygon info. auto sprite = Sprite::create(pinfo); "},"actions/":{"url":"actions/","title":"动作(Action)","keywords":"","body":"动作(Action) 动作(Action) 的功能就和字面含义一样，它通过改变一个 Node 对象的属性，让它表现出某种动作。动作对象能实时的改变 Node 的属性，任何一个对象只要它是 Node 的子类都能被改变。比如，你能通过动作对象把一个精灵从一个位置移动到另一个位置。 通过 MoveTo 和 MoveBy 方法: // Move sprite to position 50,10 in 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50, 10)); mySprite1->runAction(moveTo); // Move sprite 20 points to right in 2 seconds auto moveBy = MoveBy::create(2, Vec2(20,0)); mySprite2->runAction(moveBy); By 和 To 的区别 你能注意到，每一个动作都会有两个方法 By 和 To。两种方法方便你在不同的情况使用，By 算的是相对于节点对象的当前位置，To 算的是绝对位置，不考虑当前节点对象在哪。如果你想动作的表现是相对于 Node 当前位置的，就用 By，相对的想让动作的表现是按照坐标的绝对位置就用 To。看一个例子： auto mySprite = Sprite::create(\"mysprite.png\"); mySprite->setPosition(Vec2(200, 256)); // MoveBy - lets move the sprite by 500 on the x axis over 2 seconds // MoveBy is relative - since x = 200 + 500 move = x is now 700 after the move auto moveBy = MoveBy::create(2, Vec2(500, mySprite->getPositionY())); // MoveTo - lets move the new sprite to 300 x 256 over 2 seconds // MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of // where it is located now. auto moveTo = MoveTo::create(2, Vec2(300, mySprite->getPositionY())); // Delay - create a small delay auto delay = DelayTime::create(1); auto seq = Sequence::create(moveBy, delay, moveTo, nullptr); mySprite->runAction(seq); "},"actions/getting_started.html":{"url":"actions/getting_started.html","title":"What are Actions","keywords":"","body":"By and To, what is the difference? You will notice that each Action has a By and To version. Why? Because they are different in what they accomplish. A By is relative to the current state of the Node. A To action is absolute, meaning it doesn't take into account the current state of the Node. Let's take a look at a specific example: auto mySprite = Sprite::create(\"mysprite.png\"); mySprite->setPosition(Vec2(200, 256)); // MoveBy - lets move the sprite by 500 on the x axis over 2 seconds // MoveBy is relative - since x = 200 + 500 move = x is now 700 after the move auto moveBy = MoveBy::create(2, Vec2(500, mySprite->getPositionY())); // MoveTo - lets move the new sprite to 300 x 256 over 2 seconds // MoveTo is absolute - The sprite gets moved to 300 x 256 regardless of // where it is located now. auto moveTo = MoveTo::create(2, Vec2(300, mySprite->getPositionY())); // Delay - create a small delay auto delay = DelayTime::create(1); auto seq = Sequence::create(moveBy, delay, moveTo, nullptr); mySprite->runAction(seq); "},"actions/basic.html":{"url":"actions/basic.html","title":"基本动作","keywords":"","body":"基本动作 基本动作通常都是单一的动作，用来完成一个简单的目标。下面通过简单的示例来介绍常见的基本动作。 移动 使用 MoveTo MoveBy 完成节点对象在一个设置的时间后移动。 auto mySprite = Sprite::create(\"mysprite.png\"); // Move a sprite to a specific location over 2 seconds. auto moveTo = MoveTo::create(2, Vec2(50, 0)); mySprite->runAction(moveTo); // Move a sprite 50 pixels to the right, and 0 pixels to the top over 2 seconds. auto moveBy = MoveBy::create(2, Vec2(50, 0)); mySprite->runAction(moveBy); 旋转 使用 RotateTo RotateBy 完成节点对象在一个设置的时间后顺时针旋转指定角度。 auto mySprite = Sprite::create(\"mysprite.png\"); // Rotates a Node to the specific angle over 2 seconds auto rotateTo = RotateTo::create(2.0f, 40.0f); mySprite->runAction(rotateTo); // Rotates a Node clockwise by 40 degree over 2 seconds auto rotateBy = RotateBy::create(2.0f, 40.0f); mySprite->runAction(rotateBy); 缩放 使用 ScaleBy ScaleTo 完成节点对象的比例缩放。 auto mySprite = Sprite::create(\"mysprite.png\"); // Scale uniformly by 3x over 2 seconds auto scaleBy = ScaleBy::create(2.0f, 3.0f); mySprite->runAction(scaleBy); // Scale X by 5 and Y by 3x over 2 seconds auto scaleBy = ScaleBy::create(2.0f, 3.0f, 3.0f); mySprite->runAction(scaleBy); // Scale to uniformly to 3x over 2 seconds auto scaleTo = ScaleTo::create(2.0f, 3.0f); mySprite->runAction(scaleTo); // Scale X to 5 and Y to 3x over 2 seconds auto scaleTo = ScaleTo::create(2.0f, 3.0f, 3.0f); mySprite->runAction(scaleTo); 淡入淡出 使用 FadeIn FadeOut 完成节点对象的淡入，淡出。 FadeIn 修改节点对象的透明度属性，从完全透明到完全不透明，FadeOut \b相反。 auto mySprite = Sprite::create(\"mysprite.png\"); // fades in the sprite in 1 seconds auto fadeIn = FadeIn::create(1.0f); mySprite->runAction(fadeIn); // fades out the sprite in 2 seconds auto fadeOut = FadeOut::create(2.0f); mySprite->runAction(fadeOut); 色彩混合 使用 TintTo TintBy，将一个实现了 NodeRGB 协议的节点对象进行色彩混合。 auto mySprite = Sprite::create(\"mysprite.png\"); // Tints a node to the specified RGB values auto tintTo = TintTo::create(2.0f, 120.0f, 232.0f, 254.0f); mySprite->runAction(tintTo); // Tints a node BY the delta of the specified RGB values. auto tintBy = TintBy::create(2.0f, 120.0f, 232.0f, 254.0f); mySprite->runAction(tintBy); 帧动画 使用 Animate 对象可以很容易的通过每隔一个短暂时间进行图像替代的方式，实现一个翻页效果。下面是一个例子： auto mySprite = Sprite::create(\"mysprite.png\"); // now lets animate the sprite we moved Vector animFrames; animFrames.reserve(12); animFrames.pushBack(SpriteFrame::create(\"Blue_Front1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Front2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Front3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Left3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Back3.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right1.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right2.png\", Rect(0,0,65,81))); animFrames.pushBack(SpriteFrame::create(\"Blue_Right3.png\", Rect(0,0,65,81))); // create the animation out of the frames Animation* animation = Animation::createWithSpriteFrames(animFrames, 0.1f); Animate* animate = Animate::create(animation); // run it and repeat it forever mySprite->runAction(RepeatForever::create(animate)); 变速运动 变速动作可以让节点对象具有加速度，产生平滑同时相对复杂的动作，所以可以用变速动作来模仿一些物理运动，这样比实际使用物理引擎的性能消耗低，使用起来也简单。当然你也可以将变速动作应用到动画菜单和按钮上，实现你想要的效果。 Cocos2d-x 支持上图中的大部分变速动作，实现起来也很简单。我们来看个例子，一个精灵从屏幕顶部落下然后不断跳动： // create a sprite auto mySprite = Sprite::create(\"mysprite.png\"); // create a MoveBy Action to where we want the sprite to drop from. auto move = MoveBy::create(2, Vec2(200, dirs->getVisibleSize().height - newSprite2->getContentSize().height)); // create a BounceIn Ease Action auto move_ease_in = EaseBounceIn::create(move->clone() ); auto move_ease_in_back = move_ease_in->reverse(); // create a delay that is run in between sequence events auto delay = DelayTime::create(0.25f); // create the sequence of actions, in the order we want to run them auto seq1 = Sequence::create(move_ease_in, delay, move_ease_in_back, delay->clone(), nullptr); // run the sequence and repeat forever. mySprite->runAction(RepeatForever::create(seq1)); 复杂的动作很难在这样的文本里表示，要是看效果的话最好去运行一下本指南的 代码示例，或者运行引擎代码的测试项目 cpp-tests，在子菜单 3:Actions - Basic 中有基本的动作效果展示。 运行测试项目的方法，参考本文档的 环境搭建 章节 . "},"actions/sequences.html":{"url":"actions/sequences.html","title":"动作序列","keywords":"","body":"序列 动作序列(Sequence) 是一种封装多个动作的对象，当这个对象执行时被封装的动作会顺序执行。 一个 Sequence 可以包含任何数量的动作对象，回调方法和其它序列。可以包含回调方法? 没错! Cocos2d-x 允许把一个方法添加进去 CallFunc 对象，然后将 CallFunc 添加到 Sequence，这样，在执行序列的时候就能触发方法调用。因此，你能在一个序列中添加一些个性化的功能，而不仅仅是添加 Cocos2d-x 提供的有限动作。下面是一个序列的动作执行示意图： Sequence 示例 auto mySprite = Sprite::create(\"mysprite.png\"); // create a few actions. auto jump = JumpBy::create(0.5, Vec2(0, 0), 100, 1); auto rotate = RotateTo::create(2.0f, 10); // create a few callbacks auto callbackJump = CallFunc::create([](){ log(\"Jumped!\"); }); auto callbackRotate = CallFunc::create([](){ log(\"Rotated!\"); }); // create a sequence with the actions and callbacks auto seq = Sequence::create(jump, callbackJump, rotate, callbackRotate, nullptr); // run it mySprite->runAction(seq); 上面这个 Sequence 做了什么? 按照下面的顺序执行了每一个动作。 Jump -> callbackJump() -> Rotate -> callbackRotate() Spawn Spawn 和 Sequence 是非常相似的，区别是 Spawn 同时执行所有的动作。Spawn 对象可以添加任意数量的动作和其它 Spawn 对象。 Spawn 的效果和同时运行多个动作的 runAction() 方法是一致的，但是它的独特之处是 Spawn 能被放到 Sequence 中，结合 Spawn 和 Sequence 能实现非常强大的动作效果。 例如，创建两个动作： // create 2 actions and run a Spawn on a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); auto moveBy = MoveBy::create(10, Vec2(400,100)); auto fadeTo = FadeTo::create(2.0f, 120.0f); 使用 Spawn： // running the above Actions with Spawn. auto mySpawn = Spawn::createWithTwoActions(moveBy, fadeTo); mySprite->runAction(mySpawn); 同时调用方法 runAction()： // running the above Actions with consecutive runAction() statements。 mySprite->runAction(moveBy); mySprite->runAction(fadeTo); 上面两种方式产生的效果是一样的，现在看把一个 Spawn 添加到一个 Sequence 中是怎样的一种情景，动作的执行流程会看起来像这样： // create a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); // create a few Actions auto moveBy = MoveBy::create(10, Vec2(400,100)); auto fadeTo = FadeTo::create(2.0f, 120.0f); auto scaleBy = ScaleBy::create(2.0f, 3.0f); // create a Spawn to use auto mySpawn = Spawn::createWithTwoActions(scaleBy, fadeTo); // tie everything together in a sequence auto seq = Sequence::create(moveBy, mySpawn, moveBy, nullptr); // run it mySprite->runAction(seq); 运行本文档的 代码示例 去看一下效果吧! "},"actions/sequence_internals.html":{"url":"actions/sequence_internals.html","title":"动作的克隆和倒转","keywords":"","body":"动作的克隆 克隆(Clone) 的功能和字面含义一样，如果你对一个节点对象使用了 clone() 方法，你就获得了这个节点对象的拷贝。 为什么要使用 clone() 方法? 因为当 Action 对象运行时会产生一个内部状态，记录着节点属性的改变。当你想将一个创建的动作，重复使用到不同的节点对象时，如果不用 clone() 方法，就无法确定这个动作的属性到底是怎样的(因为被使用过，产生了内部状态)，这会造成难以预料的结果。 我们来看示例，假如你有一个坐标位置是 (0,0) 的 heroSprite，执行这样一个动作： MoveBy::create(10, Vec2(400,100)); 你的 heroSprite 就在 10s 的时间中，从 (0,0) 移动到了 (400,100)，heroSprite 有了一个新位置 (400,100)，更重要的是动作对象也有了节点位置相关的内部状态了。现在假如你有一个坐标位置是 (200,200)的 emenySprite。你还使用这个相同的动作，emenySprite 就会移动到 (800,200)的坐标位置，并不是你期待的结果。因为第二次将这个动作应用的时候，它已经有内部状态了。使用 clone() 能避免这种情况，克隆获得一个新的动作对象，新的对象没有之前的内部状态。 从代码中学习用法吧，先看看错误的情况： // create our Sprites auto heroSprite = Sprite::create(\"herosprite.png\"); auto enemySprite = Sprite::create(\"enemysprite.png\"); // create an Action auto moveBy = MoveBy::create(10, Vec2(400,100)); // run it on our hero heroSprite->runAction(moveBy); // run it on our enemy enemySprite->runAction(moveBy); // oops, this will not be unique! // uses the Actions current internal state as a starting point. 使用 clone() 的正确情况： // create our Sprites auto heroSprite = Sprite::create(\"herosprite.png\"); auto enemySprite = Sprite::create(\"enemysprite.png\"); // create an Action auto moveBy = MoveBy::create(10, Vec2(400,100)); // run it on our hero heroSprite->runAction(moveBy); // run it on our enemy enemySprite->runAction(moveBy->clone()); // correct! This will be unique 动作的倒转 倒转(Reverse) 的功能也和字面意思一样，调用 reverse() 可以让一系列动作按相反的方向执行。reverse() 不是只能简单的让一个 Action 对象反向执行，还能让 Sequence 和 Spawn 倒转。 倒转使用起来很简单： // reverse a sequence, spawn or action mySprite->runAction(mySpawn->reverse()); 思考下面这段代码在执行的时候, 内部发生了什么? // create a Sprite auto mySprite = Sprite::create(\"mysprite.png\"); mySprite->setPosition(50, 56); // create a few Actions auto moveBy = MoveBy::create(2.0f, Vec2(500,0)); auto scaleBy = ScaleBy::create(2.0f, 2.0f); auto delay = DelayTime::create(2.0f); // create a sequence auto delaySequence = Sequence::create(delay, delay->clone(), delay->clone(), delay->clone(), nullptr); auto sequence = Sequence::create(moveBy, delay, scaleBy, delaySequence, nullptr); // run it mySprite->runAction(sequence); // reverse it mySprite->runAction(sequence->reverse()); 思考起来可能有点困难，我们将执行的每一步列出来，或许能帮助你理解： mySprite 创建 mySprite 的坐标位置设置成(50,56) sequence 开始执行 sequence 执行第一个动作 moveBy，2s 中 mySprite 移动到了坐标位置(550,56) sequence 执行第二个动作， 暂停 2s sequence 执行第三个动作，scaleBy，2s 中 mySprite 放大了2倍 sequence 执行第四个动作，delaySequence，暂停 6s reverse() 被调用，序列倒转，开始反向执行 sequence 执行第四个动作，delaySequence，暂停 6s sequence 执行第三个动作，scaleBy，2s 中 mySprite 缩小了2倍 (注意：序列内的动作被倒转) sequence 执行第二个动作， 暂停 2s sequence 执行第一个动作 moveBy，2s 中 mySprite 从坐标位置 (550,56)，移动到了 (50, 56) mySprite 回到了最初的位置 我们能发现 reverse() 方法使用起来很简单，内部逻辑却一点都不简单。因为 Cocos2d-x 封装了复杂的逻辑，为你留下了简单易用的接口！ "},"scenes/":{"url":"scenes/","title":"场景(Scene)","keywords":"","body":"场景(Scene) 场景(Scene) 是一个容器，容纳游戏中的各个元素，如精灵，标签，节点对象。它负责着游戏的运行逻辑，以帧为单位渲染内容。 可以想象游戏就像一个电影，场景是观看者能看到的正在发生的情景。一个电影至少需要一个场景，一个游戏也至少需要一个 Scene。在使用 Cocos2d-x 进行游戏的开发中，你可以制作任意数量的场景，并在不同场景间轻松切换。 "},"scenes/getting_started.html":{"url":"scenes/getting_started.html","title":"What are Scenes?","keywords":"","body":"What is a Scene? A Scene is a container that holds Sprites, Labels, Nodes and other objects that your game needs. A Scene is responsible for running game logic and rendering the content on a per-frame basis. You need at least one Scene to start your game. You can think of this like a movie. The Scene is what is running and users see what is happening in real-time. You can have any number of Scene objects in your game and transition through them easily. Cocos2d-x provides scene transitions and you can even have scene transitions with cool effects. "},"scenes/creating.html":{"url":"scenes/creating.html","title":"场景创建","keywords":"","body":"场景创建 创建一个场景非常简单： auto myScene = Scene::create(); 还记得场景图吗 第二章中我们学到了 场景图(Scene Graph) 以及在游戏中它是如何生效的。要记得场景图决定了场景内节点对象的渲染顺序，也要记得 z-order 是如何影响场景图的。 渲染时 z-order 值大的节点对象会后绘制，值小的节点对象先绘制 一个简单场景 让我们构建一个简单的场景，来学习场景的使用。记得 Cocos2d-x 用右手坐标系，也就是说坐标原点(0,0)在展示区的左下角，当你在场景里放置一些节点对象设置坐标位置时，注意左下角是坐标计算的起点。 auto dirs = Director::getInstance(); Size visibleSize = dirs->getVisibleSize(); auto myScene = Scene::create(); auto label1 = Label::createWithTTF(\"My Game\", \"Marker Felt.ttf\", 36); label1->setPosition(Vec2(visibleSize.width / 2, visibleSize.height / 2)); myScene->addChild(label1); auto sprite1 = Sprite::create(\"mysprite.png\"); sprite1->setPosition(Vec2(100, 100)); myScene->addChild(sprite1); 当运行这个代码的时候，我们会看到有一个场景，场景里面有一个标签和一个精灵。这虽然很简单，但这却是开发一个游戏最重要的开始！ "},"scenes/transitioning.html":{"url":"scenes/transitioning.html","title":"场景切换","keywords":"","body":"场景切换 开始一个新游戏，改变关卡，或结束游戏时，为了给用户不同的效果呈现，大多需要切换不同的场景。Cocos2d-x 提供了一系列方式去做这件事情 场景切换。 场景切换的方式 有很多场景切换的方式，每种都有特定的方法，让我们来看看： auto myScene = Scene::create(); runWithScene() 用于开始游戏，加载第一个场景。只用于第一个场景！ Director::getInstance()->runWithScene(myScene); replaceScene() 使用传入的场景替换当前场景来切换画面，当前场景被释放。这是切换场景时最常用的方法。 Director::getInstance()->replaceScene(myScene); pushScene() 将当前运行中的场景暂停并压入到场景栈中，再将传入的场景设置为当前运行场景。只有存在正在运行的场景时才能调用该方法。 Director::getInstance()->pushScene(myScene); popScene() 释放当前场景，再从场景栈中弹出栈顶的场景，并将其设置为当前运行场景。如果栈为空，直接结束应用。 Director::getInstance()->popScene(); 场景切换的效果设置 在场景切换的过程中，你可以添加一些效果： auto myScene = Scene::create(); // Transition Fade Director::getInstance()->replaceScene(TransitionFade::create(0.5, myScene, Color3B(0,255,255))); // FlipX Director::getInstance()->replaceScene(TransitionFlipX::create(2, myScene)); // Transition Slide In Director::getInstance()->replaceScene(TransitionSlideInT::create(1, myScene) ); "},"ui_components/":{"url":"ui_components/","title":"UI 组件","keywords":"","body":"UI 组件 UI 组件不是游戏专用的，是个应用程序都可能会用几个。看一看你常使用的应用程序，肯定能发现它有使用 UI 组件。UI 代表什么，UI 组件是做什么的？ UI 代表用户界面，是 User Interface 的缩写，你看到的屏幕上的东西就是用户界面。界面组件有标签，按钮，菜单，滑动条等。Cocos2d-x 提供了一套易用的 UI 组件，游戏开发过程中，你能很容易的把它们添加到游戏中。 听起来这可能很简单，但创建像 标签(Label) 这样的核心类实际要考虑很多问题。可以想象创建一套自定义的组件是多么的困难！当然你根本没必要这样做，因为你需要的我们都考虑到了。 "},"ui_components/getting_started.html":{"url":"ui_components/getting_started.html","title":"Widgets","keywords":"","body":"Widgets, oh, my! UI is an abbreviation that stands for user interface. You know, things that are on the screen. This include items like: labels, buttons, menus, sliders and views. Cocos2d-x provides a set of UI widgets to make it simple to add these controls to your projects. It may sound trivial, but a lot goes in to creating a core class like a Label. There are so many aspects of just this one. Could you imagine having to write your own custom widget set? Don't worry, your needs are covered! setPosition(Vec2(0,0)); this->addChild(imageView); ``` It is also possible to create an `ImageView` from a `SpriteFrame`: ```cpp auto imageView = ImageView::create(\"ccicon.png\", TextureResType::PLIST); imageView->setPosition(Vec2(0,0)); this->addChild(imageView); ``` ## Text A `Text` widget is used for displaying text. It can also use it as a _text-only_ button. You can think of a `Text` widget as `Text` supports system font and TTF fonts. To create a `Text` widget: ```cpp auto text = Text::create(\"Text\",\"fonts/MyTTF.ttf\",30); this->addChild(text); ``` You can add effects like _shadow_, _glow_ and _outline_ just like any `Label` object. ### TextBMFont A `TextBMFont` widget is used for displaying `BMFont` text. It supports touch event, focus, percent positioning and percent content size. Creating a `TextBMFont` is list like the `Text` widget: ```cpp auto textBMFont = TextBMFont::create(\"BMFont\", \"bitmapFontTest2.fnt\"); textBMFont->setPosition(Vec2(0,0)); this->addChild(textBMFont); ``` #### TextAtlas A `TextAtlas` widget is used for displaying text as an _atlas font_. It supports touch event, focus, percent positioning and percent content size.\\ ```cpp auto textAtlas = TextAtlas::create(\"1234567890\", \"labelatlas.png\", 17, 22, \"0\"); textAtlas->setPosition(Vec2(0,0)); this->addChild(textAtlas); ``` #### RichText A `RichText` widget is used for displaying text, image and custom nodes. It supports touch event, focus, percent positioning and percent content size. When receiving a touch event the whole `RichText` widget receives the event. To create a `RichText` widget: ```cpp auto richText = RichText::create(); richText->ignoreContentAdaptWithSize(false); richText->setContentSize(Size(100, 100)); auto re1 = RichElementText::create(1, Color3B::WHITE, 255, str1, \"Marker Felt\", 10); richText->pushBackElement(re1); richText->setPosition(Vec2(0,0)); richText->setLocalZOrder(10); this->addChild(_richText); ``` --> "},"ui_components/labels.html":{"url":"ui_components/labels.html","title":"标签(Label)","keywords":"","body":"标签(Label) Cocos2d-x 提供 Label 对象给用户，可以使用位图字体，TrueType 字体，系统字体创建标签。这个单一的类能处理你所有的标签需求。下面介绍使用各种字体，创建标签的方法。 BMFont BMFont 是一个使用位图字体创建的标签类型，位图字体中的字符由点阵组成。使用这种字体标签性能非常好，但是不适合缩放。由于点阵的原因，缩放会导致失真。标签中的每一个字符都是一个单独的 Sprite，也就是说精灵的属性(旋转，缩放，着色等)控制都适用于这里的每个字符。 创建 BMFont 标签需要两个文件：.fnt 文件和 .png 文件。可以使用像 Glyph Designer 这样的工具来创建位图字体，这些文件将会自动生成。 使用位图字体创建标签： auto myLabel = Label::createWithBMFont(\"bitmapRed.fnt\", \"Your Text\"); 所有在标签中出现的字符都应该能在提供的 .fnt 文件找到，如果找不到，字符就不会被渲染。如果你渲染了一个 Label，同时它有丢失字符，记得去查看一下 .fnt 文件是否完备。 TTF TrueType 字体 和我们上面了解的位图字体不同，使用这种字体很方便，你不需要为每种尺寸和颜色单独使用字体文件。不像 BMFont，如果想不失真的缩放，就要提供多种字体文件。 要创建这种标签，需要指定 .ttf 字体文件名，文本字符串和字体大小。 使用 TrueType 字体创建标签： auto myLabel = Label::createWithTTF(\"Your Text\", \"Marker Felt.ttf\", 24); 虽然使用 TrueType 字体比使用位图字体更灵活，但是它渲染速度较慢，并且更改标签的属性(字体，大小)是一项非常消耗性能的操作。 如果您需要具有相同属性的多个 Label 对象，那可以创建一个 TTFConfig 对象来统一配置，TTFConfig 对象允许你设置所有标签的共同属性。 通过以下方式创建一个 TTFConfig 对象： // create a TTFConfig files for labels to share TTFConfig labelConfig; labelConfig.fontFilePath = \"myFont.ttf\"; labelConfig.fontSize = 16; labelConfig.glyphs = GlyphCollection::DYNAMIC; labelConfig.outlineSize = 0; labelConfig.customGlyphs = nullptr; labelConfig.distanceFieldEnabled = false; // create a TTF Label from the TTFConfig file. auto myLabel = Label::createWithTTF(labelConfig, \"My Label Text\"); TTFConfig 也能用于展示中文，日文，韩文的字符。 SystemFont SystemFont 是一个使用系统默认字体，默认字体大小的标签类型，这样的标签不要改变他的属性，它会使用系统的规则。 使用系统字体创建标签： auto myLabel = Label::createWithSystemFont(\"My Label Text\", \"Arial\", 16); 标签效果 在屏幕上有标签后，它们可能看起来很普通，这时你希望让他们变漂亮。你不用创建自定义字体! Label 对象就可以对标签应用效果，包括阴影，描边，发光。 阴影效果： auto myLabel = Label::createWithTTF(\"myFont.ttf\", \"My Label Text\", 16); // shadow effect is supported by all Label types myLabel->enableShadow(); 描边效果: auto myLabel = Label::createWithTTF(\"My Label Text\", \"myFont.ttf\", 16); // outline effect is TTF only, specify the outline color desired myLabel->enableOutline(Color4B::WHITE, 1)); 发光效果: auto myLabel = Label::createWithTTF(\"My Label Text\", \"myFont.ttf\", 16); // glow effect is TTF only, specify the glow color desired. myLabel->enableGlow(Color4B::YELLOW); "},"ui_components/menus.html":{"url":"ui_components/menus.html","title":"菜单(Menu)","keywords":"","body":"菜单(Menu) 菜单是什么，我们肯定都很熟悉了，在每个游戏中都会有菜单。我们使用菜单浏览游戏选项，更改游戏设置。菜单通常包含开始，退出，设置，关于等项，菜单当然也可以包含子菜单。在 Cocos2d-x 提供 Menu 对象支持菜单功能，Menu 对象是一种特殊的 Node 对象。 创建一个菜单用于添加菜单项： auto myMenu = Menu::create(); 像我们刚才提到的一个菜单，总会有一些菜单项，比如开始，退出，设置等，没有菜单项的菜单没有存在的意义。Cocos2d-x 提供了一些方法来创建菜单项，比如使用 Label 对象，或是使用一张图像。菜单项一般有正常状态和选择状态。菜单项显示时是正常状态，当你点击它时变为选择状态，同时点击菜单还会触发一个回调函数。 使用图像创建菜单： // creating a menu with a single item // create a menu item by specifying images auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this)); auto menu = Menu::create(closeItem, NULL); this->addChild(menu, 1); 还可以使用 MenuItem 的一个 vector 创建菜单： // creating a Menu from a Vector of items Vector MenuItems; auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", CC_CALLBACK_1(HelloWorld::menuCloseCallback, this)); MenuItems.pushBack(closeItem); /* repeat for as many menu items as needed */ auto menu = Menu::createWithArray(MenuItems); this->addChild(menu, 1); 运行本文档的代码示例，你就能看到在 Chapter 6 有一个 Label 菜单项组成的菜单。 使用 Lambda 表达式 我们知道，当您点击菜单项时会触发一个回调函数。C++ 11 支持了 lambda 表达式，lambda 表达式是 匿名函数，所以你可以在回调方法处，使用 lambda 表达式，这样能让代码看起来更简洁，同时不会有额外的性能开销。 一个简单的 lambda 表达式： // create a simple Hello World lambda auto func = [] () { cout 使用 lambda 表达式作为菜单项的回调函数： auto closeItem = MenuItemImage::create(\"CloseNormal.png\", \"CloseSelected.png\", [&](Ref* sender){ // your code here }); "},"ui_components/buttons.html":{"url":"ui_components/buttons.html","title":"按钮(Button)","keywords":"","body":"按钮(Button) 按钮是什么，好像没有必要解释，我们都知道这东西是用来点击的，点击后使我们的游戏产生一些变化，比如更改了场景，触发了动作等等。按钮会拦截点击事件，事件触发时调用事先定义好的回调函数。按钮有一个正常状态，一个选择状态，还有一个不可点击状态，按钮的外观可以根据这三个状态而改变。Cocos2d-x 提供 Button 对象支持按钮功能，创建一个按钮并定义一个回调函数很简单，记得在操作的时候要有头文件包含: #include \"ui/CocosGUI.h\"。 auto button = Button::create(\"normal_image.png\", \"selected_image.png\", \"disabled_image.png\"); button->setTitleText(\"Button Text\"); button->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(button); 可以看到，我们为按钮的每个状态都指定了一个 .png 图像： 在屏幕显示的时候，同一个时刻只能看到一个状态，正常显示状态像这样： "},"ui_components/checkboxes.html":{"url":"ui_components/checkboxes.html","title":"复选框(CheckBox)","keywords":"","body":"复选框(CheckBox) 日常生活中复选框很常见，比如填写问卷时，让我们选一些喜欢的项目，游戏设置中，某一设置是打开还是关闭。只有两种状态的项目经常被设计为复选框。Cocos2d-x 提供 Checkbox 对象支持复选框功能。 创建一个复选框： #include \"ui/CocosGUI.h\" auto checkbox = CheckBox::create(\"check_box_normal.png\", \"check_box_normal_press.png\", \"check_box_active.png\", \"check_box_normal_disable.png\", \"check_box_active_disable.png\"); checkbox->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(checkbox); 在上面的例子中，我们能看到为一个复选框指定了五张图像，因为复选框有五种状态: 未被选中，被点击，未被选中时不可用，被选中，选中时不可用。这样五种状态的图像依次如下： 在屏幕显示的时候，同一个时刻只能看到一个状态，被选中时状态像这样： "},"ui_components/loading_bar.html":{"url":"ui_components/loading_bar.html","title":"进度条(LoadingBar)","keywords":"","body":"进度条(LoadingBar) 如果你经常玩游戏，那肯定见过一个情景：屏幕上显示了一个进度条，提示资源正在加载中，这个条表示资源加载的进度。Cocos2d-x 提供 LoadingBar 对象支持进度条。 创建一个进度条： #include \"ui/CocosGUI.h\" auto loadingBar = LoadingBar::create(\"LoadingBarFile.png\"); // set the direction of the loading bars progress loadingBar->setDirection(LoadingBar::Direction::RIGHT); this->addChild(loadingBar); 上面的例子，我们创建了一个进度条，设置了当进度增加时，进度条向右填充。 在进度的控制中，你肯定需要改变进度条的进度. 示例： #include \"ui/CocosGUI.h\" auto loadingBar = LoadingBar::create(\"LoadingBarFile.png\"); loadingBar->setDirection(LoadingBar::Direction::RIGHT); // something happened, change the percentage of the loading bar loadingBar->setPercent(25); // more things happened, change the percentage again. loadingBar->setPercent(35); this->addChild(loadingBar); 上面例子，使用的进度条图像是： 在屏幕上一个满进度的进度条是这样的： "},"ui_components/sliders.html":{"url":"ui_components/sliders.html","title":"滑动条(Slider)","keywords":"","body":"滑动条(Slider) 有时候你想平滑的改变一个值，比如游戏设置中，调整背景音乐的音量，或着你有一个角色，允许用户设置攻击敌人的力量。这种场景最适合使用滑动条，Cocos2d-x 提供 Slider 对象支持滑动条。 创建滑动条： #include \"ui/CocosGUI.h\" auto slider = Slider::create(); slider->loadBarTexture(\"Slider_Back.png\"); // what the slider looks like slider->loadSlidBallTextures(\"SliderNode_Normal.png\", \"SliderNode_Press.png\", \"SliderNode_Disable.png\"); slider->loadProgressBarTexture(\"Slider_PressBar.png\"); slider->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ switch (type) { case ui::Widget::TouchEventType::BEGAN: break; case ui::Widget::TouchEventType::ENDED: std::cout addChild(slider); 从上面的例子，可以看出，实现一个滑动条需要提供五张图像，对应滑动条的不同部分不同状态，分别为：滑动条背景，上层进度条，正常显示时的滑动端点，滑动时的滑动端点，不可用时的滑动端点。本次示例的五张图像如下： 在屏幕上一个滑动条看起来是这样的： "},"ui_components/textfields.html":{"url":"ui_components/textfields.html","title":"文本框(TextField)","keywords":"","body":"文本框(TextField) 如果你想让参与游戏的玩家可以自定义一个昵称怎么办，在哪里输入文本？Cocos2d-x 提供 TextField 满足这种需求。它支持触摸事件，焦点，定位内容百分比等。 创建一个文本框： #include \"ui/CocosGUI.h\" auto textField = TextField::create(\"\",\"Arial\",30); textField->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ std::cout addChild(textField); 这个例子中，创建了一个 TextField，指定了回调函数。 提供的文本框对象，是多功能的，能满足所有的输入需求，比如用户密码的输入，限制用户可以输入的字符数等等！ 看一个例子： #include \"ui/CocosGUI.h\" auto textField = TextField::create(\"\",\"Arial\",30); // make this TextField password enabled textField->setPasswordEnabled(true); // set the maximum number of characters the user can enter for this TextField textField->setMaxLength(10); textField->addTouchEventListener([&](Ref* sender, Widget::TouchEventType type){ std::cout addChild(textField); 屏幕上一个文本框是这样的： 当点击文本框，键盘就会自动调出来，此时可以输入文本： "},"other_node_types/":{"url":"other_node_types/","title":"特殊节点对象","keywords":"","body":"高级节点对象 除了 Label，Sprite 这些基本的节点对象外，Cocos2d-x 还提供了一些特殊的节点对象，来帮助构建一些高级功能。 也许你想制作一个基于瓦片地图的游戏，也许你想添加粒子效果，也许你想在游戏中添加一个 2D 滚动的边栏，别担心，这些特殊的节点对象能帮助你。 "},"other_node_types/getting_started.html":{"url":"other_node_types/getting_started.html","title":"More than just a Node","keywords":"","body":"Getting Started You are using Sprite, Label and Action objects in your game and it is making progress. Besides the basic Node types described in previous chapters, Cocos2d-x also provides more advanced Node types to help build special functionality. Perhaps you want to make a tile-based game? Or maybe a 2d side scroller? Or maybe you want to add particle effects to your game? Cocos2d-x provides Node objects to help you accomplish these goals! "},"other_node_types/tilemap.html":{"url":"other_node_types/tilemap.html","title":"瓦片地图","keywords":"","body":"瓦片地图 在游戏开发过程中，我们会遇到超过屏幕大小的地图，例如在即时战略游戏中，它使得玩家可以在地图中滚动游戏画面。这类游戏通常会有丰富的背景元素，如果直接使用背景图切换的方式，需要为每个不同的场景准备一张背景图，而且每个背景图都不小，这样会造成资源浪费。 瓦片地图就是为了解决这问题而产生的。一张大的世界地图或者背景图可以由几种地形来表示，每种地形对应一张小的的图片，我们称这些小的地形图片为瓦片。把这些瓦片拼接在一起，一个完整的地图就组合出来了，这就是瓦片地图的原理。 在 Cocos2d-x 中，瓦片地图实现的是 TileMap 方案，TileMap 要求每个瓦片占据地图上一个四边形或六边形的区域。把不同的瓦片拼接在一起，就可以组成完整的地图。TileMap 使用一种基于 XML 的 TMX 格式文件。 使用 TMX 文件创建一个瓦片地图： // reading in a tiled map. auto map = TMXTiledMap::create(\"TileMap.tmx\"); addChild(map, 0, 99); // with a tag of '99' 瓦片地图可能有许多层，通过层名获取到一个特定的层。 // how to get a specific layer auto map = TMXTiledMap::create(\"TileMap.tmx\"); auto layer = map->getLayer(\"Layer0\"); auto tile = layer->getTileAt(Vec2(1, 63)); 每个瓦片都有独一无二的位置和 ID，这使得我们很容易选择特定的瓦片。 通过位置访问： // to obtain a specific tiles id unsigned int gid = layer->getTileGIDAt(Vec2(0, 63)); 瓦片地图布局示例： 有很多工具可以用来制作瓦片地图，Tiled 就是其中一款流行的制作工具，它有一个活跃的用户社区。推荐你去使用，上面的屏幕截图就来自 Tiled 的项目。 "},"other_node_types/particles.html":{"url":"other_node_types/particles.html","title":"粒子系统","keywords":"","body":"粒子系统 粒子系统是指计算机图形学中模拟特定现象的技术，它在模仿自然现象、物理现象及空间扭曲上具备得天独厚的优势，能为我们实现一些真实自然而又带有随机性的效果（如爆炸、烟花、水流）提供了方便。Cocos2d-x引擎中就为我们提供了强大的粒子系统。 下面是使用粒子系统完成的两个粒子特效： 创建粒子特效的工具 尽管你能手动创建粒子特效，按照喜好确定每个属性，但是使用工具往往更方便高效。下面介绍几个第三方工具： Particle Designer：Mac 上一款非常强大的粒子特效编辑器 V-play particle editor：一款跨平台的粒子特效编辑器 Particle2dx：一款 Web 粒子特效编辑器，打开网页即可进行设计 使用这些工具完成粒子特效的设计，最终会导出一个 .plist 文件，Cocos2d-x 通过使用这种文件，就能把粒子特效添加到场景中，添加方法和操作一个普通的节点类型一样。 创建方法： // create by plist file auto particleSystem = ParticleSystem::create(\"SpinningPeas.plist\"); 内置粒子特效 准备好添加粒子特效到你的游戏中了吗？是否习惯创建自定义粒子特效？不习惯也没关系，我们内置了一些粒子特效，你可以直接使用。这个列表都是： ParticleFire: Point particle system. Uses Gravity mode. ParticleFireworks: Point particle system. Uses Gravity mode. ParticleSun: Point particle system. Uses Gravity mode. ParticleGalaxy: Point particle system. Uses Gravity mode. ParticleFlower: Point particle system. Uses Gravity mode. ParticleMeteor: Point particle system. Uses Gravity mode. ParticleSpiral: Point particle system. Uses Gravity mode. ParticleExplosion: Point particle system. Uses Gravity mode. ParticleSmoke: Point particle system. Uses Gravity mode. ParticleSnow: Point particle system. Uses Gravity mode. ParticleRain: Point particle system. Uses Gravity mode. 比如使用内置的烟火特效 ParticleFireworks： auto emitter = ParticleFireworks::create(); addChild(emitter, 10); 是这样的效果: 要是内置的粒子特效不是你想要的那样，也没关系，你可以直接手动设置参数！让我们拿上面的烟火特效示例，并通过手动改变属性进一步控制。 auto emitter = ParticleFireworks::create(); // set the duration emitter->setDuration(ParticleSystem::DURATION_INFINITY); // radius mode emitter->setEmitterMode(ParticleSystem::Mode::RADIUS); // radius mode: 100 pixels from center emitter->setStartRadius(100); emitter->setStartRadiusVar(0); emitter->setEndRadius(ParticleSystem::START_RADIUS_EQUAL_TO_END_RADIUS); emitter->setEndRadiusVar(0); // not used when start == end addChild(emitter, 10); "},"other_node_types/parallax.html":{"url":"other_node_types/parallax.html","title":"视差滚动","keywords":"","body":"视差滚动 视差滚动是指让多层背景以不同的速度移动，从而形成的立体运动效果。比如超级马里奥游戏中，角色所在地面的移动与背景天空的移动，就是一个视差滚动。Cocos2d-x 通过 ParallaxNode 对象模拟视差滚动。可以通过序列控制移动，也可以通过监听鼠标，触摸，加速度计，键盘等事件控制移动。ParallaxNode 对象比常规节点对象复杂一些，因为为了呈现不同的移动速度，需要多个子节点。它类似 Menu 像一个容器，本身不移动，移动的是被添加进入其中的不同子节点。ParallaxNode 的创建： // create ParallaxNode auto paraNode = ParallaxNode::create(); 添加多个节点对象： // create ParallaxNode auto paraNode = ParallaxNode::create(); // background image is moved at a ratio of 0.4x, 0.5y paraNode->addChild(background, -1, Vec2(0.4f,0.5f), Vec2::ZERO); // tiles are moved at a ratio of 2.2x, 1.0y paraNode->addChild(middle_layer, 1, Vec2(2.2f,1.0f), Vec2(0,-200) ); // top image is moved at a ratio of 3.0x, 2.5y paraNode->addChild(top_layer, 2, Vec2(3.0f,2.5f), Vec2(200,800) ); 需要注意的是，被添加的每个 Node 对象被赋予了一个唯一的 z-order 顺序，以便他们堆叠在彼此之上。另外要注意 addChild() 调用中两个 Vec2 参数，第一个决定这个子节点的移动速度与父节点移动速度的比率，第二个是相对父节点 ParallaxNode 的偏移量。 在文本中很难展示视差滚动，请运行本文档的代码示例吧！ "},"event_dispatcher/":{"url":"event_dispatcher/","title":"事件分发机制","keywords":"","body":"事件分发机制 Cocos2d-x 通过事件分发机制响应用户事件，已内置支持常见的事件如触摸事件，键盘事件等。同时提供了创建自定义事件的方法，满足我们在游戏的开发过程中，特殊的事件响应需求。 基本元素 事件监听器：负责接收事件，并执行预定义的事件处理函数 事件分发器：负责发起通知 事件对象：记录事件的相关信息 "},"event_dispatcher/getting_started.html":{"url":"event_dispatcher/getting_started.html","title":"What is the EventDispatch mechanism","keywords":"","body":"What is the EventDispatch mechanism? EventDispatch is a mechanism for responding to user events. The basics: Event listeners encapsulate your event processing code. Event dispatcher notifies listeners of user events. Event objects contain information about the event. "},"event_dispatcher/types.html":{"url":"event_dispatcher/types.html","title":"监听器","keywords":"","body":"监听器 五种类型 EventListenerTouch - 响应触摸事件 EventListenerKeyboard - 响应键盘事件 EventListenerAcceleration - 响应加速度事件 EventListenMouse - 响应鼠标事件 EventListenerCustom - 响应自定义事件 事件的吞没 当你有一个监听器，已经接收到了期望的事件，这时事件应该被吞没。事件被吞没，意味着在事件的传递过程中，你消耗了此事件，事件不再向下传递。避免了下游的其它监听器获取到此事件。 设置吞没： // When \"swallow touches\" is true, then returning 'true' from the // onTouchBegan method will \"swallow\" the touch event, preventing // other listeners from using it. listener1->setSwallowTouches(true); // you should also return true in onTouchBegan() listener1->onTouchBegan = [](Touch* touch, Event* event){ // your code return true; }; "},"event_dispatcher/priority.html":{"url":"event_dispatcher/priority.html","title":"优先级","keywords":"","body":"优先级 事件的吞没中，我们提到了事件的传递。事件如何传递，先到哪个监听器？这是由优先级决定的。 固定值优先级 使用一个整形的数值，数值较低的监听器比数值较高的监听器，先接收到事件。 场景图优先级 是指向节点对象的指针，z-order 较高的节点中的监听器比 z-order 较低的节点中的，先接收到事件。由于 z-order 较高的节点在顶部绘制，所以使用这种优先级可以确保触摸事件被正确响应 还记得这个场景图吗？图像绘制时，是按照 A, B, C, D, E, F, G, H, I 的顺序。 当使用 场景图优先级 时，事件是按照绘制的反方向，即 I, H, G, F, E, D, C, B, A 传递。如果一个事件被触发，I 节点先接收到，如果在 I 节点中事件被吞没，则不会继续传递，未被吞没，事件将传递到 H 节点，每个节点都重复同样的逻辑，直到事件被吞没，或者传递结束，本次事件触发才完成。 "},"event_dispatcher/touch.html":{"url":"event_dispatcher/touch.html","title":"触摸事件","keywords":"","body":"触摸事件 触摸事件是手机游戏中最重要的事件，它易于创建，还能提供多种多样的功能。 让我们先了解一下什么是触摸事件，当你触摸移动设备的屏幕时，设备感受到被触摸，了解到被触摸的位置，同时取得触摸到的内容，然后你的触摸被回答。 这就是触摸事件。 如果你希望通过触摸控制屏幕下层的对象，那可以通过 优先级，达成这种需求，优先级高的对象能先处理事件。 创建触摸事件监听器： // Create a \"one by one\" touch event listener // (processes one touch at a time) auto listener1 = EventListenerTouchOneByOne::create(); // trigger when you push down listener1->onTouchBegan = [](Touch* touch, Event* event){ // your code return true; // if you are consuming it }; // trigger when moving touch listener1->onTouchMoved = [](Touch* touch, Event* event){ // your code }; // trigger when you let up listener1->onTouchEnded = [=](Touch* touch, Event* event){ // your code }; // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, this); 可以看到，在使用触摸事件监听器时，可以监听三种不同的事件，每一个事件都有自己触发的时机。 三种事件及其触发时机： onTouchBegan 开始触摸屏幕时 onTouchMoved 触摸屏幕，同时在屏幕上移动时 onTouchEnded 结束触摸屏幕时 "},"event_dispatcher/keyboard.html":{"url":"event_dispatcher/keyboard.html","title":"键盘事件","keywords":"","body":"键盘事件 对于桌面游戏，一般需要通过键盘做一些游戏内的控制，这时你就需要监听键盘事件。Cocos2d-x 支持键盘事件，就像上节介绍的触摸事件一样。 创建键盘事件监听器： // creating a keyboard event listener auto listener = EventListenerKeyboard::create(); listener->onKeyPressed = CC_CALLBACK_2(KeyboardTest::onKeyPressed, this); listener->onKeyReleased = CC_CALLBACK_2(KeyboardTest::onKeyReleased, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this); // Implementation of the keyboard event callback function prototype void KeyboardTest::onKeyPressed(EventKeyboard::KeyCode keyCode, Event* event) { log(\"Key with keycode %d pressed\", keyCode); } void KeyboardTest::onKeyReleased(EventKeyboard::KeyCode keyCode, Event* event) { log(\"Key with keycode %d released\", keyCode); } 可以看到，在使用键盘事件监听器时，可以监听两种不同的事件，每一个事件都有自己的触发时机。 两种事件及触发时机： onKeyPressed 按键被按下时 onKeyReleased 按下状态的按键被放开时 "},"event_dispatcher/accelerometer.html":{"url":"event_dispatcher/accelerometer.html","title":"加速度传感器事件","keywords":"","body":"加速度传感器事件 现在一些移动设备配备有加速度传感器，我们可以通过监听它的事件获取各方向的加速度。 可以设想要完成一个游戏情景：通过来回移动手机，平衡小球在手机中的位置。这种场景的完成，就需要监听加速度传感器事件。 使用加速度传感器，需要先启用 Device::setAccelerometerEnabled(true); 创建加速度传感器监听器： // creating an accelerometer event auto listener = EventListenerAcceleration::create(CC_CALLBACK_2( AccelerometerTest::onAcceleration, this)); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener, this); // Implementation of the accelerometer callback function prototype void AccelerometerTest::onAcceleration(Acceleration* acc, Event* event) { // Processing logic here } "},"event_dispatcher/mouse.html":{"url":"event_dispatcher/mouse.html","title":"鼠标事件","keywords":"","body":"鼠标事件 就像前几节介绍的那样，Cocos2d-x 支持响应鼠标事件 创建鼠标事件监听器： _mouseListener = EventListenerMouse::create(); _mouseListener->onMouseMove = CC_CALLBACK_1(MouseTest::onMouseMove, this); _mouseListener->onMouseUp = CC_CALLBACK_1(MouseTest::onMouseUp, this); _mouseListener->onMouseDown = CC_CALLBACK_1(MouseTest::onMouseDown, this); _mouseListener->onMouseScroll = CC_CALLBACK_1(MouseTest::onMouseScroll, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(_mouseListener, this); void MouseTest::onMouseDown(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Down detected, Key: \"; str += tostr(e->getMouseButton()); } void MouseTest::onMouseUp(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Up detected, Key: \"; str += tostr(e->getMouseButton()); } void MouseTest::onMouseMove(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"MousePosition X:\"; str = str + tostr(e->getCursorX()) + \" Y:\" + tostr(e->getCursorY()); } void MouseTest::onMouseScroll(Event *event) { // to illustrate the event.... EventMouse* e = (EventMouse*)event; string str = \"Mouse Scroll detected, X: \"; str = str + tostr(e->getScrollX()) + \" Y: \" + tostr(e->getScrollY()); } "},"event_dispatcher/custom.html":{"url":"event_dispatcher/custom.html","title":"自定义事件","keywords":"","body":"自定义事件 上述提到的事件都是系统内置的，如触摸事件，键盘事件等。此外，你可以制作自定义事件，这些事件不是由系统控制触发的，而是通过代码手动触发。 创建自定义事件监听器： _listener = EventListenerCustom::create(\"game_custom_event1\", [=](EventCustom* event){ std::string str(\"Custom event 1 received, \"); char* buf = static_cast(event->getUserData()); str += buf; str += \" times\"; statusLabel->setString(str.c_str()); }); _eventDispatcher->addEventListenerWithSceneGraphPriority(_listener, this); 上面制作了一个自定义事件监听器，并预设了响应方法。下面创建自定义事件，并手动分发： static int count = 0; ++count; char* buf[10]; sprintf(buf, \"%d\", count); EventCustom event(\"game_custom_event1\"); event.setUserData(buf); _eventDispatcher->dispatchEvent(&event); 示例创建了一个自定义事件( EventCustom )对象，并设置了 UserData，然后调用 _eventDispatcher->dispatchEvent(&event) 进行手动事件分发。当预先定义的事件监听器，收到此事件，将会触发对应的响应函数。响应函数中可以获取到事件分发时设置的 UserData 完成数据处理。 注意: EventCustom 与 EventListenerCustom 的第一个参数事件名都是字符串 game_custom_event1 "},"event_dispatcher/registering.html":{"url":"event_dispatcher/registering.html","title":"进阶话题","keywords":"","body":"进阶话题 注册事件监听 当我们需求多个节点对象有相同的事件响应时，可以创建一个事件监听器，然后通过 eventDispatcher，将其注册到多个对象。 以我们之前提到的触摸事件监听器为例： // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, sprite1); 需要注意的是，在添加到多个对象时，需要使用 clone() 方法。 // Add listener _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1, sprite1); // Add the same listener to multiple objects. _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(), sprite2); _eventDispatcher->addEventListenerWithSceneGraphPriority(listener1->clone(), sprite3); 移除事件监听 按照下面的方法，可以将已经添加的事件监听器移除。 _eventDispatcher->removeEventListener(listener); 内置节点对象的事件分发机制，和我们上面讨论的一致，比如，当你点击带有菜单项的菜单时，也会分发一个事件。 同样的你也可以在内置节点对象上使用 removeEventListener() 移除事件监听。 "},"3d/":{"url":"3d/","title":"3D 支持","keywords":"","body":"3D 支持 你很可能认为 Cocos2d-x 是一个纯 2D 游戏引擎，事实上，从 3.0 版本 3D 功能就开始了添加和完善。 3D 游戏开发可能对你来说很新奇，相关的术语也还不熟悉，有什么工具也还不知道，但是别担心，让我们从术语开始一一了解。 术语 进行 3D 游戏开发前，先熟悉一些常用术语: Model(模型) - 可以呈现的对象。由一个一个的多边形组成，Cocos2d-x 中对应 Sprite3D。 Mesh(网格) - 指模型的网格，由 3D 模型被划分的多边形构成。 Texture(纹理) - 纹理使 3D 模型有了表现真实物体复杂表面的能力，模型的所有表面和顶点都可以被映射纹理。 Camera(摄像机) - 3D 世界中的眼睛 ，通过它能获得一个角度的世界场景。同一个世界，通过设置不同的摄像机参数，可以获得不同的场景。 Light(光照) - 3D 世界中的光照，通过设置光照让游戏场景看起来更真实。光照效果，会影响 3D 模型表面的明暗效果，色彩效果。 Cocos2d-x 内附带的 3D 功能已经不再更新 "},"3d/terminology.html":{"url":"3d/terminology.html","title":"Terminology","keywords":"","body":"Terminology When using 3D, there are some commonly used terms that you should be familiar with: Mesh - vertices that construct a shape and texture with which you are rendering. Model - an object that can be rendered. It is a collection of meshes. In our engine Sprite3D. Texture - All surfaces and vertices of a 3D model can be mapped to a texture. In most cases you will have multiple textures per model, unwrapped in a texture atlas. Camera - Since a 3D world is not flat, you need to set a camera to look at it. You get different scenes with different camera parameters. Light - Lightening is applied to make scenes look realistic. To make an object look real, the color should change according to the light. When you face the light it is bright and the opposite is dark. Lightening an object means computing the object's color according to the light. getName (), getGLProgramState (), _blendFunc, & _quad, 1, _billboardTransform); renderer-> addCommandToTransparentQueue (& _ quadCommand); BillBoard more details see the use of the methods and examples of BillBoardTest with cpptests ### Coordinate transformation `Camera` provide helpers to transform coordinates from screen space to world space. Example: ```cpp void unproject (const Size & viewport, Vec3 * src, Vec3 * dst) const; ``` Here viewport is _viewport size_, use `src` as screen coordinates, the z axis of the `src` indicates clipping plane distance information, -1 means the near clipping plane, 1 means far clipping plane. The `dst` parameter will return world space coordinates. ## Ray `Ray` is super useful in 3D game. You can use `Ray` to achieve things like picking up an object in 3D or detect collision in 3D. Illustration: ![](3d-img/Ray.png) ### Creating a Ray You need two vectors to create a `Ray`, one is the origin, the other is the direction. Example: ```cpp Ray ray (Vec3 (0,0,0), Vec3 (0,0,1)); ``` This will create a `Ray` originated from (0,0,0) in the direction of the positive Z axis. With this `Ray`, you can call the function with space intersects AABB box or any box OBB collision, the code is as follows: ```cpp Ray ray (Vec3 (0,0,0), Vec3 (0,0,1)); AABB aabb (Vec (-1, -1, -1), Vec (1,1,1)); if (ray .intersects (aabb)) { // ray intersects with AABB } else { // ray does not intersect with the AABB } ``` ## AABB `AABB` mean axis aligned bounding box, a 3D AABB is a simple six-sided, each side is parallel to a coordinate plane. It would look like this: ![](3d-img/AABB.png) AABB properties: Two vertices is particularly important: Pmin = [Xmin Ymin Zmin], Pmax = [Xmax Ymax Zmax]. Other points on the box are met Xmin positions; std::vector normals; std::vector texs; Mesh::IndexArray indices; positions.push_back(-5.0f);positions.push_back(-5.0f);positions.push_back(0.0f); positions.push_back(5.0f);positions.push_back(-5.0f);positions.push_back(0.0f); positions.push_back(5.0f);positions.push_back(5.0f);positions.push_back(0.0f); positions.push_back(-5.0f);positions.push_back(5.0f);positions.push_back(0.0f); texs.push_back(0.0f);texs.push_back(0.0f); texs.push_back(1.0f);texs.push_back(0.0f); texs.push_back(1.0f);texs.push_back(1.0f); texs.push_back(0.0f);texs.push_back(1.0f); indices.push_back(0); indices.push_back(1); indices.push_back(2); indices.push_back(0); indices.push_back(2); indices.push_back(3); auto mesh = Mesh::create(positions, normals, texs, indices); mesh->setTexture(\"quad.png\"); ``` How to render the construct Mesh? When all the information is rendered after we finished building Mesh already have, but also need the appropriate data into the rendering pipeline to render, so you can consider building a custom class derived from Node, overloading the Draw method, and building a MeshCommand in the Draw method and pass relevant data into the Mesh render queue, eventually rendering. For example custom class Draw method can add the following code: ```cpp auto programstate = mesh->getGLProgramState(); auto& meshCommand = mesh->getMeshCommand(); GLuint textureID = mesh->getTexture() ? mesh->getTexture()->getName() : 0; meshCommand.init(_globalZOrder , textureID , programstate , _blend , mesh->getVertexBuffer() , mesh->getIndexBuffer() , mesh->getPrimitiveType() , mesh->getIndexFormat() , mesh->getIndexCount() , transform); renderer->addCommand(&meshCommand); ``` The results: ![](3d-img/quad.png) ---> "},"3d/sprite3d.html":{"url":"3d/sprite3d.html","title":"3D 精灵","keywords":"","body":"3D 精灵 就像 2D 游戏一样，3D 游戏也有精灵对象，Cocos2d-x 提供的 3D 精灵对象是 Sprite3D，3D 空间位置有三个方向的自由度，类似的 Sprite3D 的位置由 (x, y, z) 三个坐标值决定。 Sprite3D 在许多方面都和普通的 Sprite 一样。 创建并加载： auto sprite = Sprite3D::create(\"boss.c3b\"); //c3b file, created with the FBX-converter sprite->setScale(5.f); //sets the object scale in float sprite->setPosition(Vec2(200,200)); //sets sprite position scene->addChild(sprite,1); //adds sprite to scene, z-index: 1 这个对象是通过 .c3b 文件创建的，效果是这样： 创建一个动作使这个模型不断旋转： //rotate around the X axis auto rotation = RotateBy::create(15, Vec3(0, 360, 0)); //our sprite object runs the action sprite->runAction(RepeatForever::create(rotation)); 设置锚点，与 Sprite 方法一样： sprite->setAnchorPoint(Point(0.0f,0.0f)); 模型附加 回想一下，3D 模型是网格的集合，网格可以再组合，所以为了创建丰富的效果，你可以将 3D 模型附加到其它 3D 模型。 一个例子是向一个角色添加一把武器。 首先使用 getAttachNode(attachment_point_name) 获取到附加点，然后使用 addChild() 方法把武器模型添加上去。 效果如下： auto sp = Sprite3D::create(\"axe.c3b\"); sprite->getAttachNode(\"Bip001 R Hand\")->addChild(sp); 以此为例，结合多个简单的模型，你就能创建复杂的模型。 网格替换 进行 3D 游戏开发时，你可能需要对模型进行动态更改。 如果创建的模型是由网格组成，那你就能通过 getMeshByIndex() getMeshByName() 访问到网格数据，然后进行一些控制。 比如使用这个功能替换一个角色的武器或者衣服。 以一个穿着外套的角色为例： 我们通过使用网格对象，替换掉外套，下面是演示代码： auto sprite = Sprite3D::create(\"ReskinGirl.c3b\"); // display the first coat auto girlTop0 = sprite->getMeshByName(\"Girl_UpperBody01\"); girlTop0->setVisible(true); auto girlTop1 = sprite->getMeshByName(\"Girl_UpperBody02\"); girlTop1->setVisible(false); // swap to the second coat girlTop0->setVisible(false); girlTop1->setVisible(true); 效果： "},"3d/animation.html":{"url":"3d/animation.html","title":"3D 动画","keywords":"","body":"3D 动画 我们知道 3D 精灵对游戏很重要，也学会了如何操纵，但是可能还希望能有一些更丰富的效果。 那就添加动画吧！ 要运行 3D 动画，你需要使用 Animation3D 和 Animate3D 对象，首先用 Animation3D 加载一个动画文件，然后使用 Animate3D 完成添加。 示例： // the animation is contained in the .c3b file auto animation = Animation3D::create(\"orc.c3b\"); // creates the Action with Animation object auto animate = Animate3D::create(animation); // runs the animation sprite->runAction(RepeatForever::create(animate)); 去运行本文档的代码示例看看效果，记住，3D 动画与 2D 动画基本相同。2D 动画可参考本文档的 第四章 多动画 当想同时运行多个动画时，该怎么办？你可以创建多个动画，并指定开始时间和动画长度参数，两个参数的单位都是秒。例如： auto animation = Animation3D::create(fileName); auto runAnimate = Animate3D::create(animation, 0, 2); sprite->runAction(runAnimate); auto attackAnimate = Animate3D::create(animation, 3, 5); sprite->runAction(attackAnimate); 在上面的例子中，有两个动画可以运行，第一个从动画启动时开始然后持续 2 秒，第二个在 3 秒时开始然后持续 5 秒。 动画速度 动画速度由一个整数控制，整数的绝对值代表动画的持续时间，整数大于零动画正序播放，整数小于零倒序播放。速度设置为 10 意味着动画在 10 秒内正序播放完。 动画混合 使用多个动画时，会在每个动画之间自动应用混合，混合的目的是为了创造平滑的过渡。给定两个动画 A 和 B， 动画 A 最后一小段时间的几帧会和动画 B 前一小段时间的几帧重叠，这使得动画的变化看起来很自然。默认的混合的时间是 0.1 秒，你可以使用 Animate3D::setTransitionTime 更改默认的混合时间。 Cocos2d-x 支持关键帧之间的线性插值，这能填补曲线上的空白，确保光滑的路径。如果在模型构建时指定了其它插值方法，我们内置的工具 fbx-conv 将生成额外的关键帧，这种补偿通常根据目标框架完成。 有关 fbx-conv 的更多信息，请参考本章末尾的讨论 "},"3d/camera.html":{"url":"3d/camera.html","title":"相机(Camera)","keywords":"","body":"相机(Camera) 玩家看到的 3D 游戏世界，就是游戏制作中 相机(Camera) 对象查看到的场景，就如，观众看一部电影，看到的是电影拍摄时相机查看到的现实世界。游戏制作中的相机与电影拍摄时的相机作用是一样的。Camera 对象继承了 Node 对象，因此 Camera 支持大多数 Action。 相机有两种，一种是透视相机，一种是正交相机。透视相机看到的游戏世界具有远近效果，像这样： 就好像眼睛观察现实世界，近处的对象较大，远处的对象较小。第一人称的游戏通常使用透视视角渲染。正交相机看到的游戏世界没有远近效果，看到的只是游戏世界一个方向的投影，像这样： 正交相机看到的 3D 对象，大小不会因为距离而变化。游戏中的迷你地图通常是用正交相机渲染，需要上帝视角的游戏，也会使用正交相机渲染。 使用相机 不用担心，相机听起来很复杂，但使用 Cocos2d-x 操作相机很容易。使用 3D 时，无需做任何特殊的操作即可创建 Camera 对象，每个场景都会根据 Director 对象的投影属性默认创建一个相机。如果需要多台相机，可以使用以下代码创建一个： auto s = Director::getInstance()->getWinSize(); auto camera = Camera::createPerspective(60, (GLfloat)s.width/s.height, 1, 1000); // set parameters for camera camera->setPosition3D(Vec3(0, 100, 100)); camera->lookAt(Vec3(0, 0, 0), Vec3(0, 1, 0)); addChild(camera); //add camera to the scene 创建正交相机 默认的相机是透视相机，如果你想创建一个正交相机，这样做： Camera::createOrthographic(); 示例： auto s = Director::getInstance()->getWinSize(); auto camera = Camera::createOrthographic(s.width, s.height, 1, 1000); 在相机中隐藏对象 有时候，你不想在一个相机视角让所有对象显现，比如需要在玩家的视野中隐藏一个角色。这在 Cocos2d-x 中很容易做到，在节点对象使用 setCameraMask(CameraFlag) 函数，或者在相机对象使用 setCameraFlag(CameraFlag) 函数，都可以达到同样的效果。 示例： //Camera camera->setCameraFlag(CameraFlag::USER1); //Node node->setCameraMask(CameraFlag::USER1); "},"3d/cubemap.html":{"url":"3d/cubemap.html","title":"立方体纹理(TextureCube)","keywords":"","body":"立方体纹理(TextureCube) 立方体纹理是放置在立方体各个表面上的六个单独的方形纹理的集合。大多数情况下，它们用于在物体上显示无限远的反射，类似于天空盒在背景中显示远处的风景。一个展开的立方体纹理可能是这样的： 在 Cocos2d-x 中，这样创建立方体纹理： // create a textureCube object with six texture assets auto textureCube = TextureCube::create(\"skybox/left.jpg\", \"skybox/right.jpg\", \"skybox/top.jpg\", \"skybox/bottom.jpg\", \"skybox/front.jpg\", \"skybox/back.jpg\"); // set cube map texture parameters Texture2D::TexParams tRepeatParams; tRepeatParams.magFilter = GL_NEAREST; tRepeatParams.minFilter = GL_NEAREST; tRepeatParams.wrapS = GL_MIRRORED_REPEAT; tRepeatParams.wrapT = GL_MIRRORED_REPEAT; textureCube->setTexParameters(tRepeatParams); // create and set our custom shader auto shader = GLProgram::createWithFilenames(\"cube_map.vert\", \"cube_map.frag\"); auto _state = GLProgramState::create(shader); // bind cube map texture to uniform state->setUniformTexture(\"u_cubeTex\", textureCube); "},"3d/skybox.html":{"url":"3d/skybox.html","title":"天空盒(Skybox)","keywords":"","body":"天空盒(Skybox) 天空\b盒(Skybox) 是整个场景的一个包裹，显示了几何之外的世界。你可以使用 Skybox 来模拟无限的天空，山脉等现象。 Skybox 的创建： // create a Skybox object auto box = Skybox::create(); // set textureCube for Skybox box->setTexture(_textureCube); // attached to scene _scene->addChild(box); "},"3d/lighting.html":{"url":"3d/lighting.html","title":"光照(Light)","keywords":"","body":"光照(Light) 光照对于烘托一个游戏的气氛非常重要，Cocos2d-x 目前支持四种光照技术。使用不同的光照技术，可以获得不同的光照效果。 环境光 环境光 AmbientLight 对场景中的所有内容均匀的应用光照，模拟正常办公环境中的光照可以使用这种方式。 代码： auto light = AmbientLight::create (Color3B::RED); addChild(light); 效果： 定向光 定向光 DirectionLight 是来自特定方向的平行光。因为所有的光线都是平行的，对于场景中的每个物体光的方向都保持一致，所以物体和光源的位置保持怎样的关系都无所谓。定向光的一个很好例子是太阳光。 代码： auto light = DirectionLight::create(Vec3(-1.0f, -1.0f, 0.0f), Color3B::RED); addChild(light); 效果： 点光源 点光源 PointLight 从一个点向整个空间所有方向照射，注意，距离点光源越近，受到的光照越强，越远，受到的光照越弱。点光源的一个很好例子是灯泡。 代码： auto light = PointLight::create(Vec3(0.0f, 0.0f, 0.0f), Color3B::RED, 10000.0f); addChild(light); 效果： 聚光 聚光 SpotLight 是一种位于环境中某点的光源，只是它不是向所有方向照射，而是只朝某个方向照射。结果是只有一个聚光照射方向的确定半径内的物体才会被照亮，其他的都保持黑暗。聚光的一个很好的例子是手电筒的光。 代码： auto spotLight = SpotLight::create(Vec3(-1.0f, -1.0f, 0.0f), Vec3(0.0f, 0.0f, 0.0f), Color3B::RED, 0.0, 0.5, 10000.0f) ; addChild(spotLight); 效果： 光照屏蔽 如果场景中被设置了多个光照，但是你希望某一节点对象仅被其中一个光照影响，而不是被多个光照影响，那可以使用 setLightFlag(LightFlag) 函数进行控制。要注意，多个光照效果也是通过一次渲染完成的。 由于移动平台的性能问题，不推荐使用多个光照，默认光照的最大值为一，如果要打开多个光源，则必须要在 info.plist 中定义以下配置： cocos2d.x.3d.max_dir_light_in_shader 1 cocos2d.x.3d.max_point_light_in_shader 1 cocos2d.x.3d.max_spot_light_in_shader 1 "},"3d/terrain.html":{"url":"3d/terrain.html","title":"地形(Terrain)","keywords":"","body":"地形(Terrain) 地形 Terrain 是 3D 游戏中重要的组成部分，地形就是通过载入一张高度图和若干张细节纹理，从而在场景中绘制若干高低不平的几何体，用以在游戏场景中模拟自然中的沙漠，草原等景象。从地形的资源构成角度来说，包含了下面几个元素： 高度图 高度图从本质而言，也是一张图片，但是图中的每一个像素的颜色值并不被当做颜色，而是被视为一个高度值。Terrain 对象通过高度图所给的高度信息，加以适当的缩放，构建出整个地形的网格结构。 细节图 如果说高度图确定了整个地形的几何形状，那么细节图则确定了地形的外观。通过将细节图贴在地形上，可以制造非常好的表现效果。最多可以使用四个纹理作为细节图。 Alpha贴图 Alpha贴图用于控制细节图是在地形上何处以及如何绘制的。Alpha贴图从本质而言，也是一张图片，但是它将图片中每个像素中的 Red,Green,Blue 以及Alpha通道对应四张细节图在地形的某个位置上，每一张细节图颜色比例是多少。通过这种方式，我们就可以在地形上同时出现诸如沙丘，石板路，草地等纹理，使得地形的外观不再那么单调。 细节级别策略 Terrain 使用细节级别(Level Of Detail)策略，它根据摄像机离对象的远近，切换不同细节级别，达到一种近处的对象细节丰富，远处的对象细节简单，这样减少了整体需要渲染的三角形数量，提高了性能。 可以使用 Terrain::setLODDistance(float lod1, float lod2, float lod3 方法设置摄像机的距离。 具有不同细节级别的地形相邻块可能存在裂缝，Terrain 提供了两种方式(裙边法，补边法)避免这种情况的出现： Terrain::CrackFixedType::SKIRT Terrain::CrackFixedType::INCREASE_LOWER Terrain::CrackFixedType::SKIRT 裙边法：在块的每个边缘生成四个裙状网格 Terrain::CrackFixedType::INCREASE_LOWER 补边法：动态调整每个快的索引，使其无缝连接 创建地形 下面代码演示了如何创建一个地形，并在上面放一个精灵 auto player = Sprite3D::create(\"chapter9/orc.c3b\"); player->setScale(0.08); player->setPositionY(terrain->getHeight(player->getPositionX(),player->getPositionZ())); 通过 Terrain::DetailMap 对象创建细节图： Terrain::DetailMap r(\"dirt.dds\"); Terrain::DetailMap g(\"grass.dds\"); Terrain::DetailMap b(\"road.dds\"); Terrain::DetailMap a(\"greenSkin.jpg\"); 构造 Terrain::TerrainData 对象，构造函数的第一个参数为高度图的路径，第二个参数为 Alpha 贴图的路径，接下来的四个参数为之前所构造的四个 DetailMap 结构体。 Terrain::TerrainData data(\"chapter9/heightmap16.jpg\",\"TerrainTest/alphamap.png\", r, g, b, a); 调用 Terrain::create 创建出地形，第一个参数是之前构造好的 TerrainData 对象，第二个参数是细节级别策略。 _terrain = Terrain::create(data, Terrain::CrackFixedType::SKIRT); 请注意，在地形对象被添加到节点或场景中(进行了 addChild() 操作)后，就不能再对地形对象使用转换，比如缩放大小。 否则，Terrain 的方法可能会造成难以预料的结果。 获取地形高度 使用方法 Terrain::getHeight(float x, float z, Vec3 * normal= nullptr) 可以获取到地形的高度，当你想把一个节点对象放到地形表面的时候，这个方法会非常有用。 "},"3d/tools.html":{"url":"3d/tools.html","title":"常用工具","keywords":"","body":"常用工具 3D 编辑器 3D 编辑器是用于构建 3D 模型的工具集合，有商业的和免费的可用，这是其中一些受欢迎的编辑器： Blender (Free) 3DS Max Cinema4D Maya 大多数 3D 编辑器都能将文件保存成通用的格式，方便文件在其它编辑器中使用，同时也方便了游戏引擎对 3D 模型的导入和使用。 Cocos2d-x 提供的工具 Cocos2d-x 提供了一个转换工具，可以将编辑器生成的通用格式转换为引擎支持的格式。 fbx-conv 命令行 fbx-conv 允许将 FBX 格式转换为 Cocos2d-x 专有格式。 FBX 是最受欢迎的 3D 文件格式，被所有编辑器支持。 命令行工具默认的导出文件格式是 .c3b 。 命令行的使用： fbx-conv [-a|-b|-t] FBXFile 参数含义： -?：显示帮助信息 -a：导出文本格式和二进制格式 -b：导出二进制格式 -t：导出文本格式 示例： fbx-conv -a boss.FBX 工具使用注意点： 模型需要一个至少包含一个纹理的材质 只支持骨骼动画 只支持一个骨骼对象，没有多个骨骼对象的支持 您可以通过导出多个静态模型来创建一个 3D 场景 网格顶点或索引的最大数量为 32767 3D 文件格式 Cocos2d-x 目前支持两种 3D 文件格式： Wavefront 对象文件：.obj 文件 Cocos2d-x 专有格式：.c3t ，.c3b 文件 支持 Wavefront 文件格式，因为它被 3D 编辑器广泛采用，并且非常容易解析。然而，它是有缺点的，不支持诸如动画的高级功能。 另一方面，c3t 和 c3b 是 Cocos2d-x 专有的文件格式，允许动画，材质和其它高级3D功能。c3t 是文本格式，c3b 是二进制格式。开发人员进行最终的游戏发布时应使用 c3b ，因为使用它性能更好。如果是想要调试文件，或是跟踪其在 Git 或任何其他版本控制系统中的更改，则应使用 c3t 。 注意：可以使用 c3b 或 c3t 文件，不能使用 obj 文件，创建 Animation3D 对象。 "},"3d/advanced.html":{"url":"3d/advanced.html","title":"进阶话题","keywords":"","body":"进阶话题 广告牌(BillBoard) 广告牌(BillBoard)是一种特殊的精灵对象，它总是面对摄像机，摄像机旋转，广告牌对象也会跟着旋转。广告牌在 3D 游戏中是非常常见的，比如 3D 角色头顶的文字，血条，比如滑雪比赛场景里的树木，岩石。 这就是摄像机(Camera)与广告牌(BillBoard)关联的方式： Sprite 是 Billboard 的父类，因此广告牌的大部分功能都与精灵一样。 使用下面的方式可以创建一个广告牌： auto billboard = BillBoard::create(\"Blue_Front1.png\", BillBoard::Mode::VIEW_POINT_ORIENTED); 你可以更改广告牌的模式为，广告牌面向摄像机 XOY 平面，这样创建 auto billboard = BillBoard::create(\"Blue_Front1.png\", BillBoard::Mode::VIEW_PLANE_ORIENTED); 这两个创建方法看起来有点不一样，因为传入的第二个参数不同，第二个参数确定了广告牌的模式，有两种选择： VIEW_POINT_ORIENTED 广告牌面向摄像机所在的点，示例： VIEW_PLANE_ORIENTED 广告牌面向摄像机所在的平面，示例： 你可以像普通节点对象一样控制广告牌，比如控制缩放，位置，旋转等等 billboard->setScale(0.5f); billboard->setPosition3D(Vec3(0.0f, 0.0f, 0.0f)); billboard->setBlendFunc(BlendFunc::ALPHA_NON_PREMULTIPLIED); addChild(billboard); 3D 粒子系统 在 第七章 中，我们已经学习了如何使用 2D 粒子，当你进行 3D 游戏制作的时候，为了丰富游戏的效果，你可能还需要 3D 粒子。 3D 粒子系统与 2D 粒子系统的许多概念是一样的。 Cocos2d-x 目前支持制作工具 Particle Universe 构建的粒子，Particle Universe 是一个特殊的粒子编辑器，可以让你快速，轻松的构建出各种粒子效果，如爆炸，火焰，血液。 Particle Universe 粒子编辑器生成的粒子文件格式是 .pu，Cocos2d-x 直接支持这种格式。 由 PUParticleSystem3D 类负责处理。 PUParticleSystem3D 提供了两种创建粒子的方法。 第一种方式传入两个参数： Particle Universe 粒子文件和相应的材质文件。 材质文件描述的是粒子的内容，对于一个粒子特效是必须的 示例： auto ps = PUParticleSystem3D::create(\"lineStreak.pu\", \"pu_mediapack_01.material\"); ps->startParticleSystem(); this->addChild(ps); 第二个方法传入一个参数，Particle Universe 粒子文件。 使用这种方法创建粒子，与粒子文件相同的文件夹中所有的材质文件都将被自动加载。 示例： auto ps = PUParticleSystem3D::create(\"electricBeamSystem.pu\"); ps->startParticleSystem(); this->addChild(ps); 注意：使用第二种方法，可能会导致加载时间增加，消耗内存增加。 如果你知道需要使用的材质，请选第一种方法。 下图左边是 Particle Universe 中的粒子，右边是该粒子使用 Cocos2d-x 运行的效果。 在游戏中加载好了粒子效果，接下来就可以尝试进行一些控制操作，如开始，停止，暂停，恢复和获取粒子总数。 代码： virtual void startParticleSystem() override; virtual void stopParticleSystem() override; virtual void pauseParticleSystem() override; virtual void resumeParticleSystem() override; virtual int getAliveParticleCount() const override; PUParticleSystem3D 派生自 Node 对象，所以你可以为刚刚创建的粒子，增加动作和序列！ 示例： auto ps = PUParticleSystem3D::create(\"blackHole.pu\", \"pu_mediapack_01.material\"); ps->setPosition(-25.0f, 0.0f); auto moveby = MoveBy::create(2.0f, Vec2(50.0f, 0.0f)); auto moveby1 = MoveBy::create(2.0f, Vec2(-50.0f, 0.0f)); ps->runAction(RepeatForever::create(Sequence::create(moveby, moveby1, nullptr))); ps->startParticleSystem(); 组合动作和序列可能会产生有趣的黑洞效果 可以使用 AttachNode 将粒子绑定到其它 3D 模型上，示例： auto sprite3d = Sprite3D::create(\"orc.c3b\"); sprite3d->setPosition3D(Vec3(0.0f, 0.0f, 0.0f)); sprite3d->setRotation3D(Vec3(0.0f, 180.0f, 0.0f)); auto animation = Animation3D::create(\"orc.c3b\"); if (animation) { auto animate = Animate3D::create(animation); sprite3d->runAction(RepeatForever::create(animate)); } auto handler = PUParticleSystem3D::create(\"lightningBolt.pu\"); handler->startParticleSystem(); sprite3d->getAttachNode(\"Bip001 L Hand\")->addChild(handler); this->addChild(sprite3d); "},"scripting/":{"url":"scripting/","title":"使用脚本","keywords":"","body":"使用脚本 脚本组件 脚本组件是用来扩展 C++ 节点对象的一种方式，你可以将脚本组件绑定到节点对象上，然后脚本组件就能收到 onEnter，onExit 和 update 事件。 脚本组件支持两种脚本语言 JavaScript 和 Lua，使用的脚本组件应该和绑定脚本的语言类型对应，比如 ComponentJS 用来绑定 JavaScript 脚本，ComponentLua 用来绑定 Lua 脚本。有了脚本组件，你就可以在 Cocos2d-x 的项目中，很方便的使用脚本进行一些控制。需要注意的是，在一个项目中不能混用脚本组件，也就是说一个项目要么只使用 JavaScript 脚本，要么只使用 Lua 脚本。 使用 Lua 脚本： // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto luaComponent = ComponentLua::create(\"player.lua\"); player->addComponent(luaComponent); -- player.lua local player = { onEnter = function(self) -- do some things in onEnter end, onExit = function(self) -- do some things in onExit end, update = function(self) -- do some things every frame end } -- it is needed to return player to let c++ nodes know it return player 使用 JavaScript 脚本: // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto jsComponent = ComponentJS::create(\"player.js\"); player->addComponent(jsComponent); // player.js Player = cc.ComponentJS.extend({ generateProjectile: function (x, y) { var projectile = new cc.Sprite(\"components/Projectile.png\", cc.rect(0, 0, 20, 20)); var scriptComponent = new cc.ComponentJS(\"src/ComponentTest/projectile.js\"); projectile.addComponent(scriptComponent); this.getOwner().getParent().addChild(projectile); // set position var winSize = cc.director.getVisibleSize(); var visibleOrigin = cc.director.getVisibleOrigin(); projectile.setPosition(cc.p(visibleOrigin.x + 20, visibleOrigin.y + winSize.height/2)); // run action var posX = projectile.getPositionX(); var posY = projectile.getPositionY(); var offX = x - posX; var offY = y - posY; if (offX 注意，两种组件的使用上，有一个重要的区别。使用 Lua 组件，Lua 脚本最后需要返回 Lua 对象，使用 JavaScript 组件，JavaScript 脚本需要扩展 cc.ComponentJS。 更详细用法，请参考 Cocos2d-x 引擎的测试项目：tests/lua-tests/src/ComponentTest and tests/js-tests/src/ComponentTest。 "},"scripting/script_component.html":{"url":"scripting/script_component.html","title":"Script component","keywords":"","body":"Script component Script component is used to extend c++ Node objects. You can add a script component to a Node, then the script component will receive onEnter, onExit and update events. Script component supports both JavaScript and LUA. You should use the proper script component type for the language you are developing with. If you are developing with JavaScript, you would use ComponentJS, if you are developing with Lua, you would use ComponentLUA. But, you cannot mix them or use them in a c++ project! This is because the proper bindings for that language are required and these bindings are only available in their respective project types. Example with Lua: // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto luaComponent = ComponentLua::create(\"player.lua\"); player->addComponent(luaComponent); -- player.lua local player = { onEnter = function(self) -- do some things in onEnter end, onExit = function(self) -- do some things in onExit end, update = function(self) -- do some things every frame end } -- it is needed to return player to let c++ nodes know it return player Example with JavaScript: // create a Sprite and add a LUA component auto player = Sprite::create(\"player.png\"); auto jsComponent = ComponentJS::create(\"player.js\"); player->addComponent(jsComponent); // player.js Player = cc.ComponentJS.extend({ generateProjectile: function (x, y) { var projectile = new cc.Sprite(\"components/Projectile.png\", cc.rect(0, 0, 20, 20)); var scriptComponent = new cc.ComponentJS(\"src/ComponentTest/projectile.js\"); projectile.addComponent(scriptComponent); this.getOwner().getParent().addChild(projectile); // set position var winSize = cc.director.getVisibleSize(); var visibleOrigin = cc.director.getVisibleOrigin(); projectile.setPosition(cc.p(visibleOrigin.x + 20, visibleOrigin.y + winSize.height/2)); // run action var posX = projectile.getPositionX(); var posY = projectile.getPositionY(); var offX = x - posX; var offY = y - posY; if (offX One difference to keep in mind, between JavaScript and LUA components, is you should return the object in LUA component, in JavaScript, you only have to extend cc.ComponentJS For more detailed usage, please refer to tests projects: tests/lua-tests/src/ComponentTest and tests/js-tests/src/ComponentTest. getOpenGLView | | cc.GLViewImpl:create(\"Lua Empty Test\") | cocos2d::GLViewImpl::create(\"Lua Empty Test\") | | glView:setDesignResolutionSize(480, 320, cc.ResolutionPolicy.NO_BORDER) | glview->glView:setDesignResolutionSize(480, 320, ResolutionPolicy::NO_BORDER)| ``` From this table, we can see that the functions called in lua are very similar with the functions called in c++. These are some key points that we need to pay attention to: - `cc` is a module name like namespace name in c++,it is Cocos2d-x 3.0 new features. The relation between lua modules and c++ namespaces is as follow: ```cpp | Lua module name | c++ namespace | | cc | cocos2d, cocos2d::extension, CocosDenshion, cocosbuilder | | ccui | cocos2d::ui | | ccs | cocostudio, cocostudio::timeline | | sp | spine | | ccexp | cocos2d::experimental, cocos2d::experimental::ui | ``` - static and non-static c++ functions are called in lua using `:` - `cc.ResolutionPolicy.NO_BORDER` corresponds to `ResolutionPolicy::NO_BORDER` which is enum value in the c++. `enum` values are bound to lua by manual. Different modules use different lua files to keep the bindings value: ```cpp | moudle name | const value files | | cc | Cocos2dConstants.lua, ExtensionConstants.lua, NetworkConstants.lua| | ccui | GuiConstants.lua | | ccs | StudioConstants.lua| | ccexp | experimentalUIConstants.lua| ``` - For some functions, their parameters include cocos2d::Vec2, cocos2d::Vec3 we should do a conversion to call c++ function.For example: ```cpp void Node::setPosition(const Vec2& position) ``` In c++, we should call this function like this: ```cpp nodeObj->setPosition(Vec2(0.0f, 0.0f)) ``` In lua, we should call the function like this: ```cpp nodeObj:setPosition(cc.p(0.0, 0.0)) ``` `cc.p(0.0, 0.0)` is to construct an anonymous table like this {x = 0, y =0} The other parametric types that should be converted are: ``` | parametric types | lua conversional format | | cocos2d::Point | {x = numValue, y = numValue} | | cocos2d::Vec3 | {x = numValue, y = numValue, z = numValue} | | cocos2d::Vec4 | {x = numValue, y = numValue, z = numValue, w = numValue} | | cocos2d::Rect | {x = numValue, y = numValue, width = numValue, height = numValue} | | cocos2d::Size | {width = numValue, height = numValue} | | cocos2d::Color4B | {r = numValue, g = numValue, b = numValue, a = numValue} | | cocos2d::Color4F | {r = numValue, g = numValue, b = numValue, a = numValue} | | cocos2d::Color3B | {r = numValue, g = numValue, b = numValue} | | cocos2d::PhysicsMaterial | {density = numValue, restitution = numValue, friction = numValue} | | cocos2d::AffineTransform | {a = numValue, b = numValue, c = numValue, d = numValue, tx = numValue, ty = numValue} | | cocos2d::FontDefinition | {fontName = stringValue, fontSize = numValue, fontAlignmentH = numValue, fontAlignmentV = numValue, fontFillColor = {r = numValue, g = numValue, b = numValue}, fontDimensions = {width = numValue, height = numValue}, shadowEnabled = boolValue[,shadowOffset = {width = numValue, height = numValue}, shadowBlur = numValue, shadowOpacity = numValue], strokeEnabled = boolValue[,strokeColor = {r = numValue, g = numValue, b = numValue}, strokeSize = numValue]} | | cocos2d::Vector | {objValue1,objValue2,...,objValuen,...}| | cocos2d::Map| {key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} | | cocos2d::Value | {objValue1,objValue2,...,objValuen,...} or key1 = objValue1, key2 = objValue2,..., keyn = objValuen,...} or stringValue or boolValue or numValue | | cocos2d::ValueMap | {key1 = Value1, key2 = Value2,..., keyn = Valuen,...} | | cocos2d::ValueMapIntKey | {numKey1 = Value1, intKey2 = Value2, ...,intKeyn = Valuen,...} | | cocos2d::ValueVector | {Value1, Value2, ..., Valuen, ...} | | std::vector | {stringValue1, stringValue2, ..., stringValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | std::vector | {numValue1, numValue2, ..., numValuen, ...} | | cocos2d::Mat4 | {numValue1,numValue2,..., numValue16} | | cocos2d::TTFConfig |{fontFilePath = stringValue, fontSize = numValue, glyphs = numValue, customGlyphs = stringValue, distanceFieldEnabled = boolValue, outlineSize = numValue} | cocos2d::MeshVertexAttrib| {size = numValue, type = numValue, vertexAttrib = numValue, vertexAttrib =numValue} | | cocos2d::BlendFunc | { src = numValue, dst = numValue} | ``` ### Call global functions Cocos2d-x v3 also binds some global functions to lua manually, such as `kmGLPushMatrix`, `kmGLTranslatef` and `kmGLLoadMatrix`. We can call these global functions in lua as follows: ```cpp kmGLPopMatrix() ``` ### Call OpenGL functions Cocos2d-x v3 binds some OpenGL functions to lua. All the OpenGL functions are in the `gl` module and can be called as follows: ```cpp local glNode = gl.glNodeCreate() glNode:setContentSize(cc.size(256, 256)) glNode:setAnchorPoint(cc.p(0.5, 0.5)) uniformCenter = gl.getUniformLocation(program,\"center\") uniformResolution = gl.getUniformLocation( program, \"resolution\") ``` You can refer to `lua-tests/DrawPrimitiveTest` and `lua-tests/OpenGLTest` for more information. ## Bind a c++ class to lua by bindings-generator automatically Since Cocos2d-x v3.0, there is a tools called [bindings-generator](https://github.com/cocos2d/bindings-generator) to bind c++ class to lua automatically. The _bindings-generator_ is based on _tolua++_. There is an _ini_ file in the `tools/tolua` directory and then run the _genbindings.py_ script to generate the binding code. ### Create a custom class Consider this code: ```cpp // CustomClass.h #ifndef __CUSTOM__CLASS #define __CUSTOM__CLASS #include \"cocos2d.h\" namespace cocos2d { class CustomClass : public cocos2d::Ref { public: CustomClass(); ~CustomClass(); static cocos2d::CustomClass* create(); bool init(); CREATE_FUNC(CustomClass); }; } //namespace cocos2d #endif // __CUSTOM__CLASS ``` Note: - the cpp file was omitted because the bindings-generator only scan the header files - The custom class should be inherited from the `Ref` class, this is mainly due to the destructor of `Ref` calling `removeScriptObjectByObject` to reduce the reference count of _userdata_ which gets created in the c++ automatically to avoid memory leak. ### Add a new cocos2dx_custom.ini file In _tools/lua_ folder create a new file named _cocos2dx_custom.ini_ as: ```cpp [cocos2dx_custom] # the prefix to be added to the generated functions. You might or might not use this in your own # templates prefix = cocos2dx_custom # create a target namespace (in javascript, this would create some code like the equiv. to `ns = ns # all classes will be embedded in that namespace target_namespace = cc android_headers = -I%(androidndkdir)s/platforms/android-14/arch-arm/usr/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.7/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/libs/armeabi-v7a/include -I%(androidndkdir)s/sources/cxx-stl/gnu-libstdc++/4.8/include android_flags = -D_SIZE_T_DEFINED_ clang_headers = -I%(clangllvmdir)s/lib/clang/3.3/include clang_flags = -nostdinc -x c++ -std=c++11 -U __SSE__ cocos_headers = -I%(cocosdir)s/cocos -I%(cocosdir)s/my -I%(cocosdir)s/cocos/2d -I%(cocosdir)s/cocos/base -I%(cocosdir)s/cocos/ui -I%(cocosdir)s/cocos/physics -I%(cocosdir)s/cocos/2d/platform -I%(cocosdir)s/cocos/2d/platform/android -I%(cocosdir)s/cocos/math/kazmath -I%(cocosdir)s/extensions -I%(cocosdir)s/external -I%(cocosdir)s/cocos/editor-support -I%(cocosdir)s cocos_flags = -DANDROID -DCOCOS2D_JAVASCRIPT cxxgenerator_headers = # extra arguments for clang extra_arguments = %(android_headers)s %(clang_headers)s %(cxxgenerator_headers)s %(cocos_headers)s %(android_flags)s %(clang_flags)s %(cocos_flags)s %(extra_flags)s # what headers to parse headers = %(cocosdir)s/cocos/my/CustomClass.h # what classes to produce code for. You can use regular expressions here. # When testing the regular expression, it will be enclosed in \"^$\", like # this: \"^Menu*$\". classes = CustomClass.* # what should we skip? in the format ClassName::[function function] # ClassName is a regular expression, but will be used like this: # \"^ClassName$\" functions are also regular expressions, they will not be # surrounded by \"^$\". If you want to skip a whole class, just add a single # \"*\" as functions. See bellow for several examples. A special class name # is \"*\", which will apply to all class names. This is a convenience # wildcard to be able to skip similar named functions from all classes. skip = rename_functions = rename_classes = # for all class names, should we remove something when registering in the # target VM? remove_prefix = # classes for which there will be no \"parent\" lookup classes_have_no_parents = # base classes which will be skipped when their sub-classes found them. base_classes_to_skip = # classes that create no constructor # Set is special and we will use a hand-written constructor abstract_classes = # Determining whether to use script object(js object) to control the # lifecycle of native(cpp) object or the other way around. Supported # values are 'yes' or 'no'. script_control_cpp = no ``` All of the config files under _tools/tolua_ use the same format. Here is a list which you should consult when writing your own ini file: - [title]: To config the title which will by used by the *tools/tolua/gengindings.py* scripts. Generally, the title could be the file name. - prefix: To config the prefix of a function name, generally, we also use the file name as the prefix. - target_namespace: To config the module name in lua. Here we use the `cc` as the module name, when you want to use `CustomClass` in lua, you must put a prefix named `cc` in front of the name. For example, the `CustomClass` could be reference as `cc.CustomClass`. - headers: To config all the header files needed for parsing and the %(cocosdir)s is the engine root path of Cocos2d-x. - classes: To config all the classes needed to bind. Here it supports regular expression. So we could set MyCustomClass.* here. For looking more specified usage, you could ref to `tools/tolua/cocos2dx.ini`. - skip: To config the functions needed to be omit. Now the bindings-generator can't parse `void*` type and also the delegate type, so these types needed to be bind manually. And at this circumstance, you should omit all these types first and then to bind them manually. You could ref to the config files under path `cocos/scripting/lua-bindings/auto` . - rename_functions: To config the functions need to be renamed in the scripting layer. Due to some reasons, developers want more scripting friendly API, so the config option is for this purpose. - rename_classes: Not used any more. - remove_prefix: Not used any more. - classes_have_no_parents: To config the parent class needed to be filter. This option is seldom modified. - abstract_classes: To config the classes whose public constructor don't need to be exported. - script_control_cpp:yes. To config whether the scripting layer manage the object life time or not. If no, then the c++ layer cares about their life time. Now, it is imperfect to control native object's life time in scripting layer. So you could simply leave it to *no*. ## Subclassing Sometimes we want to add some new functions to extend the bindings, think inheritance in c++. Through `class(classname, super)` function in the `cocos/scripting/lua-bindings/script/cocos2d/extern.lua`, we can realize this requirement easily. The details function are as follow: ```cpp function class(classname, super) local superType = type(super) local cls if superType ~= \"function\" and superType ~= \"table\" then superType = nil super = nil end if superType == \"function\" or (super and super.__ctype == 1) then -- inherited from native C++ Object cls = {} if superType == \"table\" then -- copy fields from super for k,v in pairs(super) do cls[k] = v end cls.__create = super.__create cls.super = super else cls.__create = super end cls.ctor = function() end cls.__cname = classname cls.__ctype = 1 function cls.new(...) local instance = cls.__create(...) -- copy fields from class to native object for k,v in pairs(cls) do instance[k] = v end instance.class = cls instance:ctor(...) return instance end else -- inherited from Lua Object if super then cls = clone(super) cls.super = super else cls = {ctor = function() end} end cls.__cname = classname cls.__ctype = 2 -- lua cls.__index = cls function cls.new(...) local instance = setmetatable({}, cls) instance.class = cls instance:ctor(...) return instance end end return cls end ``` Through this function, we can see inheritance easily. Example, if we want to derive from `cc.Node`: 1. Define a subclass by `class` function ```cpp local SubNode = class(\"SubNode\",function() return cc.Node:create() end) --This function like the construtor of c++ class function SubNode:ctor() -- do initialized end function SubNode:addSprite(filePath) local sprite = cc.Sprite:create(filePath) sprite:setPosition(cc.p(0, 0)) self:addChild(sprite) end ``` 2. Create an object of subclass and use it: ```cpp local node = SubNode.new() node:addSprite(\"xxx.jpg\") ``` Note: `new` is implemented by default in the `class` function. Since the type of the second parameter is `function`, when we call `new`, this is what happens: ```cpp function SubNode.new(...) local instance = cc.Node:create() -- copy fields from SubNode to native object for k,v in pairs(SubNode) do instance[k] = v end instance.class = SubNode instance:ctor(...) return instance end ``` The object created by `new` have all the properties and behaviors of the `cc.Node` object. It also has the properties of the `SubNode` as it is derived from `cc.Node`: ```cpp function SubNode:setPostion(x,y) print(string.format(\"x = %0.2f, y = %0.2f\"), x, y) end ``` If we still need to call the function of the same name of super class: ```cpp getmetatable(SubNode):setPosition(x, y) ``` - The override functions of inherited class in lua can't be called in the c++. ## Memory Management Cocos2d-x v3.x uses the memory management and garbage collection of lua itself except the release of `userdata`. If the corresponding classes are derived from `Ref` the release of `userdata` is managed in c++ by the register table named `toluafix_refid_ptr_mapping` and `tolua_value_root`. ### Simple Test Case 1. Create a `Sprite` in the head of `createDog` function ```cpp local testSprite = cc.Sprite:create(\"res/land.png\") ``` 2. Then call the `Sprite` in the `tick` function as follow: ```cpp testSprite:getPosition() ``` 3. After a period of time, we will see the error message as follows: ```cpp cocos2d: [LUA-print] stack traceback: [string \"src/hello.lua\"]:13: in function [C]: in function 'getPosition' [string \"src/hello.lua\"]:98: in function cocos2d: [LUA-print] ---------------------------------------- cocos2d: [LUA-print] ---------------------------------------- cocos2d: [LUA-print] LUA ERROR: [string \"src/hello.lua\"]:98: invalid 'self' in function 'tolua_cocos2d_Node_getPosition' ``` This error is triggered because the _testsprite_ didn't add any other node as a child after creation. The corresponding c++ object was released at the end of the frame. ### Memory Management for Class Object #### The Class Members of Ref Class for Memory Management In `CCRef.h` we see the usage of `CC_ENABLE_SCRIPT_BINDING`: ```cpp #if CC_ENABLE_SCRIPT_BINDING public: /// object id, ScriptSupport need public _ID unsigned int _ID; /// Lua reference id int _luaID; /// scriptObject, support for swift void* _scriptObject; #endif ``` Notice `_ID` and `_luaID`, are very important when you push a `Ref` object to lua by calling `toluafix_pushusertype_ccobject` to store a key-value table named `toluafix_refid_ptr_mapping` in the registry. The `_ID` is key and the related c++ object pointer is value. The related code fragment in the `toluafix_pushusertype_ccobject` is: ```cpp //Extract from `toluafix_pushusertype_ccobject` in the tolua_fix.cpp lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushlightuserdata(L, vPtr); /* stack: refid_ptr refid ptr */ lua_rawset(L, -3); /* refid_ptr[refid] = ptr, stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ ``` Notes: - `TOLUA_REFID_PTR_MAPPING` is macro definition represent for \"toluafix_refid_ptr_mapping\" - `LUA_REGISTRYINDEX` is definition of `Pseudo-Index` for registry of Lua - `refid` is value of `_ID` - `vPtr` is value of related c++ object pointer #### Create a Ref object from Lua - Call the `cocos2d::Sprite::create(\"res/land.png\")` by lua bindings to create a Sprite object and push it into lua stack: ```cpp //Extract from `lua_cocos2dx_Sprite_create` in lua_cocos2dx_auto.cpp std::string arg0; ok &= luaval_to_std_string(tolua_S, 2,&arg0, \"cc.Sprite:create\"); if (!ok) { break; } cocos2d::Sprite* ret = cocos2d::Sprite::create(arg0); object_to_luaval(tolua_S, \"cc.Sprite\",(cocos2d::Sprite*)ret); return 1; ``` - Call `toluafix_pushusertype_ccobject` when push created object to lua stack ```cpp //Extract from `object_to_luaval` in luaBasicConversions.h if (std::is_base_of::value) { // use c style cast, T may not polymorphic cocos2d::Ref* dynObject = (cocos2d::Ref*)(ret); int ID = (int)(dynObject->_ID) ; int* luaID = &(dynObject->_luaID); toluafix_pushusertype_ccobject(L,ID, luaID, (void*)ret,type); } ``` In the `toluafix_pushusertype_ccobject` , we will use two tables named \"toluafix_refid_ptr_mapping\" and \"toluafix_refid_type_mapping\" in lua's registry to store the two key-value pairs about `_ID`-`object pointer` and `_ID`-`object type name`.The details are as follow: ```cpp //Extract from `toluafix_pushusertype_ccobject` in the tolua_fix.cpp if (*p_refid == 0) { *p_refid = refid; lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushlightuserdata(L, vPtr); /* stack: refid_ptr refid ptr */ lua_rawset(L, -3); /* refid_ptr[refid] = ptr, stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ lua_pushstring(L, TOLUA_REFID_TYPE_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_type */ lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_pushstring(L, vType); /* stack: refid_type refid type */ lua_rawset(L, -3); /* refid_type[refid] = type, stack: refid_type */ lua_pop(L, 1); /* stack: - */ //printf(\"[LUA] push CCObject OK - refid: %d, ptr: %x, type: %s\\n\", //*p_refid, (int)ptr, type); } ``` - Call `tolua_pushusertype_internal` to determine whether to create a new userdata, or just update the userdata. ```cpp void tolua_pushusertype_internal (lua_State* L, void* value, const char* type, int addToRoot) { if (value == NULL) lua_pushnil(L); else { luaL_getmetatable(L, type); /* stack: mt */ if (lua_isnil(L, -1)) { /* NOT FOUND metatable */ lua_pop(L, 1); return; } lua_pushstring(L,\"tolua_ubox\"); lua_rawget(L,-2); /* stack: mt ubox */ if (lua_isnil(L, -1)) { lua_pop(L, 1); lua_pushstring(L, \"tolua_ubox\"); lua_rawget(L, LUA_REGISTRYINDEX); }; lua_pushlightuserdata(L,value); /* stack: mt ubox key */ lua_rawget(L,-2); /* stack: mt ubox ubox[value] */ if (lua_isnil(L,-1)) { lua_pop(L,1); /* stack: mt ubox */ lua_pushlightuserdata(L,value); *(void**)lua_newuserdata(L,sizeof(void *)) = value; /* stack: mt ubox value newud */ lua_pushvalue(L,-1); /* stack: mt ubox value newud newud */ lua_insert(L,-4); /* stack: mt newud ubox value newud */ lua_rawset(L,-3); /* ubox[value] = newud, stack: mt newud ubox */ lua_pop(L,1); /* stack: mt newud */ /*luaL_getmetatable(L,type);*/ lua_pushvalue(L, -2); /* stack: mt newud mt */ lua_setmetatable(L,-2); /* update mt, stack: mt newud */ # ifdef LUA_VERSION_NUM lua_pushvalue(L, TOLUA_NOPEER); /* stack: mt newud peer */ lua_setfenv(L, -2); /* stack: mt newud */ #endif } else { /* check the need of updating the metatable to a more specialized class */ lua_insert(L,-2); /* stack: mt ubox[u] ubox */ lua_pop(L,1); /* stack: mt ubox[u] */ lua_pushstring(L,\"tolua_super\"); lua_rawget(L,LUA_REGISTRYINDEX); /* stack: mt ubox[u] super */ lua_getmetatable(L,-2); /* stack: mt ubox[u] super mt */ lua_rawget(L,-2); /* stack: mt ubox[u] super super[mt] */ if (lua_istable(L,-1)) { lua_pushstring(L,type); /* stack: mt ubox[u] super super[mt] type */ lua_rawget(L,-2); /* stack: mt ubox[u] super super[mt] flag */ if (lua_toboolean(L,-1) == 1) /* if true */ { lua_pop(L,3); /* mt ubox[u]*/ lua_remove(L, -2); return; } } /* type represents a more specilized type */ /*luaL_getmetatable(L,type);// stack: mt ubox[u] super super[mt] flag mt */ lua_pushvalue(L, -5); /* stack: mt ubox[u] super super[mt] flag mt */ lua_setmetatable(L,-5); /* stack: mt ubox[u] super super[mt] flag */ lua_pop(L,3); /* stack: mt ubox[u] */ } lua_remove(L, -2); /* stack: ubox[u]*/ if (0 != addToRoot) { lua_pushvalue(L, -1); tolua_add_value_to_root(L, value); } } } ``` We use a table named `ubox` to store key-value pairs about `userdata` and `object pointer`. This table would be used in the destruction of the object. - Call `tolua_add_value_to_root` to add a reference count for `userdata` in lua by the `tolua_value_root` table in lua registry. The mechanism will make the object in lua wouldn't collected by lua gc. Example: ```cpp local node = cc.Node:create() node.extendValue = 10000 nodeParent:addChild(node, 0 , 9999) ``` This code creates a `node` object and extends the attributes of the node object dynamically by lua's feature. When we want to get this node and its extended attribute somewhere, we can do as follows: ```cpp local child = lnodeParent:getChildByTag(9999) print(child.extendValue) ``` If we don't call the `tolua_add_value_to_root`, the result of `print(child.extendValue)` would be uncertain. Sometimes the result would be 10000 and sometimes it would be `nil`. This is because we wouldn't control lua's automatic gc effectively. When lua gc thinks there are no other references for this userdata it will collect this userdata. When we call `getChildByTag` to get a node object, it would create a new userdata and the extended attributes would disapper. We add a reference count for the userdata `tolua_value_root` table in lua registry in the c++ to avoid generating this error. #### The Release of the Userdata When calling the desturctor of `Ref`, it will trigger the release of the userdata. In the destructor of Ref, we can see: ```cpp #if CC_ENABLE_SCRIPT_BINDING // if the object is referenced by Lua engine, remove it if (_luaID) { ScriptEngineManager::getInstance()->getScriptEngine()->removeScriptObjectByObject(this); } ... #endif ``` After we push a c++ object to lua, the related _luaID would be not 0. We now can call `removeScriptObjectByObject` The `removeScriptObjectByObject` called would trigger the call of `toluafix_remove_ccobject_by_refid`, and this function would call some lua c APIs to operate the table like `toluafix_refid_ptr_mapping`, `toluafix_refid_type_mapping` and `tolua_value_root` table in the registry. The specific implementation of `toluafix_remove_ccobject_by_refid` is as follows: ```cpp TOLUA_API int toluafix_remove_ccobject_by_refid(lua_State* L, int refid) { void* ptr = NULL; const char* type = NULL; void** ud = NULL; if (refid == 0) return -1; // get ptr from tolua_refid_ptr_mapping lua_pushstring(L, TOLUA_REFID_PTR_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_ptr */ lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_rawget(L, -2); /* stack: refid_ptr ptr */ ptr = lua_touserdata(L, -1); lua_pop(L, 1); /* stack: refid_ptr */ if (ptr == NULL) { lua_pop(L, 1); // Lua stack has closed, C++ object not in Lua. // printf(\"[LUA ERROR] remove CCObject with NULL ptr, refid: %d\\n\", refid); return -2; } // remove ptr from tolua_refid_ptr_mapping lua_pushinteger(L, refid); /* stack: refid_ptr refid */ lua_pushnil(L); /* stack: refid_ptr refid nil */ lua_rawset(L, -3); /* delete refid_ptr[refid], stack: refid_ptr */ lua_pop(L, 1); /* stack: - */ // get type from tolua_refid_type_mapping lua_pushstring(L, TOLUA_REFID_TYPE_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: refid_type */ lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_rawget(L, -2); /* stack: refid_type type */ if (lua_isnil(L, -1)) { lua_pop(L, 2); printf(\"[LUA ERROR] remove CCObject with NULL type, refid: %d, ptr: %p\\n\", refid, ptr); return -1; } type = lua_tostring(L, -1); lua_pop(L, 1); /* stack: refid_type */ // remove type from tolua_refid_type_mapping lua_pushinteger(L, refid); /* stack: refid_type refid */ lua_pushnil(L); /* stack: refid_type refid nil */ lua_rawset(L, -3); /* delete refid_type[refid], stack: refid_type */ lua_pop(L, 1); /* stack: - */ // get ubox luaL_getmetatable(L, type); /* stack: mt */ lua_pushstring(L, \"tolua_ubox\"); /* stack: mt key */ lua_rawget(L, -2); /* stack: mt ubox */ if (lua_isnil(L, -1)) { // use global ubox lua_pop(L, 1); /* stack: mt */ lua_pushstring(L, \"tolua_ubox\"); /* stack: mt key */ lua_rawget(L, LUA_REGISTRYINDEX); /* stack: mt ubox */ }; // cleanup root tolua_remove_value_from_root(L, ptr); lua_pushlightuserdata(L, ptr); /* stack: mt ubox ptr */ lua_rawget(L,-2); /* stack: mt ubox ud */ if (lua_isnil(L, -1)) { // Lua object has released (GC), C++ object not in ubox. //printf(\"[LUA ERROR] remove CCObject with NULL ubox, refid: %d, ptr: %x, type: %s\\n\", refid, (int)ptr, type); lua_pop(L, 3); return -3; } // cleanup peertable lua_pushvalue(L, LUA_REGISTRYINDEX); lua_setfenv(L, -2); ud = (void**)lua_touserdata(L, -1); lua_pop(L, 1); /* stack: mt ubox */ if (ud == NULL) { printf(\"[LUA ERROR] remove CCObject with NULL userdata, refid: %d, ptr: %p, type: %s\\n\", refid, ptr, type); lua_pop(L, 2); return -1; } // clean userdata *ud = NULL; lua_pushlightuserdata(L, ptr); /* stack: mt ubox ptr */ lua_pushnil(L); /* stack: mt ubox ptr nil */ lua_rawset(L, -3); /* ubox[ptr] = nil, stack: mt ubox */ lua_pop(L, 2); //printf(\"[LUA] remove CCObject, refid: %d, ptr: %x, type: %s\\n\", refid, (int)ptr, type); return 0; } ``` The steps are as follows: - Get related object pointer stored in the `toluafix_refid_ptr_mapping` table by the value of `_luaID`. Store it. - Remove reference relationship of the object pointer from `toluafix_refid_ptr_mapping` table by `_luID` - Get related type name stored in the `tolua_refid_type_mapping` table by the value of `_luaID`,then store it - Remove reference relationship of type name from `tolua_refid_type_mapping` table by `_luID` - Get the related metatable by the type name - Get the `ubox` table - Remove reference relationship of userdata from `tolua_value_root` table by the object pointer got in the upper step - Clean userdata and remove reference relationship of userdata from `ubox` by the object pointer got in the upper step.Note:To destroy an object cited by lua, we only called '*ud = NULL;' Through the above steps,the refernce relationships in the `toluafix_refid_ptr_mapping`,`tolua_refid_type_mapping` and `tolua_refid_type_mapping` table in the registry would be removed, release the `userdata` which is created when push c++ object to lua stack, and when lua gc trigger, the related object would be collected if there is no other place refer to it. ### Memory Management for Lua Callback Function Cocos2dx have been used `toluafix_refid_function_mapping` table in the registry to manage the gc of lua callback function #### Add a reference for Lua Callback Function When we define a lua function which would be called throuch c++ codes, we whould store the pointer of this function in the `toluafix_refid_function_mapping` table by calling `toluafix_ref_function` function in the `tolua_fix.cpp`.Cocos2d-x bound a series of functions like `registerScriptHandler` and `addEventListener` to finish this work. Let's use `registerScriptHandler` of `Node` as a sample,we could use it as follows in lua: ``` local function onNodeEvent(event) if \"enter\" == event then --do something end end nodeObject:registerScriptHandler(onNodeEvent) ``` The related bindings function is named `tolua_cocos2d_Node_registerScriptHandler` in the `lua_cocos2dx_manual.cpp`,the most important sections are as follows: ``` LUA_FUNCTION handler = toluafix_ref_function(tolua_S,2,0); ScriptHandlerMgr::getInstance()->addObjectHandler((void*)self, handler, ScriptHandlerMgr::HandlerType::NODE); ``` - `toluafix_ref_function` is implemented to store the related function pointer into `toluafix_refid_function_mapping` table in the registry with a static variable named `s_function_ref_id`.This operation makes lua function avoid being collected by lua gc because that `toluafix_refid_function_mapping` table have a reference of this function. The details are as follow: ``` TOLUA_API int toluafix_ref_function(lua_State* L, int lo, int def) { // function at lo if (!lua_isfunction(L, lo)) return 0; s_function_ref_id++; lua_pushstring(L, TOLUA_REFID_FUNCTION_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: fun ... refid_fun */ lua_pushinteger(L, s_function_ref_id); /* stack: fun ... refid_fun refid */ lua_pushvalue(L, lo); /* stack: fun ... refid_fun refid fun */ lua_rawset(L, -3); /* refid_fun[refid] = fun, stack: fun ... refid_ptr */ lua_pop(L, 1); /* stack: fun ... */ return s_function_ref_id; } ``` - `addObjectHandler` is used to stored the map of object pointer and pair of `s_function_ref_id` and handler type. #### Remove a reference for Lua Callback Function If lua callback function become useless, we should remove the reference in the `toluafix_refid_function_mapping` table in the registry. Cocos2d-x provided the `toluafix_remove_function_by_refid` function to realize it. This function could be called by `removeScriptHandler` of `LuaStack`,`removeScriptHandler` of `LuaEngine` or directly. The details are as follows: ``` TOLUA_API void toluafix_remove_function_by_refid(lua_State* L, int refid) { lua_pushstring(L, TOLUA_REFID_FUNCTION_MAPPING); lua_rawget(L, LUA_REGISTRYINDEX); /* stack: ... refid_fun */ lua_pushinteger(L, refid); /* stack: ... refid_fun refid */ lua_pushnil(L); /* stack: ... refid_fun refid nil */ lua_rawset(L, -3); /* refid_fun[refid] = nil, stack: ... refid_fun */ lua_pop(L, 1); /* stack: ... */ } ``` Note: - `refid` is the corresponding value of `s_function_ref_id`. - For Ref object,we would call `ScriptHandlerMgr::getInstance()->removeObjectAllHandlers` to remove all the reference function relationship which added by the `ScriptHandlerMgr::getInstance()->addObjectHandler` automatically - Because Cocos2d-x v3.x support the features of c++ 11, we can call the related remove function through the lambda function. For example: ``` //Extract from `lua_cocos2dx_TextureCache_addImageAsync` in lua_cocos2dx_manual.cpp LUA_FUNCTION handler = ( toluafix_ref_function(tolua_S, 3, 0)); self->addImageAsync(configFilePath, [=](Texture2D* tex){ int ID = (tex) ? (int)tex->_ID : -1; int* luaID = (tex) ? &tex->_luaID : nullptr; toluafix_pushusertype_ccobject(tolua_S, ID, luaID, (void*)tex, \"cc.Texture2D\"); LuaEngine::getInstance()->getLuaStack()->executeFunctionByHandler(handler,1); LuaEngine::getInstance()->removeScriptHandler(handler); }); ``` By the mechanism of the lambda, we could get the value of handler which represents the corresponding value of `s_function_ref_id`. When we finish calling lua callback function,we could call `LuaEngine::getInstance()->removeScriptHandler(handler)` directly to remove the reference of lua callback function. ## Use Cocos Code IDE to Debug a Lua Game Cocos Code IDE is tool that can debug a lua script,it has windows and mac version. You can debug Windows and Android lua games through the windows version and you can debug Mac, iOS and android lua games through the Mac version. Now we will demonstrate how to use Cocos Code IDE to debug a lua game based on the mac version. The process of the windows version is almost the same. ## Prerequisite If you have been not installed the Cocos Code IDE,you can refer to [Cocos Code IDE Installation](https://cocos2d-x.org/wiki/Cocos_Code_IDE). ## Cocos Code IDE Configuration ### Basic Settings Click `Cocos Code IDE/Preferences` to open the configuration dialog,then select the `Cocos/Lua` to set the directory of Cocos2d-x v3.x in the `Lua Frameworks`: ![](10-img/lua_cocos_preferences.png) ### Additional Settings You should set directory of some compliling tools about android if you need to replace the Android runtime which Cocos Code IDE provided. Click `Cocos Code IDE/Preferences` then pitch on `Cocos` to configurate the directory of related tools: ![](10-img/cocos_preferences.png) ## Debug a Lua Game 1. Create a new Cocos Lua Project by the right click menu in the `Lua Projects Explorer` ![](10-img/lua_create_project.png) 2. Select `src/GameScene.lua` and open it,then toggle breakpoint by right click menu or double click ![](10-img/lua_toggle_breakpoint.png) 3.Click debug button on toolbar ![](10-img/lua_debug_button.png) 4.Trigger the breakpoint,select \"Yes\" to open `Debug Perspective`,and you will find many useful debug views like `Call stacks`, `Variables` and `Breakpoints`,etc. ![](10-img/lua_confirm_perspective.png) ![](10-img/lua_debug_dialog.png) 5.Use `Step over`, `Step into`, `Step out` in the tool bar to debug ![](10-img/lua_step_debug.png) ## Code Hot Updating when Debugging We could realize the hot updating of lua code when debugging by the Cocos Code IDE. If you want to change the moving path of dog int the src/GameScene.lua, you can modify the \"tick()\" function to control the dog's position ``` local function tick() if spriteDog.isPaused then return end local x, y = spriteDog:getPosition() if x > self.origin.x + self.visibleSize.width then x = self.origin.x else x = x + 1 end spriteDog:setPositionX(x) end ``` Modify the implementation of function, for example, change the value 1 to 10 and save your change. Then you will find that you have improved the speed of SpriteDog without restarting the app! ## How to Debug on the Other Target Platforms The above example is executed on the Mac platform because of the default configuration of Cocos Code IDE.If you debug on the other target platforms you should modify `Debug Configurations`. 1. Click `Debug Configurations` button on the toolbar to open `Debug Configurations` dialog ![](10-img/lua_config_button.png) 2. Select the `CocosLuaGame` item,then to configure ![](10-img/lua_debug_configure_dialog.png) ### Debug on the iOS Simulator 1. Check iOS Simulator radio button 2. Choose a runtime app 3. Click the Debug button,IDE will auto-install chosen runtime app and start runtime to debug ![](10-img/lua_configure_iOS_simulator.png) ### Debug on an iOS Device 1.You need a runtime IPA, you can build a custom runtime IPA by Cocos Code IDE, then [install runtime IPA](//www.solutionanalysts.com/blog/how-install-ipa-file-iphone-ipod-ipad-using-itunes-mac-windows) to iOS device. - Click `Build Runtime` on the toolbars ![](10-img/lua_configure_build_runtime.png) - Click `Yes` button on the pop-up `Cocos` dialog ![](10-img/lua_configure_build_runtime_first.png) - Click `Generate` button to Generate `Create Native Source Wizard` ![](10-img/lua_configure_creat_native_source_wizard.png) - Click `Close` button to finish `Create Native Source Wizard` ![](10-img/lua_configure_finish_create_native_source_wizard.png) - Click `Build Runtime` on the toolbars to open `Runtime Builder Wizard` dialog ![](10-img/lua_configure_runtime_builder_wizard.png) - Check `Build iOS Device Runtime` and click `Generate` button to generate ![](10-img/lua_configure_runtime_select_iOS_device.png) - Click `Close` button when Finished dialog pop up ![](10-img/lua_configure_finish_iOS_device.png) 2. Click `Debug Configuration`,then check `Remote Debug` radio button on the `Debug Configuration` dialog 3. Select `iOS` platform 4. Fill IP address of your device into the `Target IP` and Fill the IP address that your PC used on the `Host IP`(Make sure that the `Target IP` and `Host IP` can access each other) 5. Click 'Debug' button to begin to debug ![](10-img/lua_iOS_device_remote_setting.png) ### Debug on Android Device by ADB Mode 1. Prebuild Runtimelua.apk by `Build Runtime` like first of `Debug on the iOS Device` 2. Check `Android ADB Mode` radio button 3. Choose a runtime apk 4. Click the `Debug` button 5. IDE will auto-install the chosen runtime apk and start to debug ![](10-img/lua_debug_android_adb_mode.png) ### Debug on Android Device by WLAN 1. Install runtime apk to your device manually. It is placed in CocosLuaGame/runtime/android. 2. Start runtime on device manually 3. Click `Debug Configuration`,then check `Remote Debug` radio button on the `Debug Configuration` dialog 4. Fill IP address of your device into the `Target IP` and Fill the IP address that your PC used on the `Host IP`(Make sure that the `Target IP` and `Host IP` can access each other) 5. Click 'Debug' button to begin to debug ![](10-img/lua_anroid_device_remote_setting.png) --> "},"physics/":{"url":"physics/","title":"物理引擎","keywords":"","body":"简介 学过之前的那些章节，你就能做出来一款好玩的小游戏了，可是当你试图做一款复杂的游戏，那游戏需要模拟现实世界的情境，比如模拟两个物体碰撞，模拟物体受到重力，你就不知道该怎么办了。别担心，本章就介绍物理引擎，让我们来探索一下如何合理的使用物理引擎！ 是否需要使用物理引擎 当你的需求很简单时，就不要使用物理引擎。比如只需要确定两个对象是否有碰撞，结合使用节点对象的 update 函数和 Rect 对象的 containsPoint()，intersectsRect() 方法可能就足够了。例如： void update(float dt) { auto p = touch->getLocation(); auto rect = this->getBoundingBox(); if(rect.containsPoint(p)) { // do something, intersection } } 这种检查交集以确定两个对象是否有碰撞的方法，只能解决非常简单的需求，无法扩展。比如你要开发一个游戏，一个场景有 100 个精灵对象，需要判断它们互相是否有碰撞，如果使用这种方式那将非常复杂，同时性能消耗还会严重影响 CPU 的使用率和游戏运行的帧率，这游戏根本没法玩。 这个时候就需要物理引擎了，在模拟物理情景上，物理引擎的扩展性好，性能的消耗也低。像刚才提到的那个情景，使用物理引擎就能很好的解决。初次了解物理引擎的话，肯定会觉得很陌生，我们来看一个简单的例子，通过例子来介绍术语，或许会容易接受一些。 // create a static PhysicsBody auto physicsBody = PhysicsBody::createBox(Size(65.0f , 81.0f ), PhysicsMaterial(0.1f, 1.0f, 0.0f)); physicsBody->setDynamic(false); // create a sprite auto sprite = Sprite::create(\"whiteSprite.png\"); sprite->setPosition(Vec2(400, 400)); // sprite will use physicsBody sprite->addComponent(physicsBody); //add contact event listener auto contactListener = EventListenerPhysicsContact::create(); contactListener->onContactBegin = CC_CALLBACK_1(onContactBegin, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(contactListener, this); 虽然上面这个例子已经很简单了，但你可能还是觉得它复杂得有点吓人？别害怕，仔细的分析一下，就会发现也没那么复杂。 代码流程： PhysicsBody 对象创建 Sprite 对象创建 PhysicsBody 对象以组件的形式被添加到 Sprite 对象 创建监听器以响应 onContactBegin() 事件 保持耐心，一旦我们一步一步的去分析，慢慢的就能理解这个过程。 "},"physics/getting_started.html":{"url":"physics/getting_started.html","title":"Physics is scary!","keywords":"","body":"Physics is scary, do I really need it? Please tell me no! Please don't run away there are no physics monsters under your bed! Your needs might be simple enough to not need to use a physics engine. Perhaps a combination of using a Node objects update() function, Rect objects and a combination of the containsPoint() or intersectsRect() functions might be enough for you? Example: void update(float dt) { auto p = touch->getLocation(); auto rect = this->getBoundingBox(); if(rect.containsPoint(p)) { // do something, intersection } } This mechanism works for very simple needs, but doesn't scale. What if you had 100 Sprite objects all continuously updating to check for intersections with other objects? It could be done but the the CPU usage and framerate would suffer severely. Your game would be unplayable. A physics engine solves these concerns for us in a scalable and CPU friendly way. Even though this might look foreign, let's take a look at a simple example and then nut and bolt the example, terminology and best practice together. // create a static PhysicsBody auto physicsBody = PhysicsBody::createBox(Size(65.0f , 81.0f ), PhysicsMaterial(0.1f, 1.0f, 0.0f)); physicsBody->setDynamic(false); // create a sprite auto sprite = Sprite::create(\"whiteSprite.png\"); sprite->setPosition(Vec2(400, 400)); // sprite will use physicsBody sprite->addComponent(physicsBody); //add contact event listener auto contactListener = EventListenerPhysicsContact::create(); contactListener->onContactBegin = CC_CALLBACK_1(onContactBegin, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(contactListener, this); Even though this example is simple, it looks complicated and scary. It really isn't if we look closely. Here are the steps that are happening: A PhysicsBody object is created. A Sprite object is created. The Sprite object applies the properties of the PhysicsBody object. A listener is created to respond to an onContactBegin() event. Once we look step by step the concept starts to make sense. "},"physics/concepts.html":{"url":"physics/concepts.html","title":"概念","keywords":"","body":"术语和概念 为了更好的理解物理引擎，需要先了解下面的一些术语，概念。 刚体(Bodies) 刚体(Bodies) 描述了抽象物体的物理属性，包括：质量、位置、旋转角度、速度和阻尼。Cocos2d-x 中用 PhysicsBody 对象表示刚体。当刚体和形状关联后，刚体对象才具有几何形状，未关联形状， 刚体只是一个抽象物体的物理属性集。 材质(Material) 材质(Material) 描述了抽象物体的材料属性： density：密度，用于计算物体的质量 friction：摩擦，用于模拟物体间的接触滑动 restitution：恢复系数，模拟物体反弹的一个系数，系数一般设为 0 到 1 之间。0 代表不反弹，1 代表完全反弹。 形状(Shape) 形状(Shape) 描述了抽象物体的几何属性，将形状关联到刚体，刚体才具有几何形状。如果需要刚体具有复杂的形状，可以为它关联多个形状，每个形状对象都与一个 PhysicsMaterial 相关，并且拥有以下属性：type, area, mass, moment, offset 和 tag。其中有一些你可能还不熟悉，我们来逐一介绍： type：描述了形状的类别，如圆形，矩形，多边形等 area：用于计算刚体的质量，密度和面积决定了刚体的质量 mass：刚体的质量，影响物体在给定的力下获得的加速度大小，物体在一个引力场中物体受到力的大小 moment：刚体获得特定角加速度所需要的扭矩 offset：在刚体的当前坐标中，相对于刚体重心的偏移量 tag：形状对象的一个标签，你可能还记得，所有的 Node 对象都可以被分配一个 tag，用来进行辨识，实现更容易的访问。形状对象的 tag 作用也一样。 Cocos2d-x 中预定义了这些形状对象： PhysicsShape：物理形状的基类 PhysicsShapeCircle：实心的圆形，无法用它实现一个空心圆 PhysicsShapePolygon：实心且外凸的多边形 PhysicsShapeBox：矩形，它是一种特殊的外凸多边形 PhysicsShapeEdgeSegment：表示一种线段. PhysicsShapeEdgePolygon：空心多边形，由多个线段构成的多边形边缘。 PhysicsShapeEdgeBox：空心矩形，由四个线段组成的矩形边缘 PhysicsShapeEdgeChain: 链形，它可以有效的把许多边缘连接起来 连接/关节 连接(Contacts) 和 关节(joint) 对象描述了刚体相互关联的方式。 世界(World) 世界(World) 是现实物理世界的一个游戏模拟，容纳着所有被添加进去的抽象物体。你可以将刚体，形状，约束都添加到物理世界中，然后将整个世界作为一个整体进行更新。物理世界控制着所有元素的相互作用。其中，用物理 API 实现的许多互动都与 世界(World) 有关。 以上有许多需要记住的东西，请对这些都有个大概印象，以便一会用到的时候随时回看。 PhysicsWorld 物理世界(PhysicsWorld) 是 Cocos2d-x 进行物理模拟的核心对象。物理世界会同时发生很多事情，就像我们生活的世界一样。来想象一个简单的现实场景——厨房，你在思考的时候，就在脑中描绘出了一个厨房的物理世界！厨房世界里拥有一些物体，比如食物，刀具，电器，在这个世界中，这些物体会相互作用。它们会相互接触，并对接触做出反应。比如：用刀子切开食物，并把它放到电器中，做这样一件事。刀子切到食物了吗？可能切到了，也可能还没有，还可能这个刀子根本就不适合做这个。 物理世界(PhysicsWorld)与场景(Scene)进行了深入的整合，只需要调用 Scene 对象的 initWithPhysics() 方法，就可以创建一个包含物理世界的场景，注意在初始化的时候要进行函数返回值的判断。initWithPhysics() 初始化成功返回 true，失败返回 false if( !Scene::initWithPhysics() ) { } 每一个 物理世界(PhysicsWorld) 都有与之相关的属性： gravity：全局重力，应用于整个物理世界，默认值为 Vec2(0.0f, -98.0f) speed：物理世界的速度，这里的速度指的是这个模拟世界运行的一种比率，默认值是 1.0 updateRate：物理世界的刷新率，这里的刷新率指的是 游戏引擎刷新时间与物理世界刷新时间的比值 substeps：物理世界中每次刷新的子步数量 刷新物理世界的过程被称为步进，按照默认设置，物理世界会不停地进行自动刷新，这被称为自动步进。每一帧，都会不停地刷新，你可以通过 setAutoStep(false) 禁用一个物理世界的自动步进，然后通过 PhysicsWorld::step(time) 设定步进时间来手动刷新物理世界。游戏世界是按帧刷新的，物理世界可以通过子步(substeps)的设置，获得更加频繁的刷新，从而进行更精细的步进控制。 物理刚体(PhysicsBody) 对象具有位置和速度，你可以在物理刚体上应用力(forces)，运动(movement)，阻尼(damping)，冲量(impulses)等等。刚体可以是静态的，也可以是动态的，静态的刚体在模拟世界中不会移动，看起来就好像拥有无限大的质量一样，动态的刚体则是一种完全仿真的模拟。刚体可以被玩家手动移动，更常见的是它们受到力的作用而移动。动态刚体可以与所有类型的刚体发生碰撞。Cocos2d-x 提供了 Node::setPhysicsbody() 方法实现节点对象和物理刚体对象的关联。 让我们来创建一个静态的物理刚体对象，和五个动态的物理刚体对象，并让五个动态的刚体对象动起来： auto physicsBody = PhysicsBody::createBox(Size(65.0f, 81.0f), PhysicsMaterial(0.1f, 1.0f, 0.0f)); physicsBody->setDynamic(false); //create a sprite auto sprite = Sprite::create(\"whiteSprite.png\"); sprite->setPosition(s_centre); addChild(sprite); //apply physicsBody to the sprite sprite->addComponent(physicsBody); //add five dynamic bodies for (int i = 0; i setGravityEnable(false); //set initial velocity of physicsBody physicsBody->setVelocity(Vec2(cocos2d::random(-500,500), cocos2d::random(-500,500))); physicsBody->setTag(DRAG_BODYS_TAG); sprite = Sprite::create(\"blueSprite.png\"); sprite->setPosition(Vec2(s_centre.x + cocos2d::random(-300,300), s_centre.y + cocos2d::random(-300,300))); sprite->addComponent(physicsBody); addChild(sprite); } 结果是，五个动态的物理刚体对象和一个静态的物理刚体对象不断的发生碰撞。如图： "},"physics/collisions.html":{"url":"physics/collisions.html","title":"碰撞","keywords":"","body":"碰撞 你是否看到过车祸？是否跟什么物体相撞过？就像车的相撞一样，刚体对象也可以互相碰撞，当它们互相接触的时候，就认为发生了碰撞。当碰撞发生时，会触发一系列事件，它可以被完全忽略。 碰撞筛选 碰撞筛选允许你启用或者阻止形状之间碰撞的发生，引擎支持使用类型，组位掩码来进行碰撞筛选。 Cocos2d-x 有 32 个支持的碰撞类型，对于每个形状都可以指定其所属的类型。还可以指定有哪些类型可以与这个形状进行碰撞，这些是通过掩码来完成的。例如： auto sprite1 = addSpriteAtPosition(Vec2(s_centre.x - 150,s_centre.y)); sprite1->getPhysicsBody()->setCategoryBitmask(0x02); // 0010 sprite1->getPhysicsBody()->setCollisionBitmask(0x01); // 0001 sprite1 = addSpriteAtPosition(Vec2(s_centre.x - 150,s_centre.y + 100)); sprite1->getPhysicsBody()->setCategoryBitmask(0x02); // 0010 sprite1->getPhysicsBody()->setCollisionBitmask(0x01); // 0001 auto sprite2 = addSpriteAtPosition(Vec2(s_centre.x + 150,s_centre.y),1); sprite2->getPhysicsBody()->setCategoryBitmask(0x01); // 0001 sprite2->getPhysicsBody()->setCollisionBitmask(0x02); // 0010 auto sprite3 = addSpriteAtPosition(Vec2(s_centre.x + 150,s_centre.y + 100),2); sprite3->getPhysicsBody()->setCategoryBitmask(0x03); // 0011 sprite3->getPhysicsBody()->setCollisionBitmask(0x03); // 0011 } 你可以通过检查判断类型和掩码来确定碰撞的发生： if ((shapeA->getCategoryBitmask() & shapeB->getCollisionBitmask()) == 0 || (shapeB->getCategoryBitmask() & shapeA->getCollisionBitmask()) == 0) { // shapes can't collide ret = false; } 碰撞组允许你指定一个完整的组索引，你可以让具有相同组索引的形状总是一直碰撞（正索引）或者一直不碰撞（负索引和零索引）。对于组索引不同的形状。可以根据类型和掩码进行筛选，也就是说，组筛选比类型筛选具有更高的优先级。 连接/关节 回想一下之前提到的术语，关节是把不同刚体连接在一起的一种方式，就好像人体的关节是把人体的不同部位连接在一起。关节连接了不同的刚体，刚体可以是静态的，每一个关节类都是 PhysicsJoint 的子类，你可以通过设置 joint->setCollisionEnable(false) 来避免相互关联的刚体互相碰撞。关节的定义需要你提供一些几何数据，大多关节都是通过锚点来定义的，其余一些关节有各自的定义方式。 PhysicsJointFixed：固定点关节，将两个刚体固定在一个特定的点上。如果要创建一些后续会断裂的复合刚体，使用固定关节是非常合适的。 PhysicsJointLimit：限制关节，限制了两个刚体的最大距离，就好像它们被绳子连接了一样。 PhysicsJointPin：钉式关节，可以让两个刚体独立的围绕一个锚点进行旋转，就好像被钉在一起了一样。 PhysicsJointDistance：固定距离关节，设定了两个刚体间的固定距离。 PhysicsJointSpring：弹簧关节，就好像将一个弹簧连接了两个刚体，刚体会互相牵引和弹开。 PhysicsJointRotarySpring：弹簧旋转关节，类似弹簧关节，只是两个刚体位置的互相影响变成了旋转的互相影响。 PhysicsJointRotaryLimit：限制旋转关节，类似限制关节，只是两个刚体位置的互相影响变成了旋转的互相影响 PhysicsJointRatchet：与套筒扳手的工作类似。 PhysicsJointGear：传动关节，使一对刚体的角速度比值保持不变。 PhysicsJointMotor：马达关节，使一对刚体的相对角速度保持不变。 碰撞检测 碰撞(Contact) 是一种由物理引擎创建的用于管理两个形状碰撞的对象。Contact 对象不是由用户手动创建的，而是自动创建的。这里有两个相关的术语： contact point：碰撞点指两个形状相接触的那个点 contact normal：碰撞法线指从一个形状指向另一个形状的单位矢量 你可以从一个 contact 对象中获取到 PhysicsShape，从而获取到刚体： bool onContactBegin(PhysicsContact& contact) { auto bodyA = contact.getShapeA()->getBody(); auto bodyB = contact.getShapeB()->getBody(); return true; } 你可以通过碰撞监听器来访问碰撞，碰撞监听器支持四种事件：begin, pre-solve, post-solve, separate。 begin：收到这个事件时两个形状刚开始接触。在回调函数中返回 true 可以使碰撞继续被处理，若返回 false，则物理引擎会将整个碰撞忽略掉， preSolve() 和 postSolve() 回调函数也会被跳过。不过当两个形状停止重叠时，你仍然可以收到 separate 事件。 pre-solve：收到这个事件时两个形状接触在一起。如果在回调函数中返回 false，那么物理引擎会忽略掉这次碰撞，如果返回 true，碰撞会继续被处理。此外，你可以使用 setRestitution()，setFriction() 或 setSurfaceVelocity() 方法设置自定义的恢复系数，摩擦，表面速度，从而覆盖默认的碰撞属性。 post-solve：收到这个事件时两个形状已经接触，并且它们的碰撞已被处理。 separate：收到这个事件时两个形状刚刚停止了接触。 你还可以使用 EventListenerPhysicsContactWithBodies, EventListenerPhysicsContactWithShapes, EventListenerPhysicsContactWithGroup 来监听你感兴趣的刚体，形状，组的一些事件。额外的，还需要设置与物理碰撞相关的掩码。注意：默认情况下单单创建事件监听器，是收不到碰撞事件的。 示例： bool init() { //create a static PhysicsBody auto sprite = addSpriteAtPosition(s_centre,1); sprite->setTag(10); sprite->getPhysicsBody()->setContactTestBitmask(0xFFFFFFFF); sprite->getPhysicsBody()->setDynamic(false); //adds contact event listener auto contactListener = EventListenerPhysicsContact::create(); contactListener->onContactBegin = CC_CALLBACK_1(PhysicsDemoCollisionProcessing::onContactBegin, this); _eventDispatcher->addEventListenerWithSceneGraphPriority(contactListener, this); schedule(CC_SCHEDULE_SELECTOR(PhysicsDemoCollisionProcessing::tick), 0.3f); return true; return false; } void tick(float dt) { auto sprite1 = addSpriteAtPosition(Vec2(s_centre.x + cocos2d::random(-300,300), s_centre.y + cocos2d::random(-300,300))); auto physicsBody = sprite1->getPhysicsBody(); physicsBody->setVelocity(Vec2(cocos2d::random(-500,500),cocos2d::random(-500,500))); physicsBody->setContactTestBitmask(0xFFFFFFFF); } bool onContactBegin(PhysicsContact& contact) { auto nodeA = contact.getShapeA()->getBody()->getNode(); auto nodeB = contact.getShapeB()->getBody()->getNode(); if (nodeA && nodeB) { if (nodeA->getTag() == 10) { nodeB->removeFromParentAndCleanup(true); } else if (nodeB->getTag() == 10) { nodeA->removeFromParentAndCleanup(true); } } //bodies can collide return true; } "},"physics/queries.html":{"url":"physics/queries.html","title":"查询","keywords":"","body":"查询 你肯定有站着一个地方往四周看的经历？你能看到离你近的地方，也能看到离你远的东西，你能判断出它们离你有多远。物理引擎也提供了类似的空间查询功能。 Cocos2d-x 提供的 PhysicsWorld 对象支持点查询，射线查询和矩形查询。 点查询 当你碰到什么东西，比如说你的桌子的时候，你可以将这种情景作为一个点查询的例子。点查询是检查一个点周围的一定距离内是否有物体。通过点查询你可以找到一个物体中距离某定点最近的点，或者找到距离一个定点最近的物体，这非常适合于判断鼠标点击拾取的对象，也可以利用它进行一些其它的简单感知。 射线查询 当你四处看的时候，在你视线内的某些物体肯定会引起你的注意，你可以将这种情景作为一个射线查询的例子。射线查询是检查从一个定点发出的射线是否相交于一个物体，如果相交可以获取到一个交叉点，这非常适合于判断子弹（忽略子弹的飞行时间）是否命中。 示例： void tick(float dt) { Vec2 d(300 * cosf(_angle), 300 * sinf(_angle)); Vec2 point2 = s_centre + d; if (_drawNode) { removeChild(_drawNode); } _drawNode = DrawNode::create(); Vec2 points[5]; int num = 0; auto func = [&points, &num](PhysicsWorld& world, const PhysicsRayCastInfo& info, void* data)->bool { if (num getPhysicsWorld()->rayCast(func, s_centre, point2, nullptr); _drawNode->drawSegment(s_centre, point2, 1, Color4F::RED); for (int i = 0; i drawDot(points[i], 3, Color4F(1.0f, 1.0f, 1.0f, 1.0f)); } addChild(_drawNode); _angle += 1.5f * (float)M_PI / 180.0f; } 矩形查询 矩形查询提供了一种快速检查区域中有哪些物体的方法，实现起来非常容易： auto func = [](PhysicsWorld& world, PhysicsShape& shape, void* userData)->bool { //Return true from the callback to continue rect queries return true; } scene->getPhysicsWorld()->queryRect(func, Rect(0,0,200,200), nullptr); 这是在制作 Logo 击碎时使用矩形查询的例子： "},"physics/debugging.html":{"url":"physics/debugging.html","title":"调试","keywords":"","body":"调试 如果你希望在刚体周围绘制红框来帮助调试，那么可以简单的将这两行添加到物理场景的初始化代码中。你当然也可以学习官方测试项目，加一个菜单，在菜单的回调函数里控制是否打开调试功能。 Director::getInstance()->getRunningScene()->getPhysics3DWorld()->setDebugDrawEnable(true); Director::getInstance()->getRunningScene()->setPhysics3DDebugCamera(cameraObjecct); 禁用物理引擎 使用内置的物理引擎是个好的选择，它稳定又强大。不过，如果你的确想使用一些其它的物理引擎，只需要在 base/ccConfig.h 文件中将 CC_USE_PHYSICS 的值改为 0 禁用内置的物理引擎即可。 "},"audio/":{"url":"audio/","title":"音乐和音效","keywords":"","body":"音乐和音效 你的游戏肯定会需要音乐和音效！Cocos2d-x 提供了一个 SimpleAudioEngine 类支持游戏内的音乐和音效。它可以被用来增加背景音乐，控制游戏音效。 SimpleAudioEngine 是一个共享的单例对象，你可以在代码中的任何地方通过很简单的方式获取到。以下，我们会尽可能的为你展示它的各种使用方法。先来了解一下支持的文件格式。 支持的音乐格式： 平台 支持的常见文件格式 备注 Android mp3, mid, ogg, wav 可以播放android.media.MediaPlayer所支持的所有格式 iOS aac, caf, mp3, m4a, wav 可以播放AVAudioPlayer所支持的所有格式 Windows mid, mp3, wav 无 支持的音效格式： 平台 支持的常见文件格式 备注 Android ogg, wav 对wav的支持不完美 iOS caf, m4a 可以播放Cocos2d-iPhone CocosDesion所支持的所有格式 Windows mid, wav 无 "},"audio/getting_started.html":{"url":"audio/getting_started.html","title":"Getting Started","keywords":"","body":"Getting Started Your game will surely need sound! Cocos2d-x provides an audio engine called SimpleAudioEngine. It can be used to play background music as well as sound effects through out your game play. SimpleAudioEngine is a shared singleton object so you can simple call it from anywhere in your code. When creating a sample HelloWorld project we do all the setup required for you, out of the box. Supported music formats Platform Supported File Formats Notes Android .mp3, .mid, .ogg, .wav All formats supported by android.media.MediaPlayer can be played iOS .aac, .caf, .mp3, .m4a, .wav All formats supported by AVAudioPlayer can be played Windows .mid, .mp3, .wav none Supported audio formats: Platform Common Supported File Formats Notes Android .ogg, .wav Wav support is not perfect iOS .caf, .m4a Can play all formats supported by Cocos2d-iPhone CocosDesion Windows .mid, .wav none "},"audio/playing.html":{"url":"audio/playing.html","title":"背景音乐","keywords":"","body":"播放背景音乐 通过下面的方式，播放一个音频文件作为背景音乐，可以控制背景音乐是否循环播放。 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // set the background music and continuously play it. audio->playBackgroundMusic(\"mymusic.mp3\", true); // set the background music and play it just once. audio->playBackgroundMusic(\"mymusic.mp3\", false); 播放音效 通过下面的方式，将一个音频文件作为音效。 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // play a sound effect, just once. audio->playEffect(\"myEffect.mp3\", false, 1.0f, 1.0f, 1.0f); "},"audio/operations.html":{"url":"audio/operations.html","title":"声音控制","keywords":"","body":"声音控制 开始播放音乐和音效后，你可能需要对它们进行一些控制，比如暂停、停止、恢复。这很容易完成，下面介绍： 暂停 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // pause background music. audio->pauseBackgroundMusic(); // pause a sound effect. audio->pauseEffect(); // pause all sound effects. audio->pauseAllEffects(); 停止 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // stop background music. audio->stopBackgroundMusic(); // stop a sound effect. audio->stopEffect(); // stops all running sound effects. audio->stopAllEffects(); 恢复 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // resume background music. audio->resumeBackgroundMusic(); // resume a sound effect. audio->resumeEffect(); // resume all sound effects. audio->resumeAllEffects(); "},"audio/advanced.html":{"url":"audio/advanced.html","title":"高级功能","keywords":"","body":"高级声音功能 配置 移动设备上的游戏会遇到一些特殊的情景，比如游戏应用被切换至后台又切换回前台，正在玩游戏的时候电话来了，电话打完继续玩游戏，这些你在进行声音控制的时候都得考虑。 幸运的是，游戏引擎在设计的时候已经考虑到这些情景了，注意在 AppDelegate.cpp 中，有这样几个方法： // This function will be called when the app is inactive. When comes a phone call, // it's be invoked too void AppDelegate::applicationDidEnterBackground() { Director::getInstance()->stopAnimation(); // if you use SimpleAudioEngine, it must be pause // SimpleAudioEngine::getInstance()->pauseBackgroundMusic(); } // this function will be called when the app is active again void AppDelegate::applicationWillEnterForeground() { Director::getInstance()->startAnimation(); // if you use SimpleAudioEngine, it must resume here // SimpleAudioEngine::getInstance()->resumeBackgroundMusic(); } 看到了那些被注释的行吗？如果你有使用 SimpleAudioEngine 在游戏中播放声音，记得取消这些注释。当这些被注释的代码生效，你的游戏就能应对刚才提到的场景。 预加载 加载音乐和音效通常是个耗时间的过程，为了防止由加载产生的延时导致实际播放与游戏播放不协调的现象，在播放音乐和音效前，可以预加载音乐文件。 #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // pre-loading background music and effects. You could pre-load // effects, perhaps on app startup so they are already loaded // when you want to use them. audio->preloadBackgroundMusic(\"myMusic1.mp3\"); audio->preloadBackgroundMusic(\"myMusic2.mp3\"); audio->preloadEffect(\"myEffect1.mp3\"); audio->preloadEffect(\"myEffect2.mp3\"); // unload a sound from cache. If you are finished with a sound and // you wont use it anymore in your game. unload it to free up // resources. audio->unloadEffect(\"myEffect1.mp3\"); 音量控制 可以像下面这样，通过代码控制音乐和音效的音量： #include \"SimpleAudioEngine.h\" using namespace CocosDenshion; auto audio = SimpleAudioEngine::getInstance(); // setting the volume specifying value as a float // set default volume audio->setEffectsVolume(0.5); audio->setBackgroundMusicVolume(0.5); "},"audio/engines.html":{"url":"audio/engines.html","title":"Audio Engine TODO","keywords":"","body":"Are your audio needs more advanced? This far we have just talked about SimpleAudioEngine. For most games, SimpleAudioEngine provides all the functionality that they need. If your audio needs move beyond what SimpleAudioEngine can provide, Cocos2d-x also offers a second choice called just AudioEngine. SimpleAudio Engine versus Audio Engine "},"advanced_topics/":{"url":"advanced_topics/","title":"高级话题","keywords":"","body":"高级话题 哇！你已经读到最后一章了，干得不错！ 现在对于使用 Cocos2d-x 开发游戏，你应该各方面都很清楚了。但是，务必要意识到学无止境！本章就介绍一些高级的、技术性强的东西。 "},"advanced_topics/filesystem.html":{"url":"advanced_topics/filesystem.html","title":"文件接入","keywords":"","body":"文件系统接入 尽管你可以使用 stdio.h 中的函数来访问文件，但是由于以下原因可能会很不方便： 获取文件的绝对路径时，需要调用系统的特定 API 安装后，资源文件将打包到 .apk 文件中，绝对路径并不适用 想根据屏幕分辨率不同，自动加载不同的分辨率资源，如图片 Cocos2d-x 已经提供了 FileUtils 类来解决这些问题。FileUtils 是一个用于访问 Resources 目录下文件的帮助类。它也能做一些辅助性的事情，比如检查一个文件是否存在。 读文件 这是一些读文件的函数，不同的函数读不同类型的文件，返回不同的数据类型 function name return type support path type getStringFromFile std::string relative path and absolute path getDataFromFile cocos2d::Data relative path and absolute path getFileDataFromZip unsigned char* absolute path getValueMapFromFile cocos2d::ValueMap relative path and absolute path getValueVectorFromFile std::string cocos2d::ValueVector 管理文件 这些函数是用来管理文件，目录的： function name support path type isFileExist relative path and absolute path isDirectoryExist relative path and absolute path createDirectory absolute path removeDirectory absolute path removeFile absolute path renameFile absolute path getFileSize relative path and absolute path "},"advanced_topics/networking.html":{"url":"advanced_topics/networking.html","title":"网络访问","keywords":"","body":"网络访问 使用 HTTP 进行网络访问 有时候我们需要从网络上获取资源数据，一种常见的解决方法就是使用 HTTP 进行网络访问。 使用 HTTP 进行网络访问有三个步骤： 创建一个 HTTP 请求 HttpRequest 通过 setResponseCallback() 设置一个请求完成时的回调函数 使用 HttpClient 发送 HttpRequest HttpRequest 有四种类型：POST PUT DELETE UNKNOWN。除非指定请求的类型，否则就默认 UNKNOWN。HttpClient 对象负责请求的发送，也负责数据的接收。 示例： HttpRequest* request = new (std :: nothrow) HttpRequest(); request->setUrl(\"//just-make-this-request-failed.com\"); request->setRequestType(HttpRequest::Type::GET); request->setResponseCallback(CC_CALLBACK_2 (HttpClientTest::onHttpRequestCompleted, this)); HttpClient::getInstance()->sendImmediate(request); request->release(); 注意，我们通过 setResponseCallback() 设置请求完成时的回调函数了。这样做，在请求完成时，我们就能查看返回的数据，并提取出我们需要的。 回调函数的写法很简单，可以像这样做： void HttpClientTest::onHttpRequestCompleted(HttpClient* sender, HttpResponse* response) { if (!response) { return; } // Dump the data std::vector* buffer = response->getResponseData(); for (unsigned int i = 0; i size (); i ++) { log (\"% c\", (* buffer) [i]); } } "},"advanced_topics/oppo.html":{"url":"advanced_topics/oppo.html","title":"OPPO 优化","keywords":"","body":"给 OPPO 手机做的优化 该优化代码只在 Cocos2d-x 3.17.2 及以上的版本起效，并且目前只在 OPPO Reno 有效果。 具体优化方案 引擎内部在两个地方添加了优化代码： 场景加载 编译引擎内置的 shader 脚本 场景加载指的是从 Scene 创建到 Scene::onEnter() 被调用这段时间，所以加载资源的代码要放在 Scene::onEnter() 前，且需要在 Scene 创建后马上进行资源加载。 手动调用优化代码 程序比引擎更清楚什么时机需要更多的 CPU、GPU 资源，因此程序代码可以在需要更多资源的地方手动掉优化代码。可以在 C++ 或 Java 调用优化代码： C++ 的调用方式 // 通知系统某一事件发生，如场景加载开始，场景加载结束。3.17.2 之后才增加的绑定。 #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::setOptimise(const string&, const string&); #endif // 场景加载开始，需要更多的资源 // 该接口适用于突发重负载的场景，如加载地图,GC、突发大量访问磁盘文件与数据库等 #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onSceneLoaderBegin(); #endif // 场景加载结束 #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onSceneLoaderEnd(); #endif // 开始编译 shader 脚本 #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onShaderLoaderBegin(); #endif // 结束编译 shader 脚本 #if CC_TARGET_PLATFORM == CC_PLATFORM_ANDROID DataManager::onShaderLoaderEnd(); #endif Java 的调用方式 Cocos2dxDataManager::setOptimise(String thing, float value); thing 1 0 load_scene 开始加载场景 结束加载场景 shader_compile 开始编译 shader 脚本 结束编译 shader 脚本 V3.17.2 版本后，value 的类型由 float 变成了 string，这样就更灵活了。 thing 与 value目前默认支持上述两种方式，如果需要更加定制化的控制，需遵循手机厂商的标准才能被正确识别并生效。如在OPPO手机上，需要首先调用 setOptimise（\"permission\"， permissionIInfo），其中 permissionIInfo 需登录OPPO开放平台申请授权码，然后再传输定制的参数才会生效。具体可参考该文档。 "},"advanced_topics/optimizing.html":{"url":"advanced_topics/optimizing.html","title":"图形性能优化","keywords":"","body":"图形性能优化 黄金法则 二八原则 系统中 20% 的代码会消耗 80% 的性能！在进行性能优化时，我们应该始终坚持这个原则。 够用原则 如果有两种方式渲染图像，无法观察出哪个渲染的效果更好，那就选用性能消耗更低的方式。我们知道，RGBA4444 像素格式的 PNG 图像质量比 RGBA8888 像素格式的要低，但是如果在游戏效果上，无法观察出哪个效果好，我们应该坚持使用 RGBA4444 的像素格式，因为它占用更少的内存，出现内存问题和带宽问题的可能性更小。 音频采样率也是一样的。 了解目标设备和游戏引擎 了解目标设备的 CPU/GPU 系列，当性能问题仅在某些设备上出现时，这个信息就非常重要。或许你会发现他们共用一种 GPU：ARM、PowerVR 或 Mali。然后就可以进行有针对性的分析。 了解目前使用的游戏引擎也很重要，如果你知道引擎是如何组织图形命令，如何处理绘制过程。那在编码的过程中就能避免许多常见的陷阱。 使用工具分析 有许多工具可用于分析图形性能，即使我们需要优化 Android 游戏的性能，也可以使用 Xcode 帮助调试。 Xcode: Debugging-OpenGL-ES-With-Xcode-Profile-Tools 官方文档: OpenGLES_ProgrammingGuide 三大移动 GPU 供应商，也提供了图形分析工具 ARM Mali GPU: mali-graphics-debugge Imagination PowerVR GPU: pvrtune Qualcomm Adreno GPU: adreno-gpu-profiler 当你遇到图形性能问题时可以使用这些工具，但在这之前，请先确认是不是 CPU 导致的性能问题，注意不要随意猜测，而是要通过分析得出结果。 常见瓶颈 作为一个经验法则，游戏性能问题更容易出现在 CPU ，而不是 GPU CPU 性能优化 绘制调用(draw call) 次数过多，游戏循环中计算量过大，都会造成 CPU 性能下降，尽量减少游戏中的总绘制调用次数，我们应该尽可能的使用批量绘制。 Cocos2d-x 有自动批量处理绘制的支持，但仍需要一些努力才能使其工作。 当玩家玩游戏时，要尽量避免 IO 操作，尽可能预加载图集、音频、TTF字体等 更不要在游戏循环中进行繁重的计算操作，因为这可能造成每帧 60 次的大量计算，性能消耗非常恐怖！ GPU 性能优化 如果只是在开发一个 2D 游戏，也没有写复杂的着色器，那基本不会遇到 GPU 性能问题。但是过度绘制的问题仍然存在，如果过度绘制较多，将会消耗大量带宽，进而降低 GPU 性能。 尽管现在移动 GPU 具有 TBDR(基于平铺的渲染) 架构，但是只有 PowerVR 的 HSR(隐藏曲面去除) 可以显著减少过度绘制问题，其它 GPU 仅执行 TBDR 和早期的 z 测试，只有在提交不透明的几何图形时才能减少过渡绘制问题。 Cocos2d-x 总是按照从后向前的规则提交绘制命令，这样在 2D 中即使有许多透明图像，也能保证正确的混合效果。 Cocos2d-x 性能优化建议 始终使用批量绘图，将同一图层中的精灵图像打包成一个大的图集 根据经验，尽量保持 绘制调用(draw call) 次数低于 50，总之尽量减少就对了！ 在 原始 32 位（RGBA8888）纹理上，优先使用 16 位（RGBA4444 + 抖动）的处理方式 使用压缩纹理，在 iOS 中使用 PVRTC 纹理，在 Android 平台上，使用 ETC1，但是 ETC1 没有 alpha 通道，你可能需要编写自定义着色器并为 alpha 通道提供单独的 ETC1 图像 不要使用系统字体作为您的游戏得分计数器，它很慢的，尝试使用 TTF 或 BMFont，BMFont 更快 尝试在使用音频和其它游戏对象前，进行预加载 使用 armabi-v7a 构建 Android 工程，这会有更好的性能表现 使用烘焙光照，而不是动态光照 避免使用复杂的像素着色器 避免在像素着色器中使用丢弃和 alpha 测试，它会影响 HSR 优化 "},"advanced_topics/shaders.html":{"url":"advanced_topics/shaders.html","title":"着色器和材质","keywords":"","body":"着色器和材质 什么是着色器 从维基百科： 在计算机图形学领域，着色器(Shader) 是一种特殊类型的计算机程序，最初用于做阴影，在图像中产生适当的光照、明暗，现在主要用于产生特殊效果，也用于视频后期处理。 非专业人士的定义可能是：告诉计算机如何以一种特定的方式绘制东西的程序。简单地说，着色器就是运行在 GPU 上用于图像渲染的一段程序，Cocos2d-x 用它绘制节点。 Cocos2d-x 使用的着色器语言是 OpenGL ES Shading Language v1.0，描述 GLSL 语言不在本文的范围之内。想了解更多，请参考 规范文档。在 Cocos2d-x 中，所有的可渲染的 Node 对象都使用着色器。比如，Sprite 对象使用为 2D 精灵优化过的着色器，Sprite3D 使用为 3D 对象优化过的着色器。 自定义着色器 开发者能为任一 Cocos2d-x 的节点对象设置自定义的着色器，添加着色器示例： sprite->setGLProgramState(programState); sprite3d->setGLProgramState(programState); GLProgramState 对象包含两个重要的东西 GLProgram：从根本上来说就是着色器。包含一个顶点着色器和一个像素着色器。 状态属性：根本上来说就是着色器的 uniform 变量 如果你不熟悉 uniform 变量也不知道为什么需要它，请参考刚才提到的 语言规范 可以很容易的将 uniform 变量设置到 GLProgramState： glProgramState->setUniformFloat(\"u_progress\", 0.9); glProgramState->setUniformVec2(\"u_position\", Vec2(x,y)); glProgramState->setUniformMat4(\"u_transform\", matrix); 你还可以将一个回调函数设置成 uniform 变量，下面是一个 lambda 表达式作为回调函数的例子： glProgramState->setUniformCallback(\"u_progress\", [](GLProgram* glProgram, Uniform* uniform) { float random = CCRANDOM_0_1(); glProgram->setUniformLocationWith1f(uniform->location, random); } ); 虽然可以手动设置 GLProgramState 对象，但更简单的方法是使用材质对象。 什么是材质 设想你想在游戏中画一个这样的球体： 你要做的第一件事就是定义它的几何形状，像这样： 然后定义砖块纹理，像这样： 这样做也能达成目标的效果，但是如果进一步的考虑： 如果当球体离相机很远时，想使用质量较低的纹理呢？ 如果想对砖块应用模糊效果呢？ 如果想启用或者禁用球体中的照明呢？ 答案是使用 材质(Material)，而不是使用一个简单的纹理。对于材质，你可以拥有多个纹理，还可以拥有其它的一些特性，比如多重渲染。 材质对象通过 .material 文件创建，其中包含以下信息： 材质有一个或多个渲染方法(technique) 每个渲染方法有一个或多个通道(pass) 每个通道有： 一个渲染状态(RenderState) 一个包含了 uniform 变量的着色器 例如，这是一个材质文件： // A \"Material\" file can contain one or more materials material spaceship { // A Material contains one or more Techniques. // In case more than one Technique is present, the first one will be the default one // A \"Technique\" describes how the material is going to be renderer // Techniques could: // - define the render quality of the model: high quality, low quality, etc. // - lit or unlit an object // etc... technique normal { // A technique can contain one or more passes // A \"Pass\" describes the \"draws\" that will be needed // in order to achieve the desired technique // The 3 properties of the Passes are shader, renderState and sampler pass 0 { // shader: responsible for the vertex and frag shaders, and its uniforms shader { vertexShader = Shaders3D/3d_position_tex.vert fragmentShader = Shaders3D/3d_color_tex.frag // uniforms, including samplers go here u_color = 0.9,0.8,0.7 // sampler: the id is the uniform name sampler u_sampler0 { path = Sprite3DTest/boss.png mipmap = true wrapS = CLAMP wrapT = CLAMP minFilter = NEAREST_MIPMAP_LINEAR magFilter = LINEAR } } // renderState: responsible for depth buffer, cullface, stencil, blending, etc. renderState { cullFace = true cullFaceSide = FRONT depthTest = true } } } } 将一个材质设置到 Sprite3D 的方法： Material* material = Material::createWithFilename(\"Materials/3d_effects.material\"); sprite3d->setMaterial(material); 如果你想改变不同的渲染方法，你可以这样做： material->setTechnique(\"normal\"); 渲染方法(Technique) 你只能为一个 Sprite3D 绑定一个材质，但这并不意味着固定了一种渲染方式。材质(Material)有一个特性：允许包含多个 渲染方法(Technique)，当一个材质被加载时，所有的渲染方法也都被提前加载。有了这个特性，你就可以在运行时方便快速的改变一个对象的渲染效果。 通过使用 Material::setTechnique(const std::string& name) 函数，就可以完成渲染方法的切换。这种特性可以用来处理不同灯光的变换，也可以用来处理，在渲染的对象离相机很远时采用质量较低的纹理这种情景。 通道(Pass) 一个渲染方法可以有多个渲染 通道(Pass)，其中一个通道对应一次渲染，多通道意味着对一个对象渲染多次，这被称为多通道渲染，也叫多重渲染。每个通道有两个主要的对象： RenderState：包含 GPU 状态信息，如 depthTest, cullFace, stencilTest，等 GLProgramState：包含要使用的着色器，和一些 uniform 变量 材质文件格式 Cocos2d-x 的材质文件使用一种优化过的文件格式，同时与其它一些开源引擎的材质文件格式类似，如 GamePlay3D，OGRE3D。 注意点： 材质文件的扩展名无关紧要，建议使用 .material 作为扩展名 顶点着色器和像素着色器的文件扩展名也无关紧要，建议使用 .vert 和 .frag id 是材质(Meterial)，渲染方法(technique)，通道(pass)的可选属性 材质可以通过设置 parent_material_id 继承其它材质的值 // When the .material file contains one material sprite3D->setMaterial(\"Materials/box.material\"); // When the .material file contains multiple materials sprite3D->setMaterial(\"Materials/circle.material#wood\"); 字段定义 material material_id : parent_material_id     {     renderState {} [0..1] block technique id {} [0..*] block }     technique technique_id     {     renderState {} [0..1] block pass id {} [0..*] block }     pass pass_id     {     renderState {} [0..1] block shader {} [0..1] block }     renderState     {     blend = false [0..1] bool blendSrc = BLEND_ENUM [0..1] enum blendDst = BLEND_ENUM [0..1] enum cullFace = false [0..1] bool depthTest = false [0..1] bool depthWrite = false [0..1] bool }       frontFace = CW | CCW [0..1] enum   depthTest = false [0..1] bool   depthWrite = false [0..1] bool   depthFunc = FUNC_ENUM [0..1] enum   stencilTest = false [0..1] bool   stencilWrite = 4294967295 [0..1] uint   stencilFunc = FUNC_ENUM [0..1] enum   stencilFuncRef = 0 [0..1] int   stencilFuncMask = 4294967295 [0..1] uint   stencilOpSfail = STENCIL_OPERATION_ENUM [0..1] enum   stencilOpDpfail = STENCIL_OPERATION_ENUM [0..1] enum   stencilOpDppass = STENCIL_OPERATION_ENUM [0..1] enum shadershader_id     {     vertexShader = res/colored.vert [0..1] file path fragmentShader = res/colored.frag [0..1] file path defines = semicolon separated list [0..1] string       uniform_name = scalar | vector [0..*] uniform uniform_name = AUTO_BIND_ENUM [0..*] enum sampler uniform_name {} [0..*] block }     sampler uniform_name     {     path = res/wood.png | @wood [0..1] image path mipmap = bool [0..1] bool wrapS = REPEAT | CLAMP [0..1] enum wrapT = REPEAT | CLAMP [0..1] enum minFilter = TEXTURE_MIN_FILTER_ENUM [0..1] enum magFilter = TEXTURE_MAG_FILTER_ENUM [0..1] enum }     枚举类型定义 TEXTURE_MIN_FILTER_ENUM   NEAREST Lowest quality non-mipmapped LINEAR Better quality non-mipmapped NEAREST_MIPMAP_NEAREST Fast but low quality mipmapping LINEAR_MIPMAP_NEAREST   NEAREST_MIPMAP_LINEAR   LINEAR_MIPMAP_LINEAR Best quality mipmapping TEXTURE_MAG_FILTER_ENUM   NEAREST Lowest quality LINEAR Better quality BLEND_ENUM   ZERO ONE_MINUS_DST_ALPHA ONE CONSTANT_ALPHA SRC_ALPHA ONE_MINUS_CONSTANT_ALPHA ONE_MINUS_SRC_ALPHA SRC_ALPHA_SATURATE DST_ALPHA   CULL_FACE_SIDE_ENUM BACK Cull back-facing polygons. FRONT Cull front-facing polygons. FRONT_AND_BACK Cull front and back-facing polygons. FUNC_ENUM NEVER ALWAYS LESS GREATER EQUAL NOTEQUAL LEQUAL GEQUAL STENCIL_OPERATION_ENUM KEEP REPLACE ZERO INVERT INCR DECR INCR_WRAP DECR_WRAP 数据类型: scalar 代表标量，可以用浮点型(float)，整形(int)，布尔型(bool) vector 代表矢量，用逗号分隔的一系列浮点数表示 预定义的 uniform 变量 下面是 Cocos2d-x 预定义的一些 uniform 变量，你可以在自定义的着色器中使用它们。 CC_PMatrix: A mat4 with the projection matrix CC_MVMatrix: A mat4 with the Model View matrix CC_MVPMatrix: A mat4 with the Model View Projection matrix CC_NormalMatrix: A mat4 with Normal Matrix CC_Time: a vec4 with the elapsed time since the game was started CC_Time[0] = time / 10; CC_Time[1] = time; CC_Time[2] = time * 2; CC_Time[3] = time * 4; CC_SinTime: a vec4 with the elapsed time since the game was started: CC_SinTime[0] = time / 8; CC_SinTime[1] = time / 4; CC_SinTime[2] = time / 2; CC_SinTime[3] = sinf(time); CC_CosTime: a vec4 with the elapsed time since the game was started: CC_CosTime[0] = time / 8; CC_CosTime[1] = time / 4; CC_CosTime[2] = time / 2; CC_CosTime[3] = cosf(time); CC_Random01: A vec4 with four random numbers between 0.0f and 1.0f CC_Texture0: A sampler2D CC_Texture1: A sampler2D CC_Texture2: A sampler2D CC_Texture3: A sampler2D "},"advanced_topics/sqlite.html":{"url":"advanced_topics/sqlite.html","title":"SQLite 集成 TODO","keywords":"","body":"SQLite SQLite is a self-contained SQL database engine. This means there is no server involved. SQLite runs while your game is running and you write code to connect to the database and manipulate its contents. This is by no means a comprehensive guide, in fact, we cover 1% of what SQLite can do for you. Please read their website for a lot more detail as to what functionality SQLIte offers developers. Getting Started. In-order to use SQLite you must download it and add it to your project. Please see the SQLite Downloads page for more details. For our purposes you will just need sqlite.h and sqlite.c in your project. Add these files to your environment and make sure they are part of your build process. How Does SQL Work In A Game? Now that you have SQLite you must understand how using a database in your app works. There isn't any automatic benefit, unless you code it. There are no wizards and no functionality for free. This is hand coded, by you, to meet your specific needs. Generally speaking, you will need to evaluate the following: Does your database already exist? Yes? Connect to it. No? Create it, probably using create table queries. Then connect to it. Are you connected to the database? Yes? Issue queries against it to achieve your goals. No? Connect to it, then issue queries against it to achieve your goals. Do you need to update your database based upon player achievements? Yes? Run insert/update queries to change the database. No? Probably select queries are enough to use the database to drive your game play. Is the player done with your game? Yes? Make sure to close the database when your game exists. Failure to do so may corrupt your database and make it unusable. Basic Database Creation And Manipulation Let's cover how to create a simple database, connect to it and then manipulate it. Creating A Simple Database In order to use your database, it must exist. SQLite is file based. Simply creating a new file to house your database is sufficient. Notice that we use a .db file extension to help notate that this is indeed our database. It is also important to understand where the database lives on the players device. When you create the database it must be put in a location that the device allows the player to write data to. Cocos2d-x helps make this easy with a file system API called getWriteablePath(). Here is an example: sqlite3* pdb; pdb = NULL; std::string dbPath = cocos2d::FileUtils::getInstance()->getWritablePath() + \"mydatabase.db\"; int result = sqlite3_open(dbPath.c_str(), &pdb); if(result == SQLITE_OK) std::cout With the database open, you can now use it. Creating A Table Databases use tables to store data. You need at least one table in your database. The caveat is that you must know what data your table will contain in-order to create it. You can always use the SQL alter table command if at a later tine you need to modify your tables structure. This is outside the scope of this document, however. Creating a simple table: int result = 0; std::string sql; sql = \"create table \" + std::string(\"Master\") + std::string(\" (id TEXT PRIMARY KEY, value INT);\"); result = sqlite3_exec(pdb, sql.c_str(), NULL, NULL, NULL); if(result == SQLITE_OK) { // table created successfully } else { // table was NOT created successfully } Querying Data When you want information from your database you must execute a select query to get it. A select query is a read-only query. You don't have to worry about accidentally modifying your game data when running these types of queries. An example select query; std::string key = \"Brown\"; std::string sql = \"SELECT NAME \" + std::string(\" FROM \") + std::string(\"Master\") + std::string(\" WHERE id='\") + std::string(key.c_str()) + std::string(\"' LIMIT 1;\"); sqlite3_stmt* statement; if (sqlite3_prepare_v2(&pdb, sql.c_str(), -1, &statement, 0) == SQLITE_OK) { int result = 0; while(true) { result = sqlite3_step(statement); if(result == SQLITE_ROW) { // do something with the row. } else { break; } } } Inserting Data You may need to insert data into your database to use again at a later time. Use an insert query to do this. Example: Updating Data Closing The Database "},"installation/":{"url":"installation/","title":"环境搭建","keywords":"","body":"环境搭建 简介 阅读本章，你能学习到 Cocos2d-x 在各个平台的环境搭建方法，环境搭建以成功编译运行官方测试项目 cpp-tests 为目标。 搭建完成，你可以通过 cpp-tests 学习引擎的各个功能。 环境要求 Mac OS X 10.7+, Xcode 8+ Ubuntu 14.04+, CMake 3.1+ Windows 7+, VS 2015+ Python 2.7.5+, NOT Python 3+ NDK r16+ is required to build Android games (tested with r16) Android Studio 3.0+ to build Android games (tested with 3.0) JRE or JDK 1.6+ is required for web publishing "},"installation/prerequisites.html":{"url":"installation/prerequisites.html","title":"Prerequisites","keywords":"","body":"Prerequisites Build Requirements v3.17.2 Mac OS X 10.13+, Xcode 10+ Ubuntu 16.04+, CMake 3.1+ (use apt install to get the latest version) Windows 7+, VS 2017+ Python 2.7.5+, Python 2,7.10 reccomended, NOT Python 3+ NDK r91c+ is required to build Android games (tested with r19c) May be called 19.2.xx from within Android Studio Android Studio 3.4+ to build Android games (tested with 3.0) v3.17, v3.17.1 Mac OS X 10.13+, Xcode 10+ Ubuntu 16.04+, CMake 3.1+ (use apt install to get the latest version) Windows 7+, VS 2015+ Python 2.7.5+, Python 2,7.10 reccomended, NOT Python 3+ NDK r16+ is required to build Android games (tested with r16) Android Studio 3.0+ to build Android games (tested with 3.0) v3.16 Mac OS X 10.7+, Xcode 7+ Ubuntu 12.10+, CMake 2.6+ Windows 7+, VS 2013+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ is required to build Android games (tested with r14) Android Studio 2.3.3+ to build Android games (tested with 2.3.3 and 3.0) JRE or JDK 1.6+ is required for web publishing v3.15 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Android Studio 2.3+ to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 Tizen SDK 2.3+ is required to build Tizen games JRE or JDK 1.6+ is required for web publishing v3.14 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.13, v3.13.1 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r11+ and API level 19 is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.12 Mac OS X 10.7+, Xcode 7+ Ubuntu 14.04+, gcc, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Clang for developing Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.8, v3.9, v3.10, v3.11, v3.11.1 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+, CMake 2.6+ Windows 7+, VS 2013 or VS 2015 (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ or VS 2015 Windows Phone/Store 10.0, VS 2015 v3.7 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+, CMake 2.6+ Windows 7+, VS 2013+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.1, VS 2013 Update 4+ JRE or JDK 1.6+ is required for web publishing v3.4, v3.5, v3.6 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+ Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ v3.3 Mac OS X 10.7+, Xcode 5.1+ Ubuntu 14.04+, gcc 4.9+ Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r10c+ is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ v3.0, v3.1, v3.1.1, v3.2 Mac OS X 10.7+, Xcode 4.6+ Ubuntu 12.04+, gcc 4.7 Windows 7+, VS 2012+ (requires Visual C++ Redistributable for Visual Studio 2012 x86 and Visual C++ Redistributable for Visual Studio 2010 x86) Python 2.7.5+, NOT Python 3+ NDK r9d is required to build Android games Windows Phone/Store 8.0 VS 2012+ Windows Phone/Store 8.1 VS 2013 Update 3+ Runtime Requirements iOS 6.0+ for iPhone / iPad games Android 2.3+ for Android games Windows 8.1 or Windows 10.0 for Windows Phone/Store 8.1 games Windows 10.0 for Windows Phone/Store 10.0 games Mac OS X v10.6+ for Mac games Windows 7+ for Win games Modern browsers and IE 9+ for web games Revision history 11/28/2017 - slackmoehrle - added Python 2.7.5+, but not Python 3+ and Visual C++ Redistributable requirements. 1/2/2017 - slackmoehrle - reviews while comparing to README for each tagged release. "},"installation/Android-Studio.html":{"url":"installation/Android-Studio.html","title":"Android 平台","keywords":"","body":"搭建开发环境 - Android 平台 工具准备 Android Studio v3.0+， 下载参见：Google 中国开发者网站 cocos2d-x v3.17，下载后解压，下载参见：Cocos 官网页面 配置步骤： 完成 Android Studio 安装，进入欢迎界面，选择 Import project(Gradle, Eclipse ADT, etc.)。选择目录 cocos2d-x root/tests/cpp-tests/proj.android-studio，点击 OK 进入 IDE 主界面。 第一次导入 cocos2d-x 工程，控制台会提示缺少组件，点击提示下方的链接，下载安装即可。提示类似： Gradle sync failed: Failed to find Build Tools revision 27.0.1 组件安装完成，点击工具栏 Run，进行编译运行，编译过程可能会花费一点时间。 选择运行应用的设备，IDE 将自动安装应用，并控制应用展示主界面。建议直接使用 Android 手机接入电脑作为设备进行测试。这样应用会有较快的运行速度。运行成功界面： 如何调试(Debug) Android Studio 2.3+ 已经支持 C++ 代码的调试，按照以下步骤，进行 cpp-tests 的调试 点击代码行左侧的空白，设置断点 以 debug 模式运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，在底栏打开Debug视图，可以查看运行堆栈和变量的值 如何打包 按照下面的步骤，构建 App 的发布(Release)版本 将 Build Variant 设置为 release 模式 在 gradle.properties 文件中，添加签名信息 对于 Lua 项目，如果想加密 Lua 代码，也需要在 gradle.properties 文件中添加签名信息 不清楚 gradle.properties 中属性的作用时，请阅读注释。 模拟器的创建 点击工具栏 AVD Manager 进入模拟器的管理界面。 在 Android Virtual Device Manager 界面左下角，可以看到按钮 Create Virtual Device...，点击进入 Choose a device definition页面，选择设备，此处选择只决定了尺寸和分辨率，与设备中运行的系统无关。此处选择 Nexus 5X，选择后点击 Next，进入选择系统镜像页面。 在 Select a system image 界面，选择系统镜像，此处选择决定了设备的API Level 和 ABI。API Level代表了 Android 系统版本，如 API Level 24，代表 Android 7.0 系统。ABI 是与CPU相关的一个参数，模拟器多为 x86，真机多为 ARM。 选择完成，点击 Next，进入Verify Configuration，点击 Finish 结束。 FAQ 如何使用 x86 架构的模拟器运行 cpp-tests 项目？ 在项目中找到 gradle.properties 文件，将 PROP_APP_ABI=armeabi-v7a 修改为 PROP_APP_ABI=x86，点击提示中的 Sync Now，完成后重新编译运行。 更多关于 ABI 的信息请参考 Google 文档 ABI 管理 Cocos2d-x 的 Android 工程配置好复杂，怎样怎能弄清楚？ Cocos2d-x 使用的工程配置是标准的 Gradle 配置，请先阅读 Gradle 文档 中的 Android 部分，从理解简单工程的 Gradle 配置开始。 在 Windows 系统上通过 Android Studio 编译项目有路径错误？ 甚至每次报错的路径都不一样，什么原因？ Windows 系统对于文件的路径有最大长度限制，如果将引擎根目录放的比较深，可能会引起这种问题。建议将引擎根目录 cocos2d-x 放置到磁盘根目录。 "},"installation/Android-terminal.html":{"url":"installation/Android-terminal.html","title":"命令行 (已弃用)","keywords":"","body":"Android 命令行（已弃用） 背景 由于 Google 自 2015 年底已中止了对 ADT 的支持，希望开发者转向 Android Studio。同时 Android Studio 的功能也已日趋完善，足够我们使用它完成 Cocos2d-x 项目的全部开发流程：编码、编译、调试、发布。因此自 3.16 版本我们不再支持 ADT。 如果你是一个新手，请转向 Android Studio 进行 Cocos2d-x 的环境搭建学习。如果明确有对老版本引擎的 Android 环境搭建需求，那请继续阅读。 工具准备 在正式开始搭建 Cocos2d-x 开发环境之前，你需要一个可用的 Android 开发环境。这包括 JDK/SDK 1.6+ http://www.oracle.com/technetwork/java/javase/downloads/index.html Android NDK https://developer.android.com/tools/sdk/ndk/index.html Apache Ant http://ant.apache.org/bindownload.cgi Python 2.7.X https://www.python.org/downloads/ 不是 PYTHON 3 你的操作系统可能已经包含其中一些了，请下载缺失的组件。 macOS 配置 Python macOS 系统默认安装了 Python，请在终端中输入以下命令，验证 Python 是否工作。 > python --version 如果有类似下面的输出，版本号是 2.7.X，证明 Python 环境是好的。 Python 2.7.10 如果是找不到命令，请使用工具准备中提到的链接，安装一个 2.7.X 新版本的 Python，注意不要安装 Python 3.X 的版本。 JAVA macOS 系统默认是不安装 Java 的，所以你需要手动下载 Java，注意要下载 JDK，而不是 JRE。 下载安装完成后，在终端中输入以下命令验证 Java 环境是否自动配置好。 > java -version 如果可以看到类似下面的输出，则证明环境是好的， java version \"1.8.0_111\" Java(TM) SE Runtime Environment (build 1.8.0_111-b14) Java HotSpot(TM) 64-Bit Server VM (build 25.111-b14, mixed mode) 如果命令不可用，请自行配置环境变量，配置完后通过 java -version 验证环境是否配置成功。 Apache Ant Apache Ant 是另一个需要的工具，默认没有安装在 OS X 系统上。请使用工具准备中提到的链接下载，建议直接下载二进制版本。 下载后解压缩，在 .bash_profile 中添加一个 ANT_ROOT 的环境变量，变量值是 Apache Ant 目录下 bin 子目录的路径，然后将该变量添加到 PATH 中。像这样： export ANT_ROOT=/Applications/Cocos/tools/ant/bin export PATH=$ANT_ROOT:$PATH Android NDK 和 SDK 显然，进行 Android 开发需要 Android SDK 和 NDK，这两个默认都未安装在 OS X 系统上，你可以使用工具准备中提到的链接进行下载。也有另外一种方式使用 brew 包管理器。 通过 Brew 安装 使用 brew 安装 NDK 和 SDK 是一种更简单的方式，一个命令，几个环境变量就 OK。这样操作： brew tap caskroom/cask brew cask install android-sdk android-ndk 下载和安装过程会需要一点时间，完成后，你需要在 .bash_profile 设置一些环境变量： export NDK_ROOT=/usr/local/Cellar/android-ndk/r12b export PATH=$NDK_ROOT:$PATH export ANDROID_HOME=/usr/local/opt/android-sdk export ANDROID_SDK_ROOT=/usr/local/Cellar/android-sdk/24.4.1_1 export PATH=$ANDROID_SDK_ROOT:$PATH export PATH=$ANDROID_SDK_ROOT/tools:$ANDROID_SDK_ROOT/platform-tools:$PATH 设置完成后，记得执行 source ~/.bash_profile 使环境变量生效。 手动安装 如果你选择不使用 brew，那就手动下载安装。环境变量的设置与上面的基本相同，假设你将 SDK 和 NDK 下载到了 ~/Projects/ 目录，设置的环境变量就类似这样： export NDK_ROOT=/Users/username/Projects/android-ndk/r12b export PATH=$NDK_ROOT:$PATH export ANDROID_HOME=/Users/username/Projects/android-sdk export ANDROID_SDK_ROOT=/Users/username/Projects/android-sdk/24.4.1_1 export PATH=$ANDROID_SDK_ROOT:$PATH export PATH=$ANDROID_SDK_ROOT/tools:$ANDROID_SDK_ROOT/platform-tools:$PATH 如果在 Windows 系统上配置，基本流程一致，只是环境变量的配置方式略有区别。 安装额外的 SDK 不同的 SDK 对应不同的 Android 操作系统，如果你需要测试应用在不同版本上的适用性，就需要下载不同的 SDK。随着 Android 的发展，一些旧有的系统版本已经被弃用，这意味着你无须下载特别旧的 SDK。支持哪些版本，不支持哪些版本，由你来决定。 如果你希望安装额外的 SDK，可以使用内置的 Android 界面工具，使用下面的命令打开工具。 > android 只需要为你已经安装在系统上的 SDK 版本，安装 Android SDK Tools，对于 Android SDK Platform-Tools 推荐更新至最新版本。 安装 Cocos2d-x 安装 Cocos2d-x 可能是这个过程中最简单的部分，你可以从 Cocos2d-x 官网 下载独立的压缩包，也可以克隆 GitHub 仓库。不用安装这两个，选择你喜欢的一个。 下载压缩包 从官网下载压缩包，然后解压。 克隆 GitHub 仓库 使用下面的命令克隆 GitHub 仓库，并进行一些初始化设置。如果你不熟悉 GitHub 的工作流程，建议采取从官网下载压缩包的方式。 cd git clone git@github.com:cocos2d/cocos2d-x.git git submodule update --init git submodule update ./download-deps.py 之前不熟悉 GitHub，可以从 这个地方 学习后，再从 GitHub 克隆。 开发环境验证 在开始一个新项目之前，推荐先构建 cpp-tests 测试项目，他能确保你的开发环境已经完全配置好。如果在这个步骤中发生任何错误，请先仔细阅读错误信息，思考一下是否是上述步骤的环境配置存在问题。 查看有哪些 SDK 版本可用，运行： > android list targets 在终端中，将目录调整为 android-build.py 脚本的位置，这个脚本通常在引擎根目录 build 子目录下。运行： > python android-build.py -p cpp-tests 使用一个版本号代替，如：22。构建成功，证明环境配置没问题。 开始新项目 上面的工作都完成后，就可以开始创建新项目了。创建方法，在：cocos 命令行工具。 安装应用到手机 在手机上开启 USB 调试，然后通过 USB 连接手机，在终端中调整目录到 Android 项目的 bin 目录，运行下面的命令，即可将 apk 安装到你的 Android 手机： > adb install MyGame-debug.apk 注意：本文档教程只适用于 Cocos2d-x V3.15 或更低的版本 "},"installation/Android-VisualStudio.html":{"url":"installation/Android-VisualStudio.html","title":"Visual Studio (Deprecated)","keywords":"","body":"Android with Visual Studio Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Environment Requirements A Supported OS. See Installation Prerequisites Visual Studio 2015 update 2+ (NOT Visual Studio Code!) https://www.visualstudio.com/en-us/products/visual-studio-community-vs.aspx Prerequisites Download and install Visual Studio 2015 update 2+. Download and install Python. Ensure that it is available in your $PATH. Download Cocos2d-x and unzip it where you wish. From a command-line, change to the location you unzipped Cocos2d-x to and run: python setup.py Using Visual Studio with Cocos2d-x Make sure that you are using Cocos2d-x v3.12. Creating a new project Read our document on the Cocos Command-line tool and create a new project. Download proj.visualstudio copy proj.visualstudio.zip into your project's root directory and unzip it. It should fall inline with your other project directories. Example: By default proj.visualstudio contains a project called Cocos2d.sln, open this .sln file. Build and run! Integrating with an existing project Download proj.visualstudio copy proj.visualstudio.zip into your project's root directory and unzip it. It should fall inline with your other project directories. Example: By default proj.visualstudio contains a project called Cocos2d.sln, feel free to re-name this to your project's name. Open the .sln file. Add any source files and resources that are required to build your project. Change any necessary build settings required by your project. Build and troubleshoot any integration needs. "},"installation/Android-Eclipse.html":{"url":"installation/Android-Eclipse.html","title":"Eclipse (已弃用)","keywords":"","body":"Eclipse ADT （已弃用） 背景 由于 Google 自 2015 年底已中止了对 ADT 的支持，希望开发者转向 Android Studio。同时 Android Studio 的功能也已日趋完善，足够我们使用它完成 Cocos2d-x 项目的全部开发流程：编码、编译、调试、发布。因此自 3.16 版本我们不再支持 ADT。 如果你是一个新手，请转向 Android Studio 进行 Cocos2d-x 的环境搭建学习。如果明确有对老版本引擎的 Android 环境搭建需求，请继续阅读。 工具准备 完成上一节的 Android 命令行，上一节是本节的基础 下载 Eclipse ADT http://www.eclipse.org/downloads/ 导入游戏项目 打开 Eclipse 在 Package Explorer 的空白区域鼠标右键，选择 Import 在弹出框中选择 Existing Android Code Into Workspace，点击 Next 点击 Browse 按钮，进入上一节操作的 cpp-tests 项目目录，进入 proj.androi 子目录，点击确定 点击 Finish，等待导入操作完成 导入库项目 导入库项目的步骤基本与导入游戏项目一致，不同的是在 Browse 步骤，选择引擎根目录下 /cocos/platform/android/java 子目录。 导入完成后，将库项目添加到游戏项目 Java Build Path 的 Project 中。 构建并运行 将开启 USB 调试的手机，连接到电脑上。 确保你的电脑能识别手机 对于某些机型可能需要安装驱动。 右键游戏项目，选择 Run as，在子菜单中选择 Android Application。 注意：本文档教程只适用于 Cocos2d-x V3.15 或更低的版本 "},"installation/iOS.html":{"url":"installation/iOS.html","title":"iOS","keywords":"","body":"搭建开发环境 - iOS 工具准备 Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面 Xcode 9 下载后安装，下载参见：Apple官网页面 配置步骤： 打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj 在 Xcode 顶部工具栏选择 cpp-tests iOS，iPhone 7 Plus，点击运行，项目将自动编译运行，效果如图： 如何调试(Debug) 点击代码行左侧的空白，设置断点 运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值： "},"installation/OSX.html":{"url":"installation/OSX.html","title":"macOS","keywords":"","body":"搭建开发环境 - macOS 平台 工具准备 Cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面 Xcode 9 下载后安装，下载参见：Apple官网页面 配置步骤 打开 cocos2d-x-3.17/build/cocos2d_tests.xcodeproj 在 Xcode 顶部工具栏选择 cpp-tests Mac，My Mac，点击运行，项目将自动编译运行，效果如图： 如何调试(Debug) 点击代码行左侧的空白，设置断点 运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，视图会自动变化，左侧导航栏可以查看运行堆栈，底部窗口可以查看变量的值 "},"installation/Linux.html":{"url":"installation/Linux.html","title":"Linux 平台","keywords":"","body":"搭建开发环境 - Linux 平台 工具准备 Ubuntu 16.04，我们已在 Ubuntu 16.04 上做了版本功能的完整验证，建议用户使用此发行版，以防止由于版本不同引发编译或运行错误。下载参见：官网页面，aliyun 镜像站。 cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面 建议将默认软件源，替换为国内的软件源, 如//mirrors.aliyun.com/ubuntu, 这样在下载依赖时会有更快的速度 环境配置 运行引擎文件夹根目录 setup.py，脚本将会自动设置一些环境变量，遇到需要交互输入的可以直接回车跳过。 打开终端 terminal，运行脚本 build/install-deps-linux.sh 安装依赖 > cd $cocos2dx_root/build > sudo ./install-deps-linux.sh 建议使用 Ubuntu 16.04，使用其它系统，如果脚本未正确执行，请手动安装以下依赖 libx11-dev libxmu-dev libglu1-mesa-dev libgl2ps-dev libxi-dev g++ libzip-dev libpng12-dev libcurl4-gnutls-dev libfontconfig1-dev libsqlite3-dev libglew*-dev libssl-dev 编译 Cocos2d-x 运行 cmake 命令，生成 makefile： > mkdir linux-build > cd linux-build > cmake ../.. 命令执行成功，在 cmake 命令执行时的目录，会生成一系列文件： build/linux-build$ tree -L 1 . ├── CMakeCache.txt ├── CMakeFiles ├── Makefile ├── bin ├── cmake_install.cmake ├── engine └── lib 在上面的目录执行 make 命令，项目将进行编译，编译时可以看到百分比: > make -j 4 编译完成，./bin 子目录将生成 cocos2d-x 的全部测试项目： /build/linux-build/bin$ tree -L 2 运行任一测试项目，如 cpp-tests > cd bin/Debug/cpp-tests/ > ./cpp-tests 可以看到这样的效果 FAQ cpp-tests 运行时有 libfmod 报错，如何解决？ 报错类似： error while loading shared libraries: libfmod.so.6: cannot open shared object file: No such file or directory 请检查引擎子目录 external/linux-specific/fmod/prebuilt/64-bit 内 libfmod 软链接是否正常，不正常请手动修复。 ln -sf libfmod.so libfmod.so.6 ln -sf libfmodL.so libfmodL.so.6 "},"installation/Tizen.html":{"url":"installation/Tizen.html","title":"Tizen (Deprecated)","keywords":"","body":"Tizen Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Environment Requirements Windows, macOS or Ubuntu (a relatively recent version should suffice) Cocos2d-x v3.11 https://cocos2d-x.org/download Tizen 2.4 Rev3+ SDK https://developer.tizen.org/development/tools/download Java JDK for your platform (a relatively recent version should suffice) Prerequisites Download Cocos2d-x. Download Tizen installer. Download Java JDK for your platform. Installation Install Java JDK for your platform. You may or may not need to do this depending upon your current setup. Install Tizen using the installer you downloaded. If you haven't downloaded it, please refer to prerequisites above. Double click the Tizen installer that you downloaded and follow the prompts. Click the 'Done' button, then when prompted to run the Update Manager, click 'Yes(Y)'. Select 2.4 Mobile and click the down-arrow at the right side to install. If you install version 2.4, the resulting TPK could also be installed on Tizen device runs 2.3 version system. The resulting TPK is back compatible for old version devices. After completing all steps, you should be able to launc the Tizen IDE 2.4. Running the built in tests Just like with any platform Cocso2d-x supports, you can run our sample tests to understand the engine's functionality. For c++ you want to look at cpp-tests and for Lua, lua-tests. Launch the Tizen IDE Select File -> Import Under General, select Existing Projects into Workspace Browse to where the Cocos2d-x root is. Then select cpp-tests and libcocos2d-x ensuring that the path for both contains proj.tizen as it is possible to import projects for Android, but we don't want to do this. By default, a project has three configurations Debug, Release and Emulator. Debug and Release are settings that build for hardware. Emulator is for simulating a hardware device when one is not available. It is always best to test on actual hardware before deploying your app to production. To change either Debug or Release, right click on the libcocos2d-x project and select Properties. When this window opens, select C/C++ Build -> Tizen Settings. A few items here need to be changed. Change the properties with the red boxes on the screenshot below. Choose Mobile 2.4, x86 and GCC 4.9 of the toolchain. Then click the OK button. Repeat this same step for the cpp-tests project. To build for the Emulator, right click on the libcocos2d-x project and select Build Configurations -> Set Active -> Emulator Now, we can build. First, build libcocos2d-x. Right click on the libcocos2d-x project and select Build Project or press the F10 key. Repeat this same step for the cpp-tests project. Once everything is built cpp-tests will run and you can experiment with it's functionality. Compiling & Running with Command-line tool You also can compile & run your project on Tizen with cocos command. There are some arguments for the Tizen platform: | Argument | Available Value | Description | | ----|----|----| | --tizen-arch | x86, arm | Determines the architecture type for the rootstrap. Default is x86. (x86 is for simulators, and arm for devices) | | --tizen-profile | Path of signing profile | Set the profile path for signing. | | --tizen-sign | String | Set the profile name to use for signing. | | --tizen-strip | - | Determines whether to strip the native binary. | Sample commands: cocos compile -s PROJECT_PATH -p tizen -m release --tizen-arch arm --tizen-profile PROFILE_PATH --tizen-sign SIGN_STRING --tizen-strip Compile the project for the ARM architecture. A .tpk file will be generated. cocos run -s PROJECT_PATH -p tizen --tizen-profile PROFILE_PATH --tizen-sign SIGN_STRING Launch the Tizen simulator and then run the project on the Tizen simulator. (Note: it is important to remember that the Tizen simulator must always be running in-order to run your project.) Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. "},"installation/Windows.html":{"url":"installation/Windows.html","title":"Windows 平台","keywords":"","body":"搭建开发环境 - Windows 平台 工具准备 Visual Studio 2015，我们已在 Visual Studio 2015 上做了版本功能的完整验证，建议用户使用此IDE，以防止由于版本不同引发编译或运行错误。下载参见：官网页面，Visual Studio 2015 发布页面。 cocos2d-x v3.17，下载后解压，下载参见：Cocos官网页面 配置步骤 双击 cocos2d-x-3.17\\build\\cocos2d-win32.sln， Visual Studio 将打开此解决方案，解决方案打开后，可以看到这样的项目列表： 默认情况下项目列表中 cpp-tests 加粗显示，表示是启动项目，此时点击菜单栏中本地 Windows 调试器进行项目的编译和运行。编译过程视机器性能不同，会花费 10-30 分钟的时间，编译完成后，将自动运行，运行成功将看到测试程序： 如何调试(Debug) 点击代码行左侧的空白，设置断点 以 debug 模式运行 cpp-tests 操作 App 触发断点，IDE 将卡在断点处，Debug 视图会自动跳出，可以查看运行堆栈和变量的值 FAQ 使用 Visual Studio 2017 运行 cpp-tests 注意事项 由于 Visual Studio 2017 默认下载的组件可能与 cocos2d-x-3.17.zip 发布包中项目的配置不同，造成打开 cocos2d-x-3.17\\build\\cocos2d-win32.sln 会缺少组件，按照提示安装。 可能 Visual Studio 2017 与 Visual Studio 2015 读取配置文件逻辑有差异，cpp-tests 未自动设置为启动项目，在项目列表中右键单击此项目，选择 设为启动项目。 编译时有工具集报错, 按照报错提示 右键单击该解决方案，然后选择“重定解决方案目标” 操作，完成后右键单击项目重新生成。报错信息如下： error MSB8020: 无法找到 Visual Studio 2010 的生成工具(平台工具集 =“v100”)。若要使用 v100 生成工具进行生成，请安装 Visual Studio 2010 生成工具。或者，可以升级到当前 Visual Studio 工具，方式是通过选择“项目”菜单或右键单击该解决方案，然后选择“重定解决方案目标”。 解决出现的问题后，Visual Studio 2017 可以正常运行 cpp-tests ，但也不能保证引擎所有功能都可以在本 IDE 正常运行。建议使用 Visual Studio 2015 与官方测试团队保持一致。 通过 CMake 使用模板工程需要了解的一点 通过 cocos new 新建 cpp，js，lua 三个工程，使用 CMake 生成 Visual Studio 的工程，cpp 和 js 的工程可以正常编译运行，但是 lua 的工程，编译成功却运行失败？ lua 工程使用了 simulator 的库，导致在 Visual Studio 内运行时，不能正确找到工作目录。需要手动修改工程配置，将项目属性中调试内的工作目录改为 CMake 生成目录下的 bin\\TemplateLua\\Debug。 Distributing a Cocos2d-x app on Windows Note: this falls outside of the realm of Cocos2d-x. Please consult Microsoft resources for assistance. If you try to run a game created with Cocos2d-x on a non-development machine, it may be required for this machine to have the Visual Studio runtime installed. The easiest way is to create an installer for your game, but it is possible to do it without by installing all required pieces manually. Use Dependency Walker to check what DLLs your game requires. Install the required Visual Studio runtime. Microsoft has now merged VS2015, 2017 and 2019 runtimes into one, which you can find here. For the installer, check these posts: InnoSetup (also shows you a sample for how to install the VS C++ runtime using it). Sample InnoSetup script for Cocos2d-x here. Troubleshooting Please see this F.A.Q for troubleshooting help. "},"installation/Windows-Phone.html":{"url":"installation/Windows-Phone.html","title":"Windows Phone (Deprecated)","keywords":"","body":"Windows Phone 8 Installation and Setup Deprecated Document. Cocos2d-x V3.15 or less is the last supported version. Prerequisites A supported environment. See Installation Prerequisites Register to be a Windows Phone Developer https://developer.microsoft.com/en-us/windows Setting up Cocos2d-x Download Cocos2d-x and unzip it. (maybe: ~/) Make sure you have a working environment see Prerequisites above. This means a working Python, having run /setup.py> and updated your $PATH. Compile and run the cpp-tests project Open cocos2d-wp8.vc2012.sln in the build folder Right click the cpp-tests project, and select Set as StartUp Project. Select Emulator or a Device to run the project on. If you select Device you need to connect your phone device using usb. Compile and run the TestCpp project. How to debug in project Right click cpp-tests, select Properties, in Debug, select debug target. If you select Managed Only in UI Task, it's to debug c# code in cpp-tests. If you select Native Only, it's to debug c++ code in cpp-testsComponent. If you select Native Only and want to use CCLog function, right click cpp-testsComponent and define COCOS2D_DEBUG=1 in Preprocessor Definitions. Starting a new project Once everything above works, you can start a new project! To do this, read our document on the Cocos Command-line tool. "},"installation/CMake-Guide.html":{"url":"installation/CMake-Guide.html","title":"CMake 指南","keywords":"","body":"CMake 指南 CMake 是一个开源的跨平台构建工具，Cocos2d-x 是一个开源的跨平台游戏引擎，两者十分契合。 Cocos2d-x 决定自 3.17 版本开始，支持 CMake 的全平台构建。支持的平台包括 Android (NDK)、iOS、macOS、Linux、Windows（VC++ compiler），同时支持通过 CMake 将引擎部分进行预编译，并在新的构建过程中重用预编译的引擎库。 基本概念 在使用 CMake 构建工程之前，最好能对软件构建中一些基本的概念有初步的了解，比如什么是编译，链接，打包。了解这些对后续使用 CMake 有很大的帮助。 此处只解释一下：外部构建（Out-of-source Build），在从源码生成最终的二进制可执行文件的过程中，会生成大量的中间文件，中间文件和源码在同一个目录内时会使源码目录混乱不堪，使用外部构建，即将所有生成的中间文件都放在一个非源码目录中，这样无论构建多少次，源码目录始终干净如新。 常用构建选项 CMake 通用 -G，通过 CMake 生成特定 IDE 的项目配置文件。这个操作依赖 IDE，即无法在一个没安装 Xcode 的 macOS 上通过 CMake 生成对应的工程文件。 -GXcode 生成 Xcode 工程文件 -GVisual Studio 15 2017 生成 Visual Studio 2017 工程文件 CMAKE_BUILD_TYPE, 指定构建模式，比如 Debug 还是 Release，默认值 Debug。 -DCMAKE_BUILD_TYPE=Release 指定以 Release 模式生成工程。 -H -B，-H 用来指定一个源码目录，指定的目录必须含有一个 CMakeLists.txt 文件，-B 用来指定 CMake 生成的中间文件的存放目录。 -H..\\cocos2d-x -Bmsvc_build 指定要构建工程的工程路径是上一级目录的 cocos2d-x 子目录，指定 CMake 生成的文件存放在 msvc_build 目录。 --build 执行构建过程，同时指定曾使用 CMake 命令生成的构建文件所在目录。 cmake --build ./msvc_build 在执行这个构建过程时，CMake 会自动选择对应的构建工具。 各平台构建示例 Linux cd cocos2d-x mkdir linux-build && cd linux-build cmake .. make -j 4 在执行 make -j 4 命令之前，可以执行 make help 查看所有的构建目标，使用 make 构建一个特定的目标。 macOS cd cocos2d-x mkdir mac-build && cd mac-build cmake .. -GXcode open Cocos2d-x.xcodeproj 在 macOS 上使用 cmake .. -GXcode 将会默认生成 macOS 的工程。iOS 工程和 macOS 工程并不能同时生成到一个 XCode 工程中。 iOS cd cocos2d-x mkdir ios-build && cd ios-build cmake .. -GXcode -DCMAKE_TOOLCHAIN_FILE=../cmake/ios.toolchain.cmake open Cocos2d-x.xcodeproj 默认构建的是为运行在 iOS 设备的工程，如果想构建运行在模拟器的工程，请加参数 -DIOS_PLATFORM=SIMULATOR 或 -DIOS_PLATFORM=SIMULATOR64。 Android 默认工程配置在 Android 上使用旧有的 ndk-build 构建 C++ 部分，开启 CMake 构建，请先更改 Gradle 配置中的 PROP_NDK_MODE 属性为 cmake，再同步 Gradle 配置，同步完成后，可以看到外部构建脚本从 Android.mk 变为了 CMakeLists.txt。 # android native code build type # none, native code will never be compiled. # cmake, native code will be compiled by CMakeLists.txt # ndk-build, native code will be compiled by Android.mk PROP_BUILD_TYPE=ndk-build 如果需要在 Android Studio 中使用预编译库，需特别设置预编译库存放的目录，请参考关于预编译库的介绍，以及 build.gradle 中的注释。 Windows cd cocos2d-x mkdir win32-build && cd win32-build cmake .. -G\"Visual Studio 15 2017\" 以上命令使用 CMake 生成 Cocos2d-x 测试项目的 Visual Studio 2017 工程。生成后，在文件浏览器中找到 cocos2d-x/win32-build 目录，双击打开 Cocos2d-x.sln。设置 cpp-tests 为启动项目，即可正常编译运行。 另一种方式，由于 Visual Studio 2017 已经直接支持 CMake 工程，可以直接使用。详细请参考 CMake 支持。 CMake 帮助 CMake 官网: cmake.org CMake 文档: cmake.org/documentation CMake FAQ: Wiki/CMake_FAQ "},"editors_and_tools/":{"url":"editors_and_tools/","title":"Tools","keywords":"","body":"Editors and Tools The Cocos platform provides the following editors and tools to aid in development. Cocos Creator Creator to Cocos2d-x tool Cocos Command-line tool Cocos GUI (Deprecated) "},"editors_and_tools/cocosCLTool.html":{"url":"editors_and_tools/cocosCLTool.html","title":"引擎工具","keywords":"","body":"cocos 命令 Cocos2d-x 带有一个命令行工具：cocos 这是一个跨平台的工具，你可以用它创建项目、运行项目、发布项目。命令行工具适用于所有 Cocos2d-x 支持的平台，包括：iOS、Android、Mac、Linux、Windows、Web。不用 IDE，只用命令行，你就能完成所有的工作！ 工具配置 运行引擎源码根目录的 setup.py，这个脚本会配置一些环境变量，并将 cocos 命令添加到系统路径中。注意运行本脚本需要系统安装 2.x（不是 3.x）版本的 Python。 # Option 1 > ./setup.py # Option 2 > python setup.py 在 macOS 系统为了确保字符编码格式的正确，最好在 ~/.bash_profile 文件中增加下面两行： export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 修改之后，记得执行 source ~/.bash_profile 或着重启终端，这样新增的环境变量才会生效。 测试 为了确保 cocos 命令行工具已经添加到环境变量，可以正常使用。请先运行 cocos -v： > cocos -v Python 2.7.10 cocos2d-x-3.16 Cocos Console 2.3 如果有类似上面的输出，就证明了已经配置好，如果提示找不到命令，就需要检查一下环境变量是否设置正确。如果有配置，试着运行一下 source ~/.bash_profile 使配置文件生效。 命令行工具在这个目录 _cocos2d-x/tools/cocos2d-console/bin 项目创建 使用 cocos new 命令创建新项目，命令格式如下： cocos new -p -l -d 示例： cocos new MyGame -p com.MyCompany.MyGame -l cpp -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l lua -d ~/MyCompany cocos new MyGame -p com.MyCompany.MyGame -l js -d ~/MyCompany 使用命令 cocos new --help 可以查看到更多关于项目创建的帮助信息。 项目编译 我们都知道，程序从源码到二进制程序，有一个编译环节。我们来看下 Cocos2d-x 是如何编译项目的，命令格式如下： cocos compile -s -p -m -o 示例： cocos compile -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin cocos compile -s ~/MyCompany/MyGame -p android -m release -o ~/MyCompany/MyGame/bin cocos compile -s c:\\MyCompany\\MyGame -p win32 -m release -o c:\\MyCompany\\MyGame\\bin 这里的参数有点多，让我们来一个一个说，-p 是编译的平台，-m 是模式：debug 或者 release。如果没指定模式，默认 debug。此外 -s 和 -o 参数是可选的，如果操作命令的当前路径就是工程的路径，那这两个参数都可以省掉。比如已经在 ~/MyCompany/MyGame 目录，那编译命令可以简化为： cocos compile . -p ios -m release 你也可以增加一个可选的参数 -q，这样执行静默操作，控制台的输出信息会比较少。示例： cocos compile -q -s ~/MyCompany/MyGame -p ios -m release -o ~/MyCompany/MyGame/bin 由于命令行工具支持很多平台，因此还有一些特定平台的参数，使用它们可以进行更多的控制，比如指定 SDK 版本，确定签名信息，添加一些 Lua 相关或专用于 Web 的选项。 使用命令 cocos compile --help 可以查看更多关于项目编译的帮助信息。 Android 项目编译注意事项 命令行工具是很灵活的，对于编译 Android 项目允许开发者使用特定版本的 API。比如你的系统上安装了 Android-22，你想使用它来编译，就在命令行的最后增加参数 --ap android-api-version。示例： cocos compile -p android --ap android-22 你可以在项目的配置中，查看到目标 API 是什么版本。 项目运行 创建完项目后，你可以直接从命令行执行运行命令。cocos 会启动你指定平台的程序。命令行格式如下： cocos run -s -p 示例: cocos run -s ~/MyCompany/MyGame -p ios cocos run -s ~/MyCompany/MyGame -p android cocos run -s c:\\MyCompany\\MyGame -p win32 当然，你也可以指定程序以 debug 还是 release 方式运行，默认的方式是 debug。示例： cocos run -s ~/MyCompany/MyGame -p ios -m release 就好像 cocos compile 命令那样，如果你已经在项目目录了，-s 和 -o 参数就不是必须的，这对 cocos run 命令也一样。就以上面的为例，如果已经在工程目录，命令可以简化成： cocos run . -p ios -m release 在运行 Web 程序时，还有可选的参数，允许你指定浏览器，例如指定 Google Chrome： cocos run -s ~/MyCompany/MyGame -p web -b /Applications/Google\\ Chrome.app cocos run -s ~/MyCompany/MyGame -p web -b C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe cocos run -s ~/MyCompany/MyGame -p web -b /usr/local/bin/chrome 你还可以指定 IP 地址和端口，更多关于项目运行的使用帮助，请运行 cocos run --help 命令。 项目发布 cocos 通过提供一系列项目发布的命令实现了简单的发布机制。这些命令，就像上面介绍的命令一样，通过一些参数指定需要的操作。命令格式如下： cocos deploy -s -p -m 示例： cocos deploy -s ~/MyCompany/MyGame -p ios -m release cocos deploy -s ~/MyCompany/MyGame -p android -m release cocos deploy -s c:\\MyCompany\\MyGame -p win32 -m release 你可以增加参数 -q，执行静默操作，这样控制台的输出信息会比较少。示例： cocos deploy -q -s ~/MyCompany/MyGame -p ios -m release 运行 cocos deploy --help，可以查看更多关于项目发布的帮助信息。 "},"editors_and_tools/creator_to_cocos2dx.html":{"url":"editors_and_tools/creator_to_cocos2dx.html","title":"Creator to Cocos2d-x 插件","keywords":"","body":"creator_to_cocos2dx 插件 Cocos Creator 可以很高效的编辑场景和 UI，同时内置支持 JavaScript，这对 JavaScript 开发者十分友好。可是对于 C++/Lua 开发者，无法直接利用 Creator 高效的界面编辑功能，可能有一些遗憾。 为了去除这种遗憾，我们提供了 creator_to_cocos2dx 插件，它允许开发者导出 Creator 编辑的场景到 Cocos2d-x 的 C++/Lua 工程中。插件逻辑上分为两部分，第一部分是 Creator 的插件，负责把 Creator 制作的场景导出为 .ccreator 文件；第二部分是 reader，负责在 C++/Lua 工程中解析导出的 .ccreator 文件。 特性 使用插件要求 Cocos2d-x 版本 v3.14+，Creator 版本 v1.4+。 Creator 使用基于组件的模型创建对象，而 Cocos2d-x 每个对象有自己的结构，因此插件很难支持全部的 Creator 特性。下面是目前支持的一些特性： Node Node Node Node Node Scene Sprite Canvas ScrollView Label EditBox ParticleSystem TiledMap Button ProgressBar RichText SpineSkeleton Widget Animations VideoPlayer WebView Slider Toggle ToggleGroup PageView Mask Collider Prefab DragonBones 如果在使用过程中，发现某些特性不支持，升级 Cocos2d-x 和 Creator 可能是一个解决办法。 安装配置 在 Cocos Creator 中添加 creator_to_cocos2dx 插件： 克隆 GitHub 仓库 Creator To Cocos2d-x. 将插件仓库目录 creator_project/packages/creator_luacpp_support 拷贝到 Creator 项目的 packages 目录 使用 Creator 打开刚才添加插件的项目，在菜单栏的项目(Project)下，即可看到 LuaCpp Support 菜单项。 Creator 场景导出 使用插件进行场景导出： 在菜单栏中点击 项目(Project) -> LuaCPP Support -> Setup Target Project，出现的对话框中 Project Path 选择目标 Cocos2d-x 工程的路径。 点击 Build，构建过程将很快完成 在你编译运行 Cocos2d-x 项目前，记得重新 Build。完成 Build 后，导出的 reader 源码和 Creator 资源将位于如下位置： C++ 项目： 源码： NATIVE_PROJECT_ROOT/Classes/reader 资源： NATIVE_PROJECT_ROOT/Resources/creator LUA 项目： 源码：NATIVE_PROJECT_ROOT/frameworks/runtime-src/Classes/reader 资源：NATIVE_PROJECT_ROOT/frameworks/runtime-src/Resources/Creator NATIVE_PROJECT_ROOT 是 Build 时，选择的 Project Path 路径 导出选项 Export Resource Only, 不导出插件包含的 reader 源码，只导出 Creator 的场景和相关的资源，通过这种方式，可以避免二次导出的时候插件附带的原始 reader 覆盖掉已经导出到项目中的 reader。 Export Resource Dynamically Loaded, 导出可能被动态加载的资源，根据 Creator 的资源使用规范，动态加载的资源需要放置到 resources 目录下。默认的导出选项，只导出在 Creator 场景中被静态引用的资源文件。 Auto Build After Scene Saved,在 Creator 场景保存后，后台运行插件，按照面板的配置进行导出。通过这种方式简化开发者使用插件进行导出的流程。 场景导入 Cocos2d-x 项目 完成上一步的场景导出后，reader 源码和 Creator 资源都被放到文件系统中了。此时你需要将这些东西，添加到工程中。 增加头文件搜索路径 将这些目录，添加到工程的头文件搜索路径中： 对于 C++ 项目： ```sh reader ``` 对于 Lua 项目： ```sh reader reader/collider reader/animation reader/dragonbones/cocos2dx reader/dragonbones/armature reader/dragonbones/animation reader/dragonbones/events reader/dragonbones/factories reader/dragonbones/core reader/dragonbones/geom ``` Android 平台的特殊处理 Android 平台的头文件搜索路径添加方式有一些特殊，需要修改 Android.mk 文件。仿照下面的示例，添加文件包含： 对于 C++ 项目： ```sh LOCAL_STATIC_LIBRARIES += creator_reader # _COCOS_LIB_ANDROID_BEGIN # _COCOS_LIB_ANDROID_END $(call import-module, ./../../Classes/reader) # import module path ``` 对于 Lua 项目： ```sh # for lua include $(CLEAR_VARS) LOCAL_MODULE := creator_reader_lua LOCAL_MODULE_FILENAME := libcreatorreaderlua LOCAL_ARM_MODE := arm LOCAL_SRC_FILES := $(cpp_src) \\ lua-bindings/creator_reader_bindings.cpp \\ lua-bindings/reader/lua_creator_reader_auto.cpp \\ lua-bindings/reader/lua_creator_reader_manual.cpp \\ lua-bindings/dragonbones/lua_dragonbones_manual.cpp \\ lua-bindings/dragonbones/lua_dragonbones_auto.cpp LOCAL_STATIC_LIBRARIES += creator_reader_lua # _COCOS_LIB_ANDROID_BEGIN # _COCOS_LIB_ANDROID_END $(call import-module, ./../../Classes/reader) ``` 导入场景的使用 上面的工作完成了，你就可以添加代码开始使用 Creator 中的场景了，使用方式非常的简单： 对于 C++ 项目，只需要一步： // mygame.cpp #include \"reader/CreatorReader.h\" void some_function() { creator::CreatorReader* reader = creator::CreatorReader::createWithFilename(\"creator/CreatorSprites.ccreator\"); // will create the needed spritesheets + design resolution reader->setup(); // get the scene graph Scene* scene = reader->getSceneGraph(); // ...and use it Director::getInstance()->replaceScene(scene); } 对于 Lua 项目，需要两步： 注册 reader 绑定： #include \"reader/lua-bindings/creator_reader_bindings.hpp\" ... register_creator_reader_manual(L); 添加代码使用导出的场景： local creatorReader = creator.CreatorReader:createWithFilename('creator/CreatorSprites.ccreator') creatorReader:setup() local scene = creatorReader:getSceneGraph() cc.Director:getInstance():replaceScene(scene) 如何使用 ColliderManager 我们提供了 ColliderManager 对象用于管理碰撞，每个场景都有一个 ColliderManager 的实例，你可以使用使用这个实例，监听碰撞事件： creator::CreatorReader* reader = creator::CreatorReader::createWithFilename(\"creator/CreatorSprites.ccreator\"); // will create the needed spritesheets + design resolution reader->setup(); // get the scene graph Scene* scene = reader->getSceneGraph(); auto colliderManager = scene->getColliderManager(); colliderManager->registerCollitionCallback([=](creator::Contract::CollisionType type, creator::Collider* collider1, creator::Collider* collider2) { if (type == creator::Contract::CollisionType::ENTER) colliderManager->enableDebugDraw(true); if (type == creator::Contract::CollisionType::EXIT) colliderManager->enableDebugDraw(false); }, \"\"); 了解更多的 ColliderManager 特性，请查看 ColliderManager.h "},"tutorials/":{"url":"tutorials/","title":"Tutorials","keywords":"","body":"Cocos2d-x Mini Tutorials Get started with particular areas of the Cocos Engine by reading any one our mini tutorials. Storing Game Data "},"tutorials/storing-game-data/":{"url":"tutorials/storing-game-data/","title":"Storing Game Data","keywords":"","body":"Storing Game Data In most every game there are probably items that need to be stored and re-read in again between game play. This could be player information, stats, leaderboards, level progress and so much more. As always there are many ways a developer can choose to store this data. Each approach has advantages and disadvantages. In this tutorial we will explore storing game data with UserDefault and SQLite. UserDefault UserDefault is simple key/value pair data structure. It is a global singleton that can be accessed at any time, much like the Director. UserDefault is always present, even if you never invoke it. It is just empty. The first time you add a key/value pair an instance is created. Accessing UserDefault Accessing UserDefault is as simple as: cocos2d::UserDefault::getInstance()->someFunction(); However, if you plan to access UserDefault more than once, it is best to grab the instance once and then use it versus accessing it each and every time you need it. Example: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setIntegerForKey(\"score\", 10); Adding values to UserDefault Adding key/value pairs to UserDefault is easy: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setIntegerForKey(\"score\", 10); userdefaults->setFloatForKey(\"some_float\", 2.3f); userdefaults->setDoubleForKey(\"some_double\", 2.4); userdefaults->setBoolForKey(\"some_bool\", true); Changing values in UserDefault It may be necessary to change a key/value pair in UserDefault. Perhaps you are storing the players score and it needs to be updated. This is achieved by simply setting the value a second time. Example: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->setStringForKey(\"message\", \"Hello\"); userdefaults->setStringForKey(\"message\", \"Hello Again\"); Deleting values to UserDefault Deleting key/value pairs from UserDefault is also easy: auto userdefaults = cocos2d::UserDefault::getInstance(); userdefaults->deleteValueForKey(\"message\"); userdefaults->deleteValueForKey(\"score\"); userdefaults->deleteValueForKey(\"some_float\"); userdefaults->deleteValueForKey(\"some_double\"); userdefaults->deleteValueForKey(\"some_bool\"); Resetting UserDefault If you wish to clear out UserDefault completely and start from scratch you can simple call: cocos2d::UserDefault::getInstance()->flush(); Assigning UserDefault value to Labels You probably will want to use values stored in UserDefault and assign them to Label objects for the players to see. You can achieve this with just a few lines of code. Example: char strTemp[256] = \"\"; std::string ret = UserDefault::getInstance()->getStringForKey(\"message\"); sprintf(strTemp, \"string is %s\", ret.c_str()); some_label->setString(strTemp); SQLite If your needs are more advanced than a simple key/value pair you can evaluate using a database to store and manipulate your game data. SQLite is a very popular and commonly used relational database. You can read more about SQLite on the SQLite website. Setting up SQLite Download the SQLite bundle that works for your needs. There are both source code and pre-compiled binary releases. If you use the source code release you can simply drop sqlite3.h and sqlite3.c into your source tree and use include to bring in SQLite. If you use pre-compiled binaries you will need to add this as part of your library search paths. Creating a database There are a few ways to create a new SQLite database. Shipping a default database If you download the SQLite CLI you can use the command-line to interact with SQLite and all of it's functionality. If you choose this approach you will need to ship your database with you game as you are not creating it in code. This method allows you to use less SQL code up front, making your coding a bit less. However, you will still need to use SQL code when your game needs to interact with the database. Programatically creating a database If you don't wish to ship a default/pre-populated database you can always create a new database on the first launch of the game and then check if the database exists on each subsequent launch. This approach means more code. We will cover this approach in the next sections. Working with SQLite programatically There are several working pieces that are needed to interact with any database, not just SQlite. Let's take a look at what they are: a connection to the database: You can either maintain a persistent database connection while you game is running or open and close the connection as needed. If you maintain a persistent database connection, if the dataase connection gets lost you will need to handle these type of error and re-connect (this is unlikely with SQLite). If you open and close as needed you always have a connection but if multiple parts of your game are doing this at the same time you may experience locking issues or database corruption. a database to work with: either ship one with your game or create one programatically on the first launch. In either case you will need to have a database to work with. populating the database with default values: either shipping a pre-populated database with your game or creating the default values on first launch. checking values from the database: reading data from the database to make decisions in your game. updating the database as values change: as values change, storing them for fuure use (as your game dictates) closing the database connection when it is not in use: this should be done with both a persistent connection and opening a connection as needed. Failure to close the connection can result in data-loss. Use a Manager class? Using a singleton as a manager class might be a good option. This encapsulates all of the SQL functionality to a single place provided easy access to functions without a lot of mess. A singleton pattern helps provide a single(or global) instance of a class. You can read more about singleton patterns. A simple singleton may look something like this: c++ header: #ifndef _SQLMANAGER_H_ #define _SQLMANAGER_H_ #include #include class sqlite3; class SQLManager { public: static SQLManager* Instance(); virtual ~SQLManager() {} void initInstance(); bool connect(); bool isDatabasePopulated(); bool createDatabaseContents(); bool createMainTable(); inline bool getIsDatabaseReady() { return _bDatabaseReady; }; inline sqlite3*& getDatabase() { return _pdb; }; static int executeSelectQueryReturnSingleInt(const std::string& _sql); int getKeyByID(const std::string& _key, const std::string& _value); static std::string getSQLToCheckCounts(const std::string& _tableName); static void updateKey(const std::string& _key, const int& _value); private: SQLManager(); SQLManager(const SQLManager&); SQLManager& operator= (const SQLManager&); static SQLManager* pinstance; bool _bDatabaseReady = false; sqlite3* _pdb; std::string _dbFile = \"MyDatabase.db3\"; std::string _dbName = \"MyDatabase\"; std::string _dbPath; int _dbVersion = 1; // increment this when database structure changes }; #endif // _SQLMANAGER_H_ c++ source: #include \"SQLManager.hpp\" #include \"sqlite3.h\" #include \"cocos2d.h\" SQLManager* SQLManager::pinstance = 0; SQLManager::SQLManager() {} SQLManager* SQLManager::Instance() { if (pinstance == 0) { pinstance = new SQLManager; pinstance->initInstance(); } return pinstance; } void SQLManager::initInstance() { // what do we need to do when this class is instantiated? } bool SQLManager::connect() { // connecting to SQLite } bool SQLManager::isDatabasePopulated() { // is our database already populated? } bool SQLManager::createDatabaseContents() { // creating the database contents } bool SQLManager::createMainTable() { // creating the main table, but you may need more tables... } int SQLManager::executeSelectQueryReturnSingleInt(const std::string& _sql) { // returning an int as a result from a query } int SQLManager::getKeyByID(const std::string& _key, const std::string& _value) { // obtaining a key } std::string SQLManager::getSQLToCheckCounts(const std::string& _tableName) { // checking how many rows a table has } void SQLManager::updateKey(const std::string& _key, const int& _value) { // when we need to update data } This singleton class will continue to be used through the rest of this tutorial, adding to it as needed. There are arguments for why singleton patterns can be bad Creating a database To create a new database, it is best to see if an existing database already exists. If it does, it means your game has been played before on this device, no need to create a new one. Let's check for an existing database and if not create a new one using SQLManager::initInstance(), SQLManager::connect() and SQLManager::isDatabasePopulated(): void SQLManager::initInstance() { if (connect()) { if (isDatabasePopulated()) { // the database was found and is populated. } else { // a new database was created, so we need to pupulate it. } } else { // we failed to connect, handle this more gracefully for production!!! std::cout getWritablePath() + _dbFile; int result = sqlite3_open(_dbPath.c_str(), &_pdb); if(result == SQLITE_OK) { //std::cout The above code tries to open the specified database, at the specified path. If the file is already present, it opens, ig the file is not present it is still opened, but it would be empty. We don't know which! One solution is to check for the existence of a database table that would be present if your game has already been played. We will go into detail about this next. Before we do, let's make sure that we also understand that calling cocos2d::FileUtils::getInstance()->getWritablePath() will ensure that the path we get back is indeed the writeable path on this specific device. As operating systems handle this differently and also have different locations it is important that this call be made and it's return value be used. It is not advised to try and make custom locations outside what the device vendor wishes to allow. Populating a database As learned above, when trying to open a SQLite database, if it doesn't exist it will be created by the SQLite code. Therefore once you connect to the database, you don't know if the database already has data for your game or if this was the first time it is being played and therefore has zero data in it. You need to make this decision before proceeding because if the database doesn't have the data your game needs, your game fails immediately with errors and the player may never play it again because they think it is a broken or poorly made game. How might we go about doing this? Remember the unexplained call above to SQLManager::isDatabasePopulated()? Let's do the checking there and return true; if the database has previous data and return false; if it does not. If return false; then populating the database with default data is necessary. Consider this code which attepmpts to check for a table named Master to be present: bool SQLManager::isDatabasePopulated() { bool _bPopulated = false; sqlite3_stmt *statement; std::string _sql = \"SELECT count(*) FROM (SELECT * FROM sqlite_master UNION ALL SELECT * FROM sqlite_temp_master) WHERE type='table' AND name='\" + std::string(\"Master\") + std::string(\"' ORDER BY name LIMIT 1;\"); //std::cout If a table named Master exists, true will be returned and then we know we have a database that has been populated before this launch of the game. Meaning we don't need to populate it. We can continue on knowing our database is ready to read/write/update data. If a table named Master does not exist false is returned and this means we need to populate our database before using it. To do this we need to create tables with rows in them. It's hard to be specific here because each game requires unique data. However, the idea is to use the SQL CREATE TABLE command along with inserting a few rows: // a vector with what values to initially need in the Master table. const std::vector AppDBMasterTableID = {\"HighScore\", \"HighTime\", \"CurrentScore\", \"CurrentTime\", \"CurrentVersion\"}; //std::cout AppDBMasterTableValue = {0, 0, 0, 0, 1.0}; for (unsigned i = 0; i With this concept, next time the game starts a database will exist and have the default values that are needed. It wont be created every time the game is started. Any new data that is updated or inserted into the database will persist between launches! Querying data in the database After you have the database starting when the game starts and doing a quick integrity check to make sure it has the minimum necessary daya you will need to query the database from time to time to get values to make decisions. This might mean checking to see if the player beat a previous high score or if a player has beat a particular boss. Querying the database is an easy and common operation using the SQL SELLECT statement. Example: SELECT value from Master WHERE id=\"high score\"; SQLite is pretty flexible in getting back data and looping over it. Consider something like: std::string _sql = \"SELECT \" + std::string(value) + std::string(\" FROM \") + std::string(\"Master\") + std::string(\" WHERE _id='high score' LIMIT 1;\"); sqlite3_stmt* statement; if (sqlite3_prepare_v2(Instance()->getDatabase(), _sql, -1, &statement, 0) == SQLITE_OK) { int cols = sqlite3_column_count(statement); int result = 0; while(true) { result = sqlite3_step(statement); if(result == SQLITE_ROW) { for(int col = 0; col With this code the high score is returned as a string so that it can be used in a Label object. Note that since we are just selecting the value column we only iterate over just that column in the SQL table. Updating data in the database Updating works just the same as selecting data but with a different SQL statement format. A SQL UPDATE statement will be used instead. Consider: std::string _sql = \"UPDATE \" + std::string(\"Master\") + std::string(\" SET _value\") + std::string(\"=\") + std::to_string(10) + std::string(\" WHERE _id='high score';\"); //std::cout getDatabase(), _sql, NULL, NULL, NULL); if (result == SQLITE_OK) { std::cout In this example the high score is updated. Inserting new data into the database Inserting data is also easy and the format looks as familiar as the SQL SELECT and SQL UPDATE statements. Consider: std::string _sql = \"INSERT INTO \" + std::string(\"Master\") + std::string(\" VALUES ('15')\"); Closing the database connection While it isn't totally necessary to close a SQLite database, it is a good idea to play it safe and do so. Database corruption is possible if you don't. Consider closing the database where it makes sense in your code, possible on game exit. sqlite3_close(); "},"tutorials/youre-on-camera/":{"url":"tutorials/youre-on-camera/","title":"You're On Camera","keywords":"","body":"Smile, you're on camera! Yes, exactly like that! Just like using a camera to shoot your friends having fun at a party, you can use similar concepts to what you already intuitively know, to add camera functionality to your game. Why could a camera be important? It gives dimension to a 2D game and is required for 3D games. You couldn't have a true 3D game without a camera (although you can fake to a certain extent with art). In a 2D game a camera could add functionality like a mini-map. The basics of using a camera There are a few basic points to know when getting started using a Camera object. There are 2 types of cameras: perspective camera and orthographic camera. Perspective camera can be thought of as how we see every day objects...near and far. Orthographic camera can be thought of as a flat, top down view to a Scene. Every Scene automatically creates a default camera, based on the projection properties of the Director object. For more detailed information, please review the camera documentation. Getting Started Creating a demo project The easiest thing to do is to run cocos new CameraDemo -l cpp -d . to create a new Cocos project. We can re-use the default HelloWorldScene class to get us started. Housekeeping First, to be sure, let's create a few variables to help us with screen size and then quickly navigate around the screen as needed. Example, using origin and visibleSize that are already defined in the default class: cocos2d::Vec2 centerPosition = cocos2d::Vec2(visibleSize.width / 2.f, visibleSize.height / 2.f); cocos2d::Vec2 leftPosition = cocos2d::Vec2(visibleSize.width / 4.f, visibleSize.height / 2.f); cocos2d::Vec2 rightPosition = cocos2d::Vec2((visibleSize.width / 2.f + visibleSize.width / 4.f), visibleSize.height / 2.f); Second, let's create a few Sprite objects to use in our Scene. Maybe just two: /* Creatingthe sprites */ /* Sprite 1 */ auto alien1 = Sprite::create(\"Blue_Front1.png\"); alien1->setPosition(leftPosition); this->addChild(alien1); /* Sprite 2 */ auto alien2 = Sprite::create(\"White_Front1.png\"); alien2->setPosition(rightPosition); this->addChild(alien2); Creating a camera You can create as many Camera objects as you need although it is wise to use care and consider the task at hand before creating many Camera objects to handle tasks other methods are better suited to handle. "},"faq/":{"url":"faq/","title":"解决方案常见问题","keywords":"","body":"解决方案常见问题 Android CMake Linux MacOS Windows "},"faq/android.html":{"url":"faq/android.html","title":"Android","keywords":"","body":"Android generateJsonModelDebug FAILED To solve this issue, please import the project into Android Studio, click Build/Refresh Linked C++ Projects. Android Studio uses the ninja build system Android Studio, itself, uses ninja to build native codes. There is ninja binary under Cmake folder. If Android Studio cannot find ninja on Windows, it is the Android Studio issue. You should set an environment variable that specifies the path to ninja: ninja binaries are available as is ninja documentation. "},"faq/cmake.html":{"url":"faq/cmake.html","title":"CMake","keywords":"","body":"CMake CMake PIE It may be necessary to add the following line to CMakeLists.txt if a can not be used when making a PIE object; compiler is thrown: set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -no-pie -fexceptions -std=c++11 -Wno-deprecated-declarations -Wno-reorder\") "},"faq/linux.html":{"url":"faq/linux.html","title":"Linux","keywords":"","body":"Linux FMod issues Some users report issues with libfmod. If you encounter issues, please reference this post: Error while building for linux: libfmod.so.6 "},"faq/macos.html":{"url":"faq/macos.html","title":"MacOS","keywords":"","body":"MacOS XCode PNG Compression issue It is possible that your PNG images contain incorrect color profiles. You can convert color profiles using ImageMagick and the following command: find . -type f -name \"*.png\" -exec convert {} \\; "},"faq/windows.html":{"url":"faq/windows.html","title":"Windows","keywords":"","body":"Windows Re-target the Windows SDK If you see these types of errors: This is because the template project was created in an older version of Visual Studio. To fix: Right click on every project select Retarget Projects click Ok. Next, rebuild the project. If you create a new project in the future you will need to repeat these steps. Distributing a Cocos2d-x app on Windows Note: this falls outside of the realm of Cocos2d-x. Please consult Microsoft resources for assistance. If you try to run a game created with Cocos2d-x on a non-development machine, it may be required for this machine to have the Visual Studio runtime installed. The easiest way is to create an installer for your game, but it is possible to do it without by installing all required pieces manually. Use Dependency Walker to check what DLLs your game requires. Install the required Visual Studio runtime. Microsoft has now merged VS2015, 2017 and 2019 runtimes into one, which you can find here. For the installer, check these posts: InnoSetup (also shows you a sample for how to install the VS C++ runtime using it). Sample InnoSetup script for Cocos2d-x here. "},"about/":{"url":"about/","title":"引擎优势","keywords":"","body":"引擎优势 Cocos2d-x 是 MIT 许可证下发布的一款功能强大的开源游戏引擎。 允许开发人员使用 C++、Javascript 及 Lua 三种语言来进行游戏开发。 支持所有常见平台，包括 iOS、Android、Windows、macOS、Linux。 引擎特性 现代化的 C++ API 立足于 C++ 同时支持 JavaScript/Lua 作为开发语言 可以跨平台部署, 支持 iOS、Android、Windows、macOS 和 Linux 可以在 PC 端完成游戏的测试，最终发布到移动端 完善的游戏功能支持，包含精灵、动作、动画、粒子特效、场景转换、事件、文件 IO、数据持久化、骨骼动画、3D 市场占有 Cocos2d-x 用户不仅包括个人开发者和游戏开发爱好者，还包括许多知名大公司如 Zynga、Wooga、Gamevil、Glu、GREE、Konami、TinyCo、HandyGames、IGG 及 Disney Mobile 等。 使用 Cocos2d-x 开发的许多游戏占据苹果应用商店和谷歌应用商店排行榜，同时许多公司如触控、谷歌、微软、ARM，英特尔及黑莓的工程师在 Cocos2d-x 领域也非常活跃。 在中国，每一年的手游榜单大作，Cocos2d-x 从未缺席，市场份额占 50% 以上，游戏品类覆盖从轻度休闲，热火棋牌，到横版，SLG，重度 MMO 等市面全品类。一些以 Cocos2d-x 为基础开发出的游戏如下： 您可以从 官网页面 下载一个正式发布版本，也可以直接从 GitHub 克隆。无论您用 C++、JavaScript 还是 Lua 语言进行游戏开发，只需要下载这一个引擎。 "}}